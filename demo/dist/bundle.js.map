{"version":3,"file":"bundle.js","mappings":";;;;;;;;;;;;;;;;;AAA8C;AACS;AACK;AAC5D;AACA;AACA;AACA;AACO,mBAAmB,mDAAM;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA,cAAc,0BAA0B;AACxC,cAAc,0BAA0B;AACxC,cAAc,4BAA4B;AAC1C,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,OAAO;AACtB;AACA;AACA,iCAAiC,kEAAkB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0BAA0B;AACzC,eAAe,YAAY;AAC3B,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB;AACA,+BAA+B,iEAAW;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,4BAA4B,oBAAoB;AAChD,kEAAkE,mBAAmB;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iBAAiB;AAC7C;AACA;AACA;AACA;AACA,wDAAwD;AACxD,4DAA4D;AAC5D,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACzKuD;AACK;AACd;AAC9C;AACA;AACA;AACO,oCAAoC,mDAAM;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA,cAAc,2BAA2B;AACzC,cAAc,6BAA6B;AAC3C,cAAc,6BAA6B;AAC3C,cAAc,6BAA6B;AAC3C,cAAc,6BAA6B;AAC3C,cAAc,6BAA6B;AAC3C,cAAc,6BAA6B;AAC3C,cAAc,6BAA6B;AAC3C,cAAc,6BAA6B;AAC3C,cAAc,6BAA6B;AAC3C,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,OAAO;AACtB;AACA;AACA,iCAAiC,kEAAkB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0BAA0B;AACzC,eAAe,YAAY;AAC3B,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB;AACA,+BAA+B,iEAAW;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,SAAS,MAAM;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA,4BAA4B,wBAAwB;AACpD;AACA,kEAAkE,uBAAuB;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iBAAiB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,oDAAoD;AACpD,4DAA4D;AAC5D,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AClNuD;AACK;AACd;AAC9C;AACA;AACA;AACA;AACA;AACO,sBAAsB,mDAAM;AACnC;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B,wBAAwB,OAAO;AAC/B;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA,oBAAoB,OAAO;AAC3B,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA,4BAA4B,OAAO;AACnC,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA,4BAA4B,OAAO;AACnC;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B,4BAA4B,OAAO;AACnC;AACA,oBAAoB,OAAO;AAC3B;AACA,4BAA4B,OAAO;AACnC;AACA,4BAA4B,OAAO;AACnC,4BAA4B,OAAO;AACnC;AACA;AACA,oBAAoB,OAAO;AAC3B,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA,oBAAoB,OAAO;AAC3B;AACA,wBAAwB,OAAO;AAC/B;AACA,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA,wBAAwB,OAAO;AAC/B;AACA,yBAAyB,QAAQ;AACjC;AACA;AACA;AACA,gCAAgC,OAAO;AACvC;AACA,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;AACA,0BAA0B,QAAQ;AAClC;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA,kCAAkC,qBAAqB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,UAAU;AAClC;AACA;AACA;AACA;AACA;AACA,6CAA6C,mCAAmC;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B,wBAAwB,wBAAwB,OAAO;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA,8CAA8C,kBAAkB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA,wBAAwB,wBAAwB,OAAO;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,WAAW;AACtC,+BAA+B,WAAW;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,OAAO;AACtB;AACA;AACA,iCAAiC,kEAAkB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0BAA0B;AACzC,eAAe,YAAY;AAC3B,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB;AACA,+BAA+B,iEAAW;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC9gByD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,eAAe,0BAA0B;AACzC,eAAe,YAAY;AAC3B;AACA,+BAA+B,iEAAW;AAC1C;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,0BAA0B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0BAA0B;AACzC,eAAe,YAAY;AAC3B;AACA,+BAA+B,iEAAW;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,0BAA0B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,wBAAwB,eAAe;AACvC,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0BAA0B;AACzC,eAAe,YAAY;AAC3B;AACA,+BAA+B,iEAAW;AAC1C;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,0BAA0B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA,8BAA8B;AAC9B,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oBAAoB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;;;;;;;;;;;;;;;;;AC9N6C;AACY;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,eAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,gCAAgC,sDAAc;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0BAA0B;AACzC,eAAe,YAAY;AAC3B;AACA,+BAA+B,iEAAW;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,0BAA0B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;;;ACrGyC;AACzC;AACA;AACA;AACA;AACO,uBAAuB,kDAAO;AACrC;AACA;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,cAAc,aAAa;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;AC3H6C;AACO;AACV;AACM;AACF;AACiB;AACE;AACN;AAC3D;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,kEAAkB;AACnD,sCAAsC,kDAAK;AAC3C,wCAAwC,qDAAO;AAC/C;AACA;AACA,iCAAiC,qEAAqB;AACtD,yCAAyC,wDAAQ;AACjD,wCAAwC,qDAAO;AAC/C;AACA;AACA,iCAAiC,oEAAoB;AACrD,wCAAwC,sDAAO;AAC/C,wCAAwC,qDAAO;AAC/C;AACA;AACA,iCAAiC,kEAAkB;AACnD,2CAA2C,mEAAa;AACxD,wCAAwC,qDAAO;AAC/C;AACA;AACA,iCAAiC,qEAAqB;AACtD,8CAA8C,yEAAgB;AAC9D,wCAAwC,qDAAO;AAC/C;AACA;AACA,iCAAiC,oEAAoB;AACrD,6CAA6C,uEAAe;AAC5D,wCAAwC,qDAAO;AAC/C;AACA;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;;;;ACnIA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8BAA8B;AAC/B;AACA;AACA;AACA;AACA;AACO;AACP;;;;;;;;;;;;;;;;;;;;;;;;;ACpBoD;AACE;AACT;AACA;AACH;AAC6D;AAC7D;AACM;AACF;AACvC;AACP;AACA;AACA;AACA;AACA,CAAC,4CAA4C;AAC7C;AACA;AACA;AACA;AACA;AACO,qBAAqB,kDAAO;AACnC;AACA;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA,oHAAoH;AACpH;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,6DAAiB;AACxD,sCAAsC,4DAAgB;AACtD,yCAAyC,4DAAgB;AACzD;AACA;AACA;AACA;AACA,0DAA0D,cAAc,aAAa;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,8DAAY;AAChD;AACA,oCAAoC,8DAAY;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,kBAAkB;AAChF;AACA;AACA;AACA;AACA;AACA,8DAA8D,kBAAkB;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kDAAK;AACxB;AACA;AACA;AACA;AACA;AACA,yDAAyD,kDAAK;AAC9D;AACA,mCAAmC,qDAAO,YAAY,wDAAY;AAClE;AACA;AACA;AACA,8DAA8D,wDAAQ;AACtE;AACA;AACA,sCAAsC,kDAAK;AAC3C,uCAAuC,qDAAO,YAAY,wDAAY;AACtE;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA,8DAA8D,sDAAO;AACrE;AACA;AACA;AACA,0CAA0C,kDAAK;AAC/C,2CAA2C,qDAAO,YAAY,wDAAY;AAC1E;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,+BAA+B;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,kEAAkB;AAC1E,kCAAkC,kDAAK;AACvC,oCAAoC,qDAAO,UAAU;AACrD;AACA;AACA;AACA,6DAA6D,oEAAoB;AACjF;AACA;AACA,sCAAsC,kDAAK;AAC3C,wCAAwC,qDAAO;AAC/C;AACA;AACA;AACA;AACA;AACA,uCAAuC,kDAAK;AAC5C,yCAAyC,qDAAO;AAChD;AACA;AACA;AACA;AACA,qCAAqC,wDAAQ;AAC7C,+CAA+C,qDAAO;AACtD;AACA;AACA;AACA;AACA,uCAAuC,kDAAK;AAC5C,yCAAyC,qDAAO;AAChD;AACA;AACA;AACA;AACA,wCAAwC,sDAAO;AAC/C,+CAA+C,qDAAO;AACtD;AACA;AACA;AACA;AACA,6DAA6D,qEAAqB;AAClF;AACA;AACA,sCAAsC,kDAAK;AAC3C,wCAAwC,qDAAO;AAC/C;AACA;AACA;AACA;AACA;AACA,uCAAuC,kDAAK;AAC5C,yCAAyC,qDAAO;AAChD;AACA;AACA;AACA;AACA,qCAAqC,wDAAQ;AAC7C,+CAA+C,qDAAO;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,oEAAoB;AAC5E;AACA;AACA;AACA,wCAAwC,sDAAO;AAC/C,wCAAwC,qDAAO,YAAY;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,qEAAqB;AAClF;AACA;AACA;AACA,yCAAyC,wDAAQ;AACjD,wCAAwC,qDAAO,aAAa;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E,kDAAK;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,oEAAoB;AAC5E;AACA;AACA;AACA;AACA;AACA,qCAAqC,wDAAQ;AAC7C,+CAA+C,qDAAO;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,sDAAO;AAC/C,+CAA+C,qDAAO;AACtD;AACA;AACA;AACA,6DAA6D,qEAAqB;AAClF;AACA;AACA;AACA;AACA;AACA,qCAAqC,wDAAQ;AAC7C,+CAA+C,qDAAO;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,kDAAK;AAC9D;AACA;AACA;AACA;AACA,8DAA8D,wDAAQ;AACtE;AACA;AACA;AACA;AACA;AACA,0CAA0C,kDAAK;AAC/C;AACA,2CAA2C,qDAAO,YAAY,wDAAY;AAC1E;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,sDAAO;AACrE;AACA;AACA;AACA;AACA;AACA,0CAA0C,kDAAK;AAC/C;AACA,2CAA2C,qDAAO,YAAY,wDAAY;AAC1E;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACpgBsF;AAC7B;AACf;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,sBAAsB,kDAAO;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,eAAe,UAAU;AACzB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0BAA0B;AACzC,eAAe,YAAY;AAC3B,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB;AACA,+BAA+B,iEAAW,4CAA4C,6DAAiB;AACvG;AACA,2EAA2E,yDAAa;AACxF;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,0BAA0B;AACzC,eAAe,YAAY;AAC3B,eAAe,kBAAkB;AACjC;AACA,uCAAuC,iEAAW,iBAAiB,4DAAgB;AACnF;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,OAAO;AACtB,gBAAgB,SAAS;AACzB;AACA,+BAA+B,iEAAW;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,8EAA8E,kDAAkD;AAChI,6CAA6C,mDAAmD;AAChG;AACA;AACA,6EAA6E,kDAAkD;AAC/H,4CAA4C,mDAAmD;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACjLyD;AACf;AAC1C;AACA;AACA;AACA;AACA;AACO,sBAAsB,kDAAO;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,eAAe,UAAU;AACzB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0BAA0B;AACzC,eAAe,YAAY;AAC3B,eAAe,OAAO;AACtB;AACA,+BAA+B,iEAAW;AAC1C;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,OAAO;AACtB,gBAAgB,SAAS;AACzB;AACA,+BAA+B,iEAAW;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,mDAAmD;AAChG;AACA;AACA,4CAA4C,mDAAmD;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACnGsC;AACmB;AACzD;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA,0BAA0B,8CAAK;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0BAA0B;AACzC,eAAe,YAAY;AAC3B,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB;AACA,+BAA+B,iEAAW;AAC1C;AACA;;;;;;;;;;;;;;;ACrDA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;;;;;;;;AChDsC;AACiC;AACd;AACzD;AACA;AACA,UAAU;AACV;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wCAAwC;AACzC;AACA;AACA,UAAU;AACV;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC;AACrC;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA,eAAe,0BAA0B;AACzC,eAAe,YAAY;AAC3B,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB;AACA,+BAA+B,iEAAW,4CAA4C,6DAAiB;AACvG;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB,SAAS;AACzB;AACA,gCAAgC;AAChC;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,OAAO;AACtB,gBAAgB,SAAS;AACzB;AACA,+BAA+B,iEAAW;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,0BAA0B;AACzC,eAAe,YAAY;AAC3B,eAAe,kBAAkB;AACjC;AACA,sCAAsC,iEAAW,iBAAiB,4DAAgB;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,0BAA0B;AACzC,eAAe,YAAY;AAC3B,eAAe,kBAAkB;AACjC;AACA,wCAAwC,iEAAW,iBAAiB,4DAAgB;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,8CAAK;AACxB;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B,eAAe,YAAY;AAC3B,gBAAgB,UAAU;AAC1B;AACA,6DAA6D,iEAAW;AACxE;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B,gBAAgB,UAAU;AAC1B;AACA,8BAA8B,iEAAW;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,gBAAgB;AAC/B,eAAe,0BAA0B;AACzC,eAAe,YAAY;AAC3B,gBAAgB,QAAQ;AACxB;AACA,mDAAmD,iEAAW;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,eAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC7SA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACsD;AAChB;AACmC;AAChB;AACzD;AACA;AACA;AACA;AACA;AACO,4BAA4B,+CAAQ;AAC3C;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,0BAA0B,8CAAK;AAC/B;AACA;AACA;AACA;AACA,eAAe,0BAA0B;AACzC,eAAe,YAAY;AAC3B,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB;AACA,+BAA+B,iEAAW,4CAA4C,6DAAiB;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB,SAAS;AACzB;AACA;AACA;AACA,wCAAwC,6DAAiB;AACzD;AACA;AACA,6CAA6C,8DAAkB;AAC/D;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B,eAAe,YAAY;AAC3B,gBAAgB,UAAU;AAC1B;AACA,qBAAqB,4DAAqB,mBAAmB,iEAAW;AACxE;AACA;AACA,mBAAmB,4DAAqB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACjHsD;AAChB;AACc;AACK;AACzD;AACA;AACA;AACA;AACA;AACO,8BAA8B,+CAAQ;AAC7C;AACA;AACA,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT,0BAA0B,8CAAK;AAC/B;AACA;AACA;AACA;AACA,eAAe,0BAA0B;AACzC,eAAe,YAAY;AAC3B,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB;AACA,+BAA+B,iEAAW,4CAA4C,4DAAgB;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,eAAe;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B,eAAe,YAAY;AAC3B,gBAAgB,UAAU;AAC1B;AACA,qBAAqB,4DAAqB,mBAAmB,iEAAW;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA,iCAAiC,SAAS;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,4DAAqB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACxJsD;AAChB;AACc;AACK;AACnB;AACtC;AACA;AACA;AACA;AACA;AACA;AACO,+BAA+B,+CAAQ;AAC9C;AACA;AACA,eAAe,aAAa;AAC5B;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT,0BAA0B,8CAAK;AAC/B;AACA;AACA;AACA;AACA,eAAe,0BAA0B;AACzC,eAAe,YAAY;AAC3B,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB;AACA,+BAA+B,iEAAW,4CAA4C,4DAAgB;AACtG;AACA;AACA;AACA;AACA,0BAA0B,yDAAkB;AAC5C;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B,eAAe,YAAY;AAC3B,gBAAgB,UAAU;AAC1B;AACA,qBAAqB,4DAAqB,mBAAmB,iEAAW;AACxE;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC,kCAAkC,aAAa;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,aAAa;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,4DAAqB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;;;;;;;;;;;;;;;;;;;ACnKhC,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACsD;AAChB;AACe;AACI;AACzD;AACA;AACA;AACO,oBAAoB,+CAAQ;AACnC;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA,0BAA0B,8CAAK;AAC/B;AACA;AACA;AACA;AACA,eAAe,0BAA0B;AACzC,eAAe,YAAY;AAC3B,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,8CAAK;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0BAA0B;AACzC,eAAe,YAAY;AAC3B,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB;AACA,+BAA+B,iEAAW,4CAA4C,6DAAiB;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B,eAAe,YAAY;AAC3B,gBAAgB,UAAU;AAC1B;AACA,qBAAqB,4DAAqB,mBAAmB,iEAAW;AACxE;AACA;AACA,qBAAqB,4DAAqB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACjJsD;AAChB;AACc;AACK;AACzD;AACA;AACA;AACA;AACA;AACO,sBAAsB,+CAAQ;AACrC;AACA;AACA,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT,0BAA0B,8CAAK;AAC/B;AACA;AACA;AACA;AACA,eAAe,0BAA0B;AACzC,eAAe,YAAY;AAC3B,eAAe,UAAU;AACzB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,eAAe,0BAA0B;AACzC,eAAe,YAAY;AAC3B,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB;AACA,+BAA+B,iEAAW,4CAA4C,4DAAgB;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,4BAA4B,iBAAiB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,EAAE;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,eAAe;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B,eAAe,YAAY;AAC3B,gBAAgB,UAAU;AAC1B;AACA,qBAAqB,4DAAqB,mBAAmB,iEAAW;AACxE;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA,iCAAiC,SAAS;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,4DAAqB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B,gBAAgB,QAAQ;AACxB;AACA,+BAA+B,iEAAW;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B,gBAAgB,QAAQ;AACxB;AACA,6BAA6B,iEAAW;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACxPsD;AAChB;AACc;AACK;AACzD;AACA;AACA;AACA;AACA;AACO,uBAAuB,+CAAQ;AACtC;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,0BAA0B,8CAAK;AAC/B;AACA;AACA;AACA;AACA,eAAe,0BAA0B;AACzC,eAAe,YAAY;AAC3B,eAAe,UAAU;AACzB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0BAA0B;AACzC,eAAe,YAAY;AAC3B,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB;AACA,+BAA+B,iEAAW,4CAA4C,4DAAgB;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B,eAAe,YAAY;AAC3B,gBAAgB,UAAU;AAC1B;AACA,qBAAqB,4DAAqB,mBAAmB,iEAAW;AACxE;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC,kCAAkC,aAAa;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,aAAa;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,4DAAqB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B,gBAAgB,QAAQ;AACxB;AACA,+BAA+B,iEAAW;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;AC1OyC;AACM;AACH;AACC;AACiB;AACJ;AACjB;AACuB;AACwB;AACxF;AACA;AACA;AACA;AACO,mBAAmB,kDAAO;AACjC;AACA;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA,0DAA0D,cAAc,aAAa;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,GAAG,iBAAiB,EAAE,gBAAgB,EAAE,gBAAgB,EAAE;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,eAAe;AAC9C,mCAAmC,eAAe;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,kDAAK;AACxD,iDAAiD,6DAAiB;AAClE;AACA;AACA,mDAAmD,wDAAQ;AAC3D,iDAAiD,4DAAgB;AACjE;AACA;AACA,mDAAmD,sDAAO;AAC1D,iDAAiD,4DAAgB;AACjE;AACA;AACA,mDAAmD,mEAAa;AAChE,iDAAiD,6DAAiB;AAClE;AACA;AACA,mDAAmD,yEAAgB;AACnE,iDAAiD,4DAAgB;AACjE;AACA;AACA,mDAAmD,uEAAe;AAClE,iDAAiD,4DAAgB;AACjE;AACA;AACA,gDAAgD,qDAAO;AACvD;AACA,yBAAyB;AACzB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACxJsB;AACG;AACA;AACY;AACR;AACG;AACE;AACA;AACE;AACH;AACG;AACD;AACO;AACG;AACD;AACd;AACQ;AACA;AACJ;AACJ;AACI;AACF;AACI;AACO;AACE;AACH;AACF;AACA;AACE;AACR;AACC;AACU;AACd;AACF;AACA;AACE;AACO;AACS;AACd;AACI;AACY;AACZ;AAC4B;AAC1C;AACI;AACJ;;;;;;;;;;;;;;;;;;;;;AC7C+B;AACG;AACL;AACpD;AACA;AACA;AACO;AACP;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,OAAO;AACtB,eAAe,kBAAkB;AACjC,eAAe,0BAA0B;AACzC,eAAe,YAAY;AAC3B,gBAAgB,WAAW;AAC3B;AACA,wDAAwD,iEAAW,MAAM;AACzE;AACA;AACA;AACA;AACO;AACP;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,OAAO;AACtB,eAAe,kBAAkB;AACjC,eAAe,0BAA0B;AACzC,eAAe,YAAY;AAC3B,gBAAgB,WAAW;AAC3B;AACA,wDAAwD,iEAAW;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,OAAO;AACtB,eAAe,kBAAkB;AACjC,eAAe,0BAA0B;AACzC,eAAe,YAAY;AAC3B,gBAAgB,WAAW;AAC3B;AACA,wDAAwD,iEAAW;AACnE;AACA;AACA;AACA,sEAAsE,qEAAqB;AAC3F;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS,OAAO;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,OAAO;AACtB,eAAe,kBAAkB;AACjC,eAAe,0BAA0B;AACzC,eAAe,YAAY;AAC3B,gBAAgB,WAAW;AAC3B;AACA,wDAAwD,iEAAW;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,4DAAgB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,OAAO;AAChB;AACA;;;;;;;;;;;;;;;;;;ACzJoD;AACN;AACW;AACzD;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,4DAAgB;AAC1C;AACA;AACA;AACA,6BAA6B,uDAAe;AAC5C;AACA;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,0BAA0B;AACzC,eAAe,YAAY;AAC3B;AACA,yCAAyC,iEAAW;AACpD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;;;;;;;;;ACjCgC;AACyB;AACW;AAC1B;AACO;AACjD;AACA;AACA;AACA,UAAU;AACV;AACO;AACP;AACA;AACA;AACA;AACA;AACA,CAAC,kCAAkC;AAC5B,2BAA2B,yCAAK;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,eAAe,0BAA0B;AACzC,eAAe,YAAY;AAC3B,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB;AACA,+BAA+B,iEAAW;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,2CAA2C,kEAAkB;AAC7D;AACA,gDAAgD,kDAAK;AACrD;AACA;AACA,mFAAmF,qEAAqB;AACxG;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,uCAAuC,wBAAwB;AAC/D;AACA;AACA;AACA,iBAAiB,OAAO,KAAK,eAAe;AAC5C;AACA;AACA;AACA;AACA;AACA,6IAA6I,yDAAa;AAC1J;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,eAAe,0BAA0B;AACzC,eAAe,YAAY;AAC3B,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB;AACA,oCAAoC,iEAAW;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,EAAE;AACf;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,kBAAkB;AAClB,8BAA8B,uBAAuB;AACrD;AACA;AACA,aAAa,OAAO,KAAK,eAAe;AACxC;AACA;AACA,aAAa,EAAE;AACf;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,YAAY;AAC3B,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB,SAAS;AACzB;AACA,+CAA+C,iEAAW;AAC1D;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,mDAAmD,0DAA0D;AAC7G;AACA;AACA,gDAAgD,0DAA0D;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC5RgC;AACyB;AACzD;AACA;AACA;AACO,2BAA2B,yCAAK;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0BAA0B;AACzC,eAAe,YAAY;AAC3B,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB;AACA,+BAA+B,iEAAW;AAC1C;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,YAAY;AAC3B,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB,SAAS;AACzB;AACA,+CAA+C,iEAAW;AAC1D;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,mDAAmD,0DAA0D;AAC7G;AACA;AACA,gDAAgD,0DAA0D;AAC1G;AACA;AACA,oDAAoD,0DAA0D;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC9HyD;AACf;AAC1C;AACA;AACA;AACO,oBAAoB,kDAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0BAA0B;AACzC,eAAe,YAAY;AAC3B,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB;AACA,+BAA+B,iEAAW;AAC1C;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,YAAY;AAC3B,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB,SAAS;AACzB;AACA,+CAA+C,iEAAW,+DAA+D;AACzH;;;;;;;;;;;;;;;;;ACpFyD;AACzB;AAChC;AACA;AACA;AACO,0BAA0B,yCAAK;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0BAA0B;AACzC,eAAe,YAAY;AAC3B,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB;AACA,+BAA+B,iEAAW;AAC1C;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC3BqD;AAChB;AACmB;AACH;AACT;AACH;AACA;AACP;AACO;AACG;AACN;AACG;AACiB;AACX;AACiB;AACwB;AAC1B;AACjB;AACf;AACA;AACQ;AACtC;AACA;AACA;AACA;AACO,kBAAkB,kDAAO;AAChC;AACA;AACA,eAAe,yBAAyB;AACxC,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,8DAAY;AACpD;AACA,mCAAmC,8DAAY;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,cAAc,aAAa;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,2CAAM;AACjC,6CAA6C,2DAAgB,gCAAgC;AAC7F,4CAA4C,8DAAmB,gCAAgC;AAC/F;AACA,2BAA2B,kDAAM;AACjC,6CAA6C,2DAAgB,gCAAgC;AAC7F,4CAA4C,8DAAmB,gCAAgC;AAC/F,6CAA6C,wBAAwB;AACrE,4CAA4C,wBAAwB;AACpE;AACA,6BAA6B,gDAAQ;AACrC;AACA,6BAA6B,gDAAQ;AACrC;AACA,yBAAyB,wCAAI;AAC7B;AACA,yBAAyB,wCAAI;AAC7B;AACA,4BAA4B,qDAAO;AACnC,+BAA+B,iEAAW;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,8DAAiB;AAC1D;AACA;AACA,wCAAwC,6DAAgB;AACxD;AACA;AACA,2CAA2C,6DAAgB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA,sEAAsE;AACtE,uEAAuE;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA,gCAAgC,mDAAK,wBAAwB,oEAAa;AAC1E,yCAAyC,qDAAO;AAChD;AACA,qCAAqC,yDAAQ,wBAAwB,0EAAgB;AACrF,yCAAyC,qDAAO;AAChD;AACA,qCAAqC,uDAAO,wBAAwB,wEAAe;AACnF,yCAAyC,qDAAO;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,8CAAK;AAChC;AACA,+DAA+D,6EAA6E;AAC5I,8BAA8B,8EAA8E;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA6E;AAC7E;AACA,6EAA6E;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA6E;AAC7E;AACA,6EAA6E;AAC7E;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA,gFAAgF;AAChF;AACA;AACA;AACA,UAAU;AACV;AACA,gCAAgC,wEAAwE;AACxG;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC,gEAAgE;AAChE;AACA;AACA,4EAA4E;AAC5E,+EAA+E;AAC/E;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,aAAa;AACb;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA,yHAAyH;AACzH;AACA,yHAAyH;AACzH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,wEAAwE;AACtG;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,OAAO;AACtB;AACA;AACA;AACA,kDAAkD,yEAAyB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;AC9sBqD;AACA;AACT;AACH;AACiE;AACjE;AACM;AACF;AACtC;AACP;AACA;AACA;AACA;AACA,CAAC,8CAA8C;AAC/C;AACA;AACA;AACO,uBAAuB,kDAAO;AACrC;AACA;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA,oHAAoH;AACpH;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,6DAAiB;AACxD,sCAAsC,4DAAgB;AACtD,yCAAyC,4DAAgB;AACzD;AACA;AACA;AACA;AACA,0DAA0D,cAAc,aAAa;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,8DAAY;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,8DAAY;AAC5C;AACA;AACA;AACA;AACA,gCAAgC,8DAAY;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,kDAAK;AACvC,oCAAoC,qDAAO;AAC3C;AACA;AACA;AACA;AACA;AACA,mCAAmC,kDAAK;AACxC,qCAAqC,qDAAO;AAC5C;AACA;AACA;AACA;AACA,iCAAiC,wDAAQ;AACzC,2CAA2C,qDAAO;AAClD;AACA;AACA;AACA;AACA,mCAAmC,kDAAK;AACxC,qCAAqC,qDAAO;AAC5C;AACA;AACA;AACA;AACA,oCAAoC,sDAAO;AAC3C,2CAA2C,qDAAO;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,kDAAK;AACvC,oCAAoC,qDAAO;AAC3C;AACA;AACA;AACA;AACA;AACA,mCAAmC,kDAAK;AACxC,qCAAqC,qDAAO;AAC5C;AACA;AACA;AACA;AACA,iCAAiC,wDAAQ;AACzC,2CAA2C,qDAAO;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,sDAAO;AAC3C,oCAAoC,qDAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,wDAAQ;AAC7C,oCAAoC,qDAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,4DAAgB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,yEAAyB;AACjE,gCAAgC,wDAAQ;AACxC;AACA;AACA;AACA;AACA,qCAAqC,sDAAO;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,wDAAQ;AACzC,2CAA2C,qDAAO;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,sDAAO;AAC3C,2CAA2C,qDAAO;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,wDAAQ;AACzC,2CAA2C,qDAAO;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACvTsC;AACgB;AACtB;AAChC;AACA;AACA;AACA;AACA;AACA;AACO,mBAAmB,mDAAU;AACpC;AACA;AACA;AACA,eAAe,YAAY;AAC3B;AACA,uBAAuB,uDAAc;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,8CAAK;AACxB;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA,0BAA0B,uDAAc;AACxC,yBAAyB,sDAAkB;AAC3C;AACA;AACA,+BAA+B,yDAAgB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F;AAC/F;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,uDAAc;AAC5C;AACA,6BAA6B,sDAAkB;AAC/C;AACA,mCAAmC,yDAAgB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC7GsC;AACgB;AACtD;AACA;AACA;AACA;AACA;AACO,oBAAoB,mDAAU;AACrC;AACA;AACA;AACA,eAAe,YAAY;AAC3B;AACA,uBAAuB,uDAAc;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,8CAAK;AACxB;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB,UAAU;AAC1B;AACA;AACA,0BAA0B,uDAAc;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,SAAS;AACxB,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA;AACA;AACA,8BAA8B,uDAAc;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACxIsC;AACtC;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB,UAAU;AAC1B;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB,UAAU;AAC1B;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA,kBAAkB,WAAW,8CAAK;AAClC;AACA;;;;;;;;;;;;;;;;AC9BA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB,UAAU;AAC1B;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB,UAAU;AAC1B;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;;;;;;;;;;;;;;;;;ACnDsC;AACI;AAC1C;AACA;AACA;AACO,0BAA0B,mDAAU;AAC3C;AACA;AACA;AACA;AACA,mBAAmB,8CAAK;AACxB;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACvCyF;AACrC;AACd;AACtC;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,kEAAkB;AAC3C,4CAA4C,6DAAiB;AAC7D,4CAA4C,qDAAY;AACxD,8CAA8C,qDAAY;AAC1D;AACA;AACA;AACA;AACA,yBAAyB,qEAAqB;AAC9C,4CAA4C,4DAAgB;AAC5D,8CAA8C,qDAAY;AAC1D;AACA;AACA;AACA;AACA,yBAAyB,oEAAoB;AAC7C,4CAA4C,4DAAgB;AAC5D,4CAA4C,qDAAY;AACxD,8CAA8C,qDAAY;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC1FyF;AACrC;AACd;AACtC;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,IAAI,8CAA8C;AAC3D,wBAAwB,YAAY;AACpC;AACA;AACA,qBAAqB,kEAAkB;AACvC,wCAAwC,6DAAiB;AACzD,wCAAwC,qDAAY;AACpD,0CAA0C,qDAAY;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,qEAAqB;AAC1C,wCAAwC,4DAAgB;AACxD,0CAA0C,qDAAY;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,oEAAoB;AACzC,wCAAwC,4DAAgB;AACxD,wCAAwC,qDAAY;AACpD,0CAA0C,qDAAY;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC3FqD;AACrD;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,6DAAiB;AAC5C;AACA;AACA;AACA;;;;;;;;;;;;;;;;AClBqD;AAC9C;AACP,yBAAyB,WAAW,6DAAiB;AACrD;;;;;;;;;;;;;;;ACHA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACPsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,eAAe,0BAA0B;AACzC,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACO;AACP;AACA;AACA,eAAe,0BAA0B;AACzC,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,eAAe,0BAA0B;AACzC,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0BAA0B;AACzC,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA,eAAe,0BAA0B;AACzC,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,eAAe,0BAA0B;AACzC,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0BAA0B;AACzC,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,eAAe,0BAA0B;AACzC,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0BAA0B;AACzC,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0BAA0B;AACzC,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mDAAU,CAAC,sDAAa,mBAAmB,sDAAa;AAC/E;AACA;AACA;AACA;AACA,eAAe,0BAA0B;AACzC,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0BAA0B;AACzC,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AClwByC;AACzC;AACA;AACA;AACA;AACO,mBAAmB,kDAAO;AACjC;AACA;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA,6DAA6D,cAAc,aAAa;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,EAAE,gBAAgB,EAAE,gBAAgB,EAAE;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,eAAe;AAC9C,mCAAmC,eAAe;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACxF0C;AAC1C;AACA;AACA;AACO;AACP;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA,QAAQ,2DAAgB;AACxB;AACA;AACA;AACA,QAAQ,2DAAgB;AACxB;AACA;AACA;AACA,QAAQ,2DAAgB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,sBAAsB;AACrC,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,2DAA2D,sDAAsD;AAC1K,QAAQ,8DAAmB;AAC3B,QAAQ,8DAAmB;AAC3B,QAAQ,8DAAmB;AAC3B,QAAQ,8DAAmB;AAC3B;AACA,YAAY,2DAAgB;AAC5B,YAAY,2DAAgB;AAC5B;AACA;AACA,YAAY,2DAAgB;AAC5B,YAAY,2DAAgB;AAC5B;AACA,gEAAgE,2BAA2B,yBAAyB;AACpH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACzGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA,kCAAkC,EAAE,aAAa,EAAE,aAAa,EAAE;AAClE;AACA;AACA;AACA;AACA;AACA,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA,wBAAwB,WAAW;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA,wCAAwC;AACxC,SAAS;AACT;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AChDA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,QAAQ;AACvB,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACpFqD;AACZ;AACzC;AACA;AACA;AACA;AACA;AACO,qBAAqB,kDAAO;AACnC;AACA;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,cAAc,YAAY;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,8DAAY;AAC5D;AACA;AACA;AACA;AACA,gDAAgD,8DAAY;AAC5D;AACA;AACA;AACA;AACA;AACA,qEAAqE,8DAAY;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF,8DAAY,0CAA0C,8DAAY;AAC3J;AACA,SAAS;AACT,sDAAsD,8DAAY;AAClE;AACA,SAAS;AACT;AACA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;UCnJA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;ACKiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,oBAAoB,sCAAG;AACvB;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,6BAA6B,+CAAY,CAAC,qDAAkB;AAC5D,sBAAsB,wCAAK;AAC3B;AACA,iBAAiB,mDAAgB;AACjC;AACA,oBAAoB,YAAY;AAChC;AACA,0BAA0B,wCAAK;AAC/B,4BAA4B,0CAAO,SAAS,eAAe;AAC3D;AACA;AACA,6BAA6B,+CAAY;AACzC;AACA,yBAAyB,iDAAc;AACvC,uBAAuB,qDAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,uDAAoB;AACnD;AACA;AACA,sBAAsB,wCAAK;AAC3B,uBAAuB,mDAAgB;AACvC,sCAAsC;AACtC,qCAAqC;AACrC;AACA;AACA;AACA,0BAA0B,iDAAc;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack:///../dist/analysis/heat/heat.js","webpack:///../dist/analysis/interpolation/inverse-distance-weight.js","webpack:///../dist/analysis/interpolation/kriging.js","webpack:///../dist/animation/animation.js","webpack:///../dist/animation/particle-animation.js","webpack:///../dist/animator.js","webpack:///../dist/data/feature-class.js","webpack:///../dist/data/field.js","webpack:///../dist/editor/editor.js","webpack:///../dist/element/feature.js","webpack:///../dist/element/graphic.js","webpack:///../dist/element/raster.js","webpack:///../dist/entity.js","webpack:///../dist/geometry/geometry.js","webpack:///../dist/geometry/multiple-point.js","webpack:///../dist/geometry/multiple-polygon.js","webpack:///../dist/geometry/multiple-polyline.js","webpack:///../dist/geometry/point.js","webpack:///../dist/geometry/polygon.js","webpack:///../dist/geometry/polyline.js","webpack:///../dist/grid.js","webpack:///../dist/index.js","webpack:///../dist/label/collision.js","webpack:///../dist/label/label.js","webpack:///../dist/layer/feature-layer.js","webpack:///../dist/layer/graphic-layer.js","webpack:///../dist/layer/layer.js","webpack:///../dist/layer/raster-layer.js","webpack:///../dist/map.js","webpack:///../dist/measurer.js","webpack:///../dist/projection/bd09.js","webpack:///../dist/projection/gcj02.js","webpack:///../dist/projection/noop-projection.js","webpack:///../dist/projection/projection.js","webpack:///../dist/projection/web-mercator.js","webpack:///../dist/renderer/category-renderer.js","webpack:///../dist/renderer/class-renderer.js","webpack:///../dist/renderer/dot-renderer.js","webpack:///../dist/renderer/renderer.js","webpack:///../dist/renderer/simple-renderer.js","webpack:///../dist/symbol/symbol.js","webpack:///../dist/tile.js","webpack:///../dist/tooltip/tooltip.js","webpack:///../dist/util/bound.js","webpack:///../dist/util/color.js","webpack:///../dist/util/subject.js","webpack:///../dist/util/utility.js","webpack:///../dist/viewer.js","webpack:///webpack/bootstrap","webpack:///webpack/runtime/define property getters","webpack:///webpack/runtime/hasOwnProperty shorthand","webpack:///webpack/runtime/make namespace object","webpack:///./cluster2.js"],"sourcesContent":["import { Raster } from \"../../element/raster\";\r\nimport { GeometryType } from \"../../geometry/geometry\";\r\nimport { WebMercator } from \"../../projection/web-mercator\";\r\n/*\r\n * 热力图\r\n * https://juejin.im/post/6844903709244129293\r\n */\r\nexport class Heat extends Raster {\r\n    /**\r\n     * 创建热力图\r\n     */\r\n    constructor() {\r\n        super(0, 0, 0, 0);\r\n        /**\r\n         * 热力半径\r\n         */\r\n        this.radius = 40; //px\r\n        /**\r\n         * 渐变色\r\n         */\r\n        this.gradient = [\r\n            { step: 0.3, color: \"blue\" },\r\n            { step: 0.5, color: \"lime\" },\r\n            { step: 0.7, color: \"yellow\" },\r\n            { step: 1, color: \"red\" }\r\n        ];\r\n        /*\r\n        * 蜂窝显示\r\n        */\r\n        this.honey = false;\r\n        /*\r\n        * 蜂窝边长\r\n        */\r\n        this.honeySide = 10;\r\n    }\r\n    /*\r\n    * 动态栅格（实时渲染）\r\n    */\r\n    get dynamic() {\r\n        return true;\r\n    }\r\n    get min() {\r\n        return this._min;\r\n    }\r\n    set min(value) {\r\n        this._min = value;\r\n    }\r\n    get max() {\r\n        return this._max;\r\n    }\r\n    set max(value) {\r\n        this._max = value;\r\n    }\r\n    /*\r\n     * 初始化\r\n     * @param {FeatureClass} featureClass - 点要素类\r\n     * @param {Field} field - 值字段\r\n     */\r\n    generate(featureClass, field) {\r\n        if (featureClass.type != GeometryType.Point)\r\n            return;\r\n        this._featureClass = featureClass;\r\n        this._field = field;\r\n        const values = featureClass.features.map(feature => feature.properties[field.name]);\r\n        this._min = this._min || Math.min(...values), this._max = this._max || Math.max(...values);\r\n        //初始化色带，256个颜色，1个像素代表1个颜色\r\n        this._ramp = document.createElement(\"canvas\");\r\n        const ramp = this._ramp.getContext('2d');\r\n        this._ramp.width = 256;\r\n        this._ramp.height = 1;\r\n        const grd = ramp.createLinearGradient(0, 0, this._ramp.width, this._ramp.height);\r\n        this.gradient.forEach(item => {\r\n            grd.addColorStop(item.step, item.color);\r\n        });\r\n        ramp.fillStyle = grd;\r\n        ramp.fillRect(0, 0, this._ramp.width, this._ramp.height);\r\n    }\r\n    /**\r\n     * 绘制栅格\r\n     * @remarks\r\n     * 遍历图形集合进行绘制\r\n     * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n     * @param {Projection} projection - 坐标投影转换\r\n     * @param {Bound} extent - 当前可视范围\r\n     * @param {number} zoom - 当前缩放级别\r\n     */\r\n    draw(ctx, projection = new WebMercator(), extent = projection.bound, zoom = 10) {\r\n        //绘制alpha通道图，类似灰度图\r\n        const canvas = document.createElement(\"canvas\");\r\n        canvas.width = ctx.canvas.width;\r\n        canvas.height = ctx.canvas.height;\r\n        const gray = canvas.getContext(\"2d\");\r\n        //遍历要素集合，根据字段值画alpha通道图\r\n        this._featureClass.features.forEach((feature) => {\r\n            const value = feature.properties[this._field.name];\r\n            if (value != undefined) {\r\n                const alpha = (value - this._min) / (this._max - this._min);\r\n                const point = feature.geometry;\r\n                point.project(projection);\r\n                const matrix = ctx.getTransform();\r\n                const screenX = (matrix.a * point.x + matrix.e);\r\n                const screenY = (matrix.d * point.y + matrix.f);\r\n                gray.save();\r\n                gray.lineWidth = 0;\r\n                const radgrad = gray.createRadialGradient(screenX, screenY, 0, screenX, screenY, this.radius);\r\n                radgrad.addColorStop(0, \"rgba(0, 0, 0, 1)\");\r\n                radgrad.addColorStop(1, \"rgba(0, 0, 0, 0)\");\r\n                gray.fillStyle = radgrad;\r\n                gray.globalAlpha = alpha;\r\n                gray.beginPath(); //Start path\r\n                gray.arc(screenX, screenY, this.radius, 0, Math.PI * 2, true);\r\n                gray.fill();\r\n                gray.restore();\r\n            }\r\n        });\r\n        //根据alpha值找到色带中对应颜色\r\n        const colorData = this._ramp.getContext(\"2d\").getImageData(0, 0, 256, 1).data;\r\n        const imgData = gray.getImageData(0, 0, canvas.width, canvas.height);\r\n        const data = imgData.data;\r\n        if (this.honey) {\r\n            ctx.save();\r\n            ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n            ctx.strokeStyle = \"#ffffff88\";\r\n            ctx.lineWidth = 1;\r\n            let flag = 0; //奇偶标志\r\n            for (let y = 0; y <= canvas.height; y = Math.floor(y + this.honeySide * 1.732 / 2)) {\r\n                for (let x = 0 + flag * (3 / 2 * this.honeySide); x <= canvas.width; x = x + 3 * this.honeySide) {\r\n                    const index = (y * canvas.width + x) * 4;\r\n                    const alpha = data[index + 3];\r\n                    //const pixelData = gray.getImageData(x, y, 1, 1);\r\n                    //const pixel = pixelData.data;\r\n                    //const alpha = pixel[3];\r\n                    if (alpha != 0) {\r\n                        ctx.fillStyle = \"rgba(\" + colorData[4 * alpha] + \",\" + colorData[4 * alpha + 1] + \",\" + colorData[4 * alpha + 2] + \",\" + alpha / 255 + \")\";\r\n                        //ctx.fillStyle =\"rgba(255,0,0,0.5)\";\r\n                        ctx.beginPath();\r\n                        ctx.moveTo(x - this.honeySide, y);\r\n                        ctx.lineTo(x - 1 / 2 * this.honeySide, Math.floor(y - this.honeySide * 1.732 / 2));\r\n                        ctx.lineTo(x + 1 / 2 * this.honeySide, Math.floor(y - this.honeySide * 1.732 / 2));\r\n                        ctx.lineTo(x + this.honeySide, y);\r\n                        ctx.lineTo(x + 1 / 2 * this.honeySide, Math.floor(y + this.honeySide * 1.732 / 2));\r\n                        ctx.lineTo(x - 1 / 2 * this.honeySide, Math.floor(y + this.honeySide * 1.732 / 2));\r\n                        ctx.lineTo(x - this.honeySide, y);\r\n                        ctx.closePath();\r\n                        ctx.fill();\r\n                        ctx.stroke();\r\n                    }\r\n                }\r\n                flag = flag === 0 ? 1 : 0;\r\n            }\r\n            ctx.restore();\r\n        }\r\n        else {\r\n            for (let i = 0; i < data.length; i++) {\r\n                const value = data[i];\r\n                //只有alpha是有值，R，G，B待设置\r\n                if (value > 0) {\r\n                    //alpha值，对应colorData数组下标\r\n                    data[i - 3] = colorData[4 * value]; //R\r\n                    data[i - 2] = colorData[4 * value + 1]; //G\r\n                    data[i - 1] = colorData[4 * value + 2]; //B\r\n                }\r\n            }\r\n            ctx.save();\r\n            ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n            ctx.putImageData(imgData, 0, 0);\r\n            ctx.restore();\r\n        }\r\n    }\r\n}\r\n","import { GeometryType } from \"../../geometry/geometry\";\r\nimport { WebMercator } from \"../../projection/web-mercator\";\r\nimport { Raster } from \"../../element/raster\";\r\n/*\r\n * 反距离加权法（Inverse Distance Weighted）插值\r\n */\r\nexport class InverseDistanceWeight extends Raster {\r\n    /**\r\n     * 创建插值\r\n     */\r\n    constructor() {\r\n        super(0, 0, 0, 0);\r\n        /**\r\n         * 分辨率\r\n         */\r\n        this.resolution = 10; //\r\n        /**\r\n         * 渐变色\r\n         */\r\n        //[\"#006837\", \"#1a9850\", \"#66bd63\", \"#a6d96a\", \"#d9ef8b\", \"#ffffbf\", \"#fee08b\", \"#fdae61\", \"#f46d43\", \"#d73027\", \"#a50026\"]\r\n        this.gradient = [\r\n            { step: 0, color: \"#006837\" },\r\n            { step: 0.1, color: \"#1a9850\" },\r\n            { step: 0.2, color: \"#66bd63\" },\r\n            { step: 0.3, color: \"#a6d96a\" },\r\n            { step: 0.4, color: \"#d9ef8b\" },\r\n            { step: 0.5, color: \"#ffffbf\" },\r\n            { step: 0.6, color: \"#fee08b\" },\r\n            { step: 0.7, color: \"#fdae61\" },\r\n            { step: 0.8, color: \"#f46d43\" },\r\n            { step: 0.9, color: \"#d73027\" },\r\n            { step: 1, color: \"#a50026\" }\r\n        ];\r\n        /**\r\n         * 反距离函数\r\n         */\r\n        this.decay = (distance) => {\r\n            return 1 / Math.pow(distance, 3);\r\n        };\r\n        /*\r\n        * 蜂窝显示\r\n        */\r\n        this.honey = false;\r\n        /*\r\n        * 蜂窝边长\r\n        */\r\n        this.honeySide = 10;\r\n        /*\r\n        * 蜂窝颜色\r\n        */\r\n        this.honeyColor = \"#ffffff88\";\r\n    }\r\n    /*\r\n    * 动态栅格（实时渲染）\r\n    */\r\n    get dynamic() {\r\n        return true;\r\n    }\r\n    get min() {\r\n        return this._min;\r\n    }\r\n    set min(value) {\r\n        this._min = value;\r\n    }\r\n    get max() {\r\n        return this._max;\r\n    }\r\n    set max(value) {\r\n        this._max = value;\r\n    }\r\n    /*\r\n     * 初始化\r\n     * @param {FeatureClass} featureClass - 点要素类\r\n     * @param {Field} field - 值字段\r\n     */\r\n    generate(featureClass, field) {\r\n        if (featureClass.type != GeometryType.Point)\r\n            return;\r\n        this._featureClass = featureClass;\r\n        this._field = field;\r\n        const values = featureClass.features.map(feature => feature.properties[field.name]);\r\n        this._min = this._min || Math.min(...values), this._max = this._max || Math.max(...values);\r\n        //初始化色带，256个颜色，1个像素代表1个颜色\r\n        this._ramp = document.createElement(\"canvas\");\r\n        const ramp = this._ramp.getContext('2d');\r\n        this._ramp.width = 256;\r\n        this._ramp.height = 1;\r\n        const grd = ramp.createLinearGradient(0, 0, this._ramp.width, this._ramp.height);\r\n        this.gradient.forEach(item => {\r\n            grd.addColorStop(item.step, item.color);\r\n        });\r\n        ramp.fillStyle = grd;\r\n        ramp.fillRect(0, 0, this._ramp.width, this._ramp.height);\r\n    }\r\n    /**\r\n     * 绘制栅格\r\n     * @remarks\r\n     * 遍历图形集合进行绘制\r\n     * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n     * @param {Projection} projection - 坐标投影转换\r\n     * @param {Bound} extent - 当前可视范围\r\n     * @param {number} zoom - 当前缩放级别\r\n     */\r\n    draw(ctx, projection = new WebMercator(), extent = projection.bound, zoom = 10) {\r\n        const valueData = [];\r\n        const matrix = ctx.getTransform();\r\n        //抽稀\r\n        /*const cluster = this._featureClass.features.reduce( (acc, cur) => {\r\n            if (cur.geometry instanceof Point) {\r\n                const point: Point = cur.geometry;\r\n                const item: any = acc.find((item: any) => {\r\n                    const distance = point.distance(item.geometry, CoordinateType.Screen, ctx, projection);\r\n                    return distance <= 20;\r\n                });\r\n                if (!item) acc.push(cur);\r\n                return acc;\r\n            }\r\n        }, []);*/\r\n        //生成(x,y,value),\r\n        //1.如x,y地理平面坐标，则可放到初始化代码中；\r\n        //2.如x,y屏幕平面坐标，则放在此处，每次重绘重新坐标变换；\r\n        this._featureClass.features.forEach((feature) => {\r\n            const value = feature.properties[this._field.name];\r\n            if (value != undefined) {\r\n                const point = feature.geometry;\r\n                point.project(projection);\r\n                const screenX = (matrix.a * point.x + matrix.e);\r\n                const screenY = (matrix.d * point.y + matrix.f);\r\n                valueData.push([screenX, screenY, (value - this._min) / (this._max - this._min)]);\r\n            }\r\n        });\r\n        //根据alpha值找到色带中对应颜色\r\n        const colorData = this._ramp.getContext(\"2d\").getImageData(0, 0, 256, 1).data;\r\n        //是否采用蜂窝网格渲染\r\n        if (this.honey) {\r\n            ctx.save();\r\n            ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n            ctx.strokeStyle = this.honeyColor;\r\n            ctx.lineWidth = 1;\r\n            let flag = 0; //奇偶标志\r\n            //循环y轴\r\n            for (let y = 0; y <= ctx.canvas.height; y = Math.floor(y + this.honeySide * 1.732 / 2)) {\r\n                //循环x轴\r\n                for (let x = 0 + flag * (3 / 2 * this.honeySide); x <= ctx.canvas.width; x = x + 3 * this.honeySide) {\r\n                    //通过蜂窝网格中心点(x,y)，计算该点的反距离插值\r\n                    let values = 0, weights = 0;\r\n                    valueData.forEach(item => {\r\n                        let distance = Math.sqrt((item[0] - x) * (item[0] - x) + (item[1] - y) * (item[1] - y));\r\n                        distance = distance < 1 ? 1 : distance;\r\n                        let weight = this.decay(distance);\r\n                        values += weight * item[2];\r\n                        weights += weight;\r\n                    });\r\n                    if (weights) {\r\n                        //插值对比色带，找到填充色，填充整个网格\r\n                        const alpha = Math.floor(values / weights * 255);\r\n                        ctx.fillStyle = \"rgba(\" + colorData[4 * alpha] + \",\" + colorData[4 * alpha + 1] + \",\" + colorData[4 * alpha + 2] + \",\" + alpha / 255 + \")\";\r\n                        ctx.beginPath();\r\n                        //绘制蜂窝网格\r\n                        ctx.moveTo(x - this.honeySide, y);\r\n                        ctx.lineTo(x - 1 / 2 * this.honeySide, Math.floor(y - this.honeySide * 1.732 / 2));\r\n                        ctx.lineTo(x + 1 / 2 * this.honeySide, Math.floor(y - this.honeySide * 1.732 / 2));\r\n                        ctx.lineTo(x + this.honeySide, y);\r\n                        ctx.lineTo(x + 1 / 2 * this.honeySide, Math.floor(y + this.honeySide * 1.732 / 2));\r\n                        ctx.lineTo(x - 1 / 2 * this.honeySide, Math.floor(y + this.honeySide * 1.732 / 2));\r\n                        ctx.lineTo(x - this.honeySide, y);\r\n                        ctx.closePath();\r\n                        ctx.fill();\r\n                        ctx.stroke();\r\n                    }\r\n                }\r\n                //奇偶行换位\r\n                flag = flag === 0 ? 1 : 0;\r\n            }\r\n            ctx.restore();\r\n        }\r\n        else {\r\n            const canvas = document.createElement(\"canvas\");\r\n            canvas.width = ctx.canvas.width / this.resolution;\r\n            canvas.height = ctx.canvas.height / this.resolution;\r\n            const gray = canvas.getContext(\"2d\");\r\n            const imgData = gray.getImageData(0, 0, canvas.width, canvas.height);\r\n            const data = imgData.data;\r\n            for (let i = 0; i < data.length; i = i + 4) {\r\n                const screenY = i / (4 * canvas.width) * this.resolution, screenX = i / 4 % canvas.width * this.resolution;\r\n                let values = 0, weights = 0;\r\n                //加权\r\n                valueData.forEach(item => {\r\n                    let distance = Math.sqrt((item[0] - screenX) * (item[0] - screenX) + (item[1] - screenY) * (item[1] - screenY));\r\n                    distance = distance < 1 ? 1 : distance;\r\n                    let weight = this.decay(distance);\r\n                    values += weight * item[2];\r\n                    weights += weight;\r\n                });\r\n                //像素RGB赋值，赋值方式参考热力图\r\n                if (weights) {\r\n                    const alpha = Math.floor(values / weights * 255);\r\n                    data[i] = colorData[4 * alpha]; //R\r\n                    data[i + 1] = colorData[4 * alpha + 1]; //G\r\n                    data[i + 2] = colorData[4 * alpha + 2]; //B\r\n                    data[i + 3] = alpha;\r\n                }\r\n            }\r\n            gray.putImageData(imgData, 0, 0);\r\n            ctx.save();\r\n            ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n            ctx.drawImage(canvas, 0, 0, ctx.canvas.width, ctx.canvas.height);\r\n            ctx.restore();\r\n        }\r\n    }\r\n}\r\n","import { GeometryType } from \"../../geometry/geometry\";\r\nimport { WebMercator } from \"../../projection/web-mercator\";\r\nimport { Raster } from \"../../element/raster\";\r\n/*\r\n * 克里金插值\r\n * http://oeo4b.github.io/#documentation\r\n * https://rawgit.com/oeo4b/kriging.js/master/kriging.js\r\n */\r\nexport class Kriging extends Raster {\r\n    /**\r\n     * 创建克里金插值\r\n     * @param {number} xmin - 经度左值\r\n     * @param {number} ymin - 纬度下值\r\n     * @param {number} xmax - 经度右值\r\n     * @param {number} ymax - 纬度上值\r\n     * @param {number} width - 栅格宽度\r\n     * @param {number} height - 栅格高度\r\n     * @param {number} cellsize - 栅格大小\r\n     */\r\n    constructor(xmin, ymin, xmax, ymax, width = 1000, height = 1000, cellsize = 4) {\r\n        super(xmin, ymin, xmax, ymax, width, height);\r\n        /*\r\n         * 渲染颜色\r\n         */\r\n        this.colors = [\"#006837\", \"#1a9850\", \"#66bd63\", \"#a6d96a\", \"#d9ef8b\", \"#ffffbf\", \"#fee08b\", \"#fdae61\", \"#f46d43\", \"#d73027\", \"#a50026\"];\r\n        /*\r\n         * 插值算法\r\n         */\r\n        this.model = \"exponential\";\r\n        /*\r\n         * 精度 分辨率 1 block = 4 px\r\n         */\r\n        this.cellSize = 4;\r\n        this.cellSize = cellsize;\r\n    }\r\n    // Matrix algebra\r\n    _kriging_matrix_diag(c, n) {\r\n        let i, Z = Array(n * n).fill(0);\r\n        for (i = 0; i < n; i++)\r\n            Z[i * n + i] = c;\r\n        return Z;\r\n    }\r\n    ;\r\n    _kriging_matrix_transpose(X, n, m) {\r\n        let i, j, Z = Array(m * n);\r\n        for (i = 0; i < n; i++)\r\n            for (j = 0; j < m; j++)\r\n                Z[j * n + i] = X[i * m + j];\r\n        return Z;\r\n    }\r\n    ;\r\n    _kriging_matrix_scale(X, c, n, m) {\r\n        let i, j;\r\n        for (i = 0; i < n; i++)\r\n            for (j = 0; j < m; j++)\r\n                X[i * m + j] *= c;\r\n    }\r\n    ;\r\n    _kriging_matrix_add(X, Y, n, m) {\r\n        let i, j, Z = Array(n * m);\r\n        for (i = 0; i < n; i++)\r\n            for (j = 0; j < m; j++)\r\n                Z[i * m + j] = X[i * m + j] + Y[i * m + j];\r\n        return Z;\r\n    }\r\n    ;\r\n    // Naive matrix multiplication\r\n    _kriging_matrix_multiply(X, Y, n, m, p) {\r\n        let i, j, k, Z = Array(n * p);\r\n        for (i = 0; i < n; i++) {\r\n            for (j = 0; j < p; j++) {\r\n                Z[i * p + j] = 0;\r\n                for (k = 0; k < m; k++)\r\n                    Z[i * p + j] += X[i * m + k] * Y[k * p + j];\r\n            }\r\n        }\r\n        return Z;\r\n    }\r\n    ;\r\n    // Cholesky decomposition\r\n    _kriging_matrix_chol(X, n) {\r\n        let i, j, k, sum, p = Array(n);\r\n        for (i = 0; i < n; i++)\r\n            p[i] = X[i * n + i];\r\n        for (i = 0; i < n; i++) {\r\n            for (j = 0; j < i; j++)\r\n                p[i] -= X[i * n + j] * X[i * n + j];\r\n            if (p[i] <= 0)\r\n                return false;\r\n            p[i] = Math.sqrt(p[i]);\r\n            for (j = i + 1; j < n; j++) {\r\n                for (k = 0; k < i; k++)\r\n                    X[j * n + i] -= X[j * n + k] * X[i * n + k];\r\n                X[j * n + i] /= p[i];\r\n            }\r\n        }\r\n        for (i = 0; i < n; i++)\r\n            X[i * n + i] = p[i];\r\n        return true;\r\n    }\r\n    ;\r\n    // Inversion of cholesky decomposition\r\n    _kriging_matrix_chol2inv(X, n) {\r\n        let i, j, k, sum;\r\n        for (i = 0; i < n; i++) {\r\n            X[i * n + i] = 1 / X[i * n + i];\r\n            for (j = i + 1; j < n; j++) {\r\n                sum = 0;\r\n                for (k = i; k < j; k++)\r\n                    sum -= X[j * n + k] * X[k * n + i];\r\n                X[j * n + i] = sum / X[j * n + j];\r\n            }\r\n        }\r\n        for (i = 0; i < n; i++)\r\n            for (j = i + 1; j < n; j++)\r\n                X[i * n + j] = 0;\r\n        for (i = 0; i < n; i++) {\r\n            X[i * n + i] *= X[i * n + i];\r\n            for (k = i + 1; k < n; k++)\r\n                X[i * n + i] += X[k * n + i] * X[k * n + i];\r\n            for (j = i + 1; j < n; j++)\r\n                for (k = j; k < n; k++)\r\n                    X[i * n + j] += X[k * n + i] * X[k * n + j];\r\n        }\r\n        for (i = 0; i < n; i++)\r\n            for (j = 0; j < i; j++)\r\n                X[i * n + j] = X[j * n + i];\r\n    }\r\n    ;\r\n    // Inversion via gauss-jordan elimination\r\n    _kriging_matrix_solve(X, n) {\r\n        let m = n;\r\n        let b = Array(n * n);\r\n        let indxc = Array(n);\r\n        let indxr = Array(n);\r\n        let ipiv = Array(n);\r\n        let i, icol, irow, j, k, l, ll;\r\n        let big, dum, pivinv, temp;\r\n        for (i = 0; i < n; i++)\r\n            for (j = 0; j < n; j++) {\r\n                if (i == j)\r\n                    b[i * n + j] = 1;\r\n                else\r\n                    b[i * n + j] = 0;\r\n            }\r\n        for (j = 0; j < n; j++)\r\n            ipiv[j] = 0;\r\n        for (i = 0; i < n; i++) {\r\n            big = 0;\r\n            for (j = 0; j < n; j++) {\r\n                if (ipiv[j] != 1) {\r\n                    for (k = 0; k < n; k++) {\r\n                        if (ipiv[k] == 0) {\r\n                            if (Math.abs(X[j * n + k]) >= big) {\r\n                                big = Math.abs(X[j * n + k]);\r\n                                irow = j;\r\n                                icol = k;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            ++(ipiv[icol]);\r\n            if (irow != icol) {\r\n                for (l = 0; l < n; l++) {\r\n                    temp = X[irow * n + l];\r\n                    X[irow * n + l] = X[icol * n + l];\r\n                    X[icol * n + l] = temp;\r\n                }\r\n                for (l = 0; l < m; l++) {\r\n                    temp = b[irow * n + l];\r\n                    b[irow * n + l] = b[icol * n + l];\r\n                    b[icol * n + l] = temp;\r\n                }\r\n            }\r\n            indxr[i] = irow;\r\n            indxc[i] = icol;\r\n            if (X[icol * n + icol] == 0)\r\n                return false; // Singular\r\n            pivinv = 1 / X[icol * n + icol];\r\n            X[icol * n + icol] = 1;\r\n            for (l = 0; l < n; l++)\r\n                X[icol * n + l] *= pivinv;\r\n            for (l = 0; l < m; l++)\r\n                b[icol * n + l] *= pivinv;\r\n            for (ll = 0; ll < n; ll++) {\r\n                if (ll != icol) {\r\n                    dum = X[ll * n + icol];\r\n                    X[ll * n + icol] = 0;\r\n                    for (l = 0; l < n; l++)\r\n                        X[ll * n + l] -= X[icol * n + l] * dum;\r\n                    for (l = 0; l < m; l++)\r\n                        b[ll * n + l] -= b[icol * n + l] * dum;\r\n                }\r\n            }\r\n        }\r\n        for (l = (n - 1); l >= 0; l--)\r\n            if (indxr[l] != indxc[l]) {\r\n                for (k = 0; k < n; k++) {\r\n                    temp = X[k * n + indxr[l]];\r\n                    X[k * n + indxr[l]] = X[k * n + indxc[l]];\r\n                    X[k * n + indxc[l]] = temp;\r\n                }\r\n            }\r\n        return true;\r\n    }\r\n    // Variogram models\r\n    _kriging_variogram_gaussian(h, nugget, range, sill, A) {\r\n        return nugget + ((sill - nugget) / range) *\r\n            (1.0 - Math.exp(-(1.0 / A) * Math.pow(h / range, 2)));\r\n    }\r\n    ;\r\n    _kriging_variogram_exponential(h, nugget, range, sill, A) {\r\n        return nugget + ((sill - nugget) / range) *\r\n            (1.0 - Math.exp(-(1.0 / A) * (h / range)));\r\n    }\r\n    ;\r\n    _kriging_variogram_spherical(h, nugget, range, sill, A) {\r\n        if (h > range)\r\n            return nugget + (sill - nugget) / range;\r\n        return nugget + ((sill - nugget) / range) *\r\n            (1.5 * (h / range) - 0.5 * Math.pow(h / range, 3));\r\n    }\r\n    ;\r\n    // Train using gaussian processes with bayesian priors\r\n    train(t, x, y, model, sigma2, alpha) {\r\n        let variogram = {\r\n            t: t,\r\n            x: x,\r\n            y: y,\r\n            nugget: 0.0,\r\n            range: 0.0,\r\n            sill: 0.0,\r\n            A: 1 / 3,\r\n            n: 0,\r\n            model: null,\r\n            K: null,\r\n            M: null\r\n        };\r\n        switch (model) {\r\n            case \"gaussian\":\r\n                variogram.model = this._kriging_variogram_gaussian;\r\n                break;\r\n            case \"exponential\":\r\n                variogram.model = this._kriging_variogram_exponential;\r\n                break;\r\n            case \"spherical\":\r\n                variogram.model = this._kriging_variogram_spherical;\r\n                break;\r\n        }\r\n        ;\r\n        // Lag distance/semivariance\r\n        let i, j, k, l, n = t.length;\r\n        let distance = Array((n * n - n) / 2);\r\n        for (i = 0, k = 0; i < n; i++)\r\n            for (j = 0; j < i; j++, k++) {\r\n                distance[k] = Array(2);\r\n                distance[k][0] = Math.pow(Math.pow(x[i] - x[j], 2) +\r\n                    Math.pow(y[i] - y[j], 2), 0.5);\r\n                distance[k][1] = Math.abs(t[i] - t[j]);\r\n            }\r\n        distance.sort((a, b) => { return a[0] - b[0]; });\r\n        variogram.range = distance[(n * n - n) / 2 - 1][0];\r\n        // Bin lag distance\r\n        let lags = ((n * n - n) / 2) > 30 ? 30 : (n * n - n) / 2;\r\n        let tolerance = variogram.range / lags;\r\n        let lag = Array(lags).fill(0);\r\n        let semi = Array(lags).fill(0);\r\n        if (lags < 30) {\r\n            for (l = 0; l < lags; l++) {\r\n                lag[l] = distance[l][0];\r\n                semi[l] = distance[l][1];\r\n            }\r\n        }\r\n        else {\r\n            for (i = 0, j = 0, k = 0, l = 0; i < lags && j < ((n * n - n) / 2); i++, k = 0) {\r\n                while (distance[j][0] <= ((i + 1) * tolerance)) {\r\n                    lag[l] += distance[j][0];\r\n                    semi[l] += distance[j][1];\r\n                    j++;\r\n                    k++;\r\n                    if (j >= ((n * n - n) / 2))\r\n                        break;\r\n                }\r\n                if (k > 0) {\r\n                    lag[l] /= k;\r\n                    semi[l] /= k;\r\n                    l++;\r\n                }\r\n            }\r\n            if (l < 2)\r\n                return variogram; // Error: Not enough points\r\n        }\r\n        // Feature transformation\r\n        n = l;\r\n        variogram.range = lag[n - 1] - lag[0];\r\n        let X = Array(2 * n).fill(1);\r\n        let Y = Array(n);\r\n        let A = variogram.A;\r\n        for (i = 0; i < n; i++) {\r\n            switch (model) {\r\n                case \"gaussian\":\r\n                    X[i * 2 + 1] = 1.0 - Math.exp(-(1.0 / A) * Math.pow(lag[i] / variogram.range, 2));\r\n                    break;\r\n                case \"exponential\":\r\n                    X[i * 2 + 1] = 1.0 - Math.exp(-(1.0 / A) * lag[i] / variogram.range);\r\n                    break;\r\n                case \"spherical\":\r\n                    X[i * 2 + 1] = 1.5 * (lag[i] / variogram.range) -\r\n                        0.5 * Math.pow(lag[i] / variogram.range, 3);\r\n                    break;\r\n            }\r\n            ;\r\n            Y[i] = semi[i];\r\n        }\r\n        // Least squares\r\n        let Xt = this._kriging_matrix_transpose(X, n, 2);\r\n        let Z = this._kriging_matrix_multiply(Xt, X, 2, n, 2);\r\n        Z = this._kriging_matrix_add(Z, this._kriging_matrix_diag(1 / alpha, 2), 2, 2);\r\n        let cloneZ = Z.slice(0);\r\n        if (this._kriging_matrix_chol(Z, 2))\r\n            this._kriging_matrix_chol2inv(Z, 2);\r\n        else {\r\n            this._kriging_matrix_solve(cloneZ, 2);\r\n            Z = cloneZ;\r\n        }\r\n        let W = this._kriging_matrix_multiply(this._kriging_matrix_multiply(Z, Xt, 2, 2, n), Y, 2, n, 1);\r\n        // Variogram parameters\r\n        variogram.nugget = W[0];\r\n        variogram.sill = W[1] * variogram.range + variogram.nugget;\r\n        variogram.n = x.length;\r\n        // Gram matrix with prior\r\n        n = x.length;\r\n        let K = Array(n * n);\r\n        for (i = 0; i < n; i++) {\r\n            for (j = 0; j < i; j++) {\r\n                K[i * n + j] = variogram.model(Math.pow(Math.pow(x[i] - x[j], 2) +\r\n                    Math.pow(y[i] - y[j], 2), 0.5), variogram.nugget, variogram.range, variogram.sill, variogram.A);\r\n                K[j * n + i] = K[i * n + j];\r\n            }\r\n            K[i * n + i] = variogram.model(0, variogram.nugget, variogram.range, variogram.sill, variogram.A);\r\n        }\r\n        // Inverse penalized Gram matrix projected to target vector\r\n        let C = this._kriging_matrix_add(K, this._kriging_matrix_diag(sigma2, n), n, n);\r\n        let cloneC = C.slice(0);\r\n        if (this._kriging_matrix_chol(C, n))\r\n            this._kriging_matrix_chol2inv(C, n);\r\n        else {\r\n            this._kriging_matrix_solve(cloneC, n);\r\n            C = cloneC;\r\n        }\r\n        // Copy unprojected inverted matrix as K\r\n        let K2 = C.slice(0);\r\n        let M = this._kriging_matrix_multiply(C, t, n, n, 1);\r\n        variogram.K = K2;\r\n        variogram.M = M;\r\n        return variogram;\r\n    }\r\n    ;\r\n    // Model prediction\r\n    predict(x, y, variogram) {\r\n        var i, k = Array(variogram.n);\r\n        for (i = 0; i < variogram.n; i++)\r\n            k[i] = variogram.model(Math.pow(Math.pow(x - variogram.x[i], 2) +\r\n                Math.pow(y - variogram.y[i], 2), 0.5), variogram.nugget, variogram.range, variogram.sill, variogram.A);\r\n        return this._kriging_matrix_multiply(k, variogram.M, 1, variogram.n, 1)[0];\r\n    }\r\n    ;\r\n    variance(x, y, variogram) {\r\n        var i, k = Array(variogram.n);\r\n        for (i = 0; i < variogram.n; i++)\r\n            k[i] = variogram.model(Math.pow(Math.pow(x - variogram.x[i], 2) +\r\n                Math.pow(y - variogram.y[i], 2), 0.5), variogram.nugget, variogram.range, variogram.sill, variogram.A);\r\n        return variogram.model(0, variogram.nugget, variogram.range, variogram.sill, variogram.A) +\r\n            this._kriging_matrix_multiply(this._kriging_matrix_multiply(k, variogram.K, 1, variogram.n, variogram.n), k, 1, variogram.n, 1)[0];\r\n    }\r\n    ;\r\n    // Gridded matrices or contour paths\r\n    grid(polygons, variogram, width) {\r\n        var i, j, k, n = polygons.length;\r\n        if (n == 0)\r\n            return;\r\n        // Boundaries of polygons space\r\n        var xlim = [polygons[0][0][0], polygons[0][0][0]];\r\n        var ylim = [polygons[0][0][1], polygons[0][0][1]];\r\n        for (i = 0; i < n; i++) // Polygons\r\n            for (j = 0; j < polygons[i].length; j++) { // Vertices\r\n                if (polygons[i][j][0] < xlim[0])\r\n                    xlim[0] = polygons[i][j][0];\r\n                if (polygons[i][j][0] > xlim[1])\r\n                    xlim[1] = polygons[i][j][0];\r\n                if (polygons[i][j][1] < ylim[0])\r\n                    ylim[0] = polygons[i][j][1];\r\n                if (polygons[i][j][1] > ylim[1])\r\n                    ylim[1] = polygons[i][j][1];\r\n            }\r\n        // Alloc for O(n^2) space\r\n        var xtarget, ytarget;\r\n        var a = Array(2), b = Array(2);\r\n        var lxlim = Array(2); // Local dimensions\r\n        var lylim = Array(2); // Local dimensions\r\n        var x = Math.ceil((xlim[1] - xlim[0]) / width);\r\n        var y = Math.ceil((ylim[1] - ylim[0]) / width);\r\n        var A = Array(x + 1);\r\n        const _pip = (array, x, y) => {\r\n            let i, j, c = false;\r\n            for (i = 0, j = array.length - 1; i < array.length; j = i++) {\r\n                if (((array[i][1] > y) != (array[j][1] > y)) &&\r\n                    (x < (array[j][0] - array[i][0]) * (y - array[i][1]) / (array[j][1] - array[i][1]) + array[i][0])) {\r\n                    c = !c;\r\n                }\r\n            }\r\n            return c;\r\n        };\r\n        for (i = 0; i <= x; i++)\r\n            A[i] = Array(y + 1);\r\n        for (i = 0; i < n; i++) {\r\n            // Range for polygons[i]\r\n            lxlim[0] = polygons[i][0][0];\r\n            lxlim[1] = lxlim[0];\r\n            lylim[0] = polygons[i][0][1];\r\n            lylim[1] = lylim[0];\r\n            for (j = 1; j < polygons[i].length; j++) { // Vertices\r\n                if (polygons[i][j][0] < lxlim[0])\r\n                    lxlim[0] = polygons[i][j][0];\r\n                if (polygons[i][j][0] > lxlim[1])\r\n                    lxlim[1] = polygons[i][j][0];\r\n                if (polygons[i][j][1] < lylim[0])\r\n                    lylim[0] = polygons[i][j][1];\r\n                if (polygons[i][j][1] > lylim[1])\r\n                    lylim[1] = polygons[i][j][1];\r\n            }\r\n            // Loop through polygon subspace\r\n            a[0] = Math.floor(((lxlim[0] - ((lxlim[0] - xlim[0]) % width)) - xlim[0]) / width);\r\n            a[1] = Math.ceil(((lxlim[1] - ((lxlim[1] - xlim[1]) % width)) - xlim[0]) / width);\r\n            b[0] = Math.floor(((lylim[0] - ((lylim[0] - ylim[0]) % width)) - ylim[0]) / width);\r\n            b[1] = Math.ceil(((lylim[1] - ((lylim[1] - ylim[1]) % width)) - ylim[0]) / width);\r\n            for (j = a[0]; j <= a[1]; j++)\r\n                for (k = b[0]; k <= b[1]; k++) {\r\n                    xtarget = xlim[0] + j * width;\r\n                    ytarget = ylim[0] + k * width;\r\n                    if (_pip(polygons[i], xtarget, ytarget))\r\n                        A[j][k] = this.predict(xtarget, ytarget, variogram);\r\n                }\r\n        }\r\n        return {\r\n            A: A,\r\n            xlim: xlim,\r\n            ylim: ylim,\r\n            zlim: [Math.min(...variogram.t), Math.max(...variogram.t)],\r\n            width: width\r\n        };\r\n    }\r\n    ;\r\n    contour(value, polygons, variogram) {\r\n    }\r\n    ;\r\n    plot(grid, xlim, ylim, colors) {\r\n        // Clear screen\r\n        const ctx = this.canvas.getContext(\"2d\");\r\n        ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\r\n        // Starting boundaries\r\n        var range = [xlim[1] - xlim[0], ylim[1] - ylim[0], grid.zlim[1] - grid.zlim[0]];\r\n        var i, j, x, y, z;\r\n        var n = grid.A.length;\r\n        var m = grid.A[0].length;\r\n        var wx = Math.ceil(grid.width * this.canvas.width / (xlim[1] - xlim[0]));\r\n        var wy = Math.ceil(grid.width * this.canvas.height / (ylim[1] - ylim[0]));\r\n        for (i = 0; i < n; i++) {\r\n            for (j = 0; j < m; j++) {\r\n                if (grid.A[i][j] == undefined)\r\n                    continue;\r\n                x = this.canvas.width * (i * grid.width + grid.xlim[0] - xlim[0]) / range[0];\r\n                y = this.canvas.height * (1 - (j * grid.width + grid.ylim[0] - ylim[0]) / range[1]);\r\n                z = (grid.A[i][j] - grid.zlim[0]) / range[2];\r\n                if (z < 0.0)\r\n                    z = 0.0;\r\n                if (z > 1.0)\r\n                    z = 1.0;\r\n                ctx.fillStyle = colors[Math.floor((colors.length - 1) * z)];\r\n                ctx.fillRect(Math.round(x - wx / 2), Math.round(y - wy / 2), wx, wy);\r\n            }\r\n        }\r\n    }\r\n    ;\r\n    /*\r\n     * 生成插值\r\n     * @param {FeatureClass} featureClass - 插值点要素类\r\n     * @param {Field} field - 插值字段\r\n     */\r\n    generate(featureClass, field) {\r\n        if (featureClass.type != GeometryType.Point)\r\n            return;\r\n        const values = featureClass.features.map(feature => feature.properties[field.name]);\r\n        const lngs = featureClass.features.map(feature => feature.geometry.lng);\r\n        const lats = featureClass.features.map(feature => feature.geometry.lat);\r\n        const variogram = this.train(values, lngs, lats, this.model, 0, 100);\r\n        const bound = this.bound;\r\n        const boundary = [[[bound.xmin, bound.ymin], [bound.xmin, bound.ymax], [bound.xmax, bound.ymax], [bound.xmax, bound.ymin]]];\r\n        const grid = this.grid(boundary, variogram, (bound.ymax - bound.ymin) / (this.canvas.height / this.cellSize));\r\n        this.plot(grid, [bound.xmin, bound.xmax], [bound.ymin, bound.ymax], this.colors);\r\n    }\r\n    /**\r\n     * 绘制栅格\r\n     * @remarks\r\n     * 遍历图形集合进行绘制\r\n     * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n     * @param {Projection} projection - 坐标投影转换\r\n     * @param {Bound} extent - 当前可视范围\r\n     * @param {number} zoom - 当前缩放级别\r\n     */\r\n    draw(ctx, projection = new WebMercator(), extent = projection.bound, zoom = 10) {\r\n        let [xmin, ymax] = projection.project([this.bound.xmin, this.bound.ymax]);\r\n        let [xmax, ymin] = projection.project([this.bound.xmax, this.bound.ymin]);\r\n        ctx.save();\r\n        const matrix = ctx.getTransform();\r\n        let screenXMin = (matrix.a * xmin + matrix.e);\r\n        let screenYMin = (matrix.d * ymax + matrix.f);\r\n        let screenXMax = (matrix.a * xmax + matrix.e);\r\n        let screenYMax = (matrix.d * ymin + matrix.f);\r\n        //keep size\r\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n        //this.resample(this.canvas, this.canvas.width, this.canvas.height, false);\r\n        ctx.drawImage(this.canvas, screenXMin, screenYMin, screenXMax - screenXMin, screenYMax - screenYMin);\r\n        ctx.restore();\r\n    }\r\n}\r\n","import { WebMercator } from \"../projection/web-mercator\";\r\n/**\r\n * 动画效果基类\r\n * @remarks\r\n * 动画两种实现方式：\r\n * 1.针对单个图形要素，实现动画，使用时，逻辑较清晰；\r\n * 2.针对整个图层，类似Symbol，使用时，可能存在效率问题；\r\n * 目前暂实现1，针对2，目前保留部分已注释的代码，便于日后参考。\r\n */\r\nexport class Animation {\r\n    /**\r\n     * 动画效果初始化\r\n     * @remarks\r\n     * 一般情况下，把一次性逻辑放于此处，以及处理动画的初始状态\r\n     * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n     * @param {Projection} projection - 坐标投影转换\r\n     */\r\n    init(ctx, projection = new WebMercator()) {\r\n    }\r\n    /**\r\n     * 动画效果\r\n     * @remarks\r\n     * 通过Animator中requestAnimationFrame循环调用，因此注意优化代码，保持帧数\r\n     * @param {number} elapsed - 已逝去的时间，毫秒\r\n     * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n     */\r\n    animate(elapsed, ctx) {\r\n    }\r\n}\r\n/**\r\n * 点默认动画效果类\r\n * @remarks\r\n * 类似flashing效果，从中心点向外光环扩散效果\r\n */\r\nexport class PointAnimation extends Animation {\r\n    //radius: number = this.limit / this.ring;\r\n    /**\r\n     * 创建动画效果\r\n     * @param {Point} geometry - 点\r\n     */\r\n    constructor(geometry) {\r\n        super();\r\n        /**\r\n         * 边宽\r\n         */\r\n        this.lineWidth = 2;\r\n        /**\r\n         * 颜色\r\n         */\r\n        this.color = \"#ff0000\";\r\n        /**\r\n         * 扩散速度\r\n         */\r\n        this.velocity = 10; //  px/s\r\n        /**\r\n         * 扩散的最大半径\r\n         */\r\n        this.limit = 30;\r\n        /**\r\n         * 扩散的光圈数\r\n         */\r\n        this.ring = 3;\r\n        this._point = geometry;\r\n    }\r\n    /**\r\n     * 动画效果初始化\r\n     * @remarks\r\n     * 一般情况下，把一次性逻辑放于此处，以及处理动画的初始状态\r\n     * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n     * @param {Projection} projection - 坐标投影转换\r\n     */\r\n    init(ctx, projection = new WebMercator()) {\r\n        this._point.project(projection);\r\n        const matrix = ctx.getTransform();\r\n        this._screenX = (matrix.a * this._point.x + matrix.e);\r\n        this._screenY = (matrix.d * this._point.y + matrix.f);\r\n        /*ctx.save();\r\n        ctx.strokeStyle = this.color;\r\n        ctx.lineWidth = this.lineWidth;\r\n        //keep size\r\n        //地理坐标 转回 屏幕坐标\r\n        ctx.setTransform(1,0,0,1,0,0);\r\n        ctx.beginPath(); //Start path\r\n        ctx.arc(this._screenX, this._screenY, this.limit / this.ring, 0, Math.PI * 2, true);\r\n        ctx.stroke();\r\n        ctx.restore();*/\r\n    }\r\n    /**\r\n     * 动画效果\r\n     * @remarks\r\n     * 通过Animator中requestAnimationFrame循环调用，因此注意优化代码，保持帧数\r\n     * @param {number} elapsed - 已逝去的时间，毫秒\r\n     * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n     */\r\n    animate(elapsed, ctx) {\r\n        ctx.save();\r\n        ctx.strokeStyle = this.color;\r\n        ctx.lineWidth = this.lineWidth;\r\n        //keep size\r\n        //地理坐标 转回 屏幕坐标\r\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n        /*ctx.arc(this._screenX, this._screenY, this.limit / this.ring, 0, Math.PI * 2, true);\r\n        ctx.fill();*/\r\n        for (let i = 0; i < this.ring; i++) {\r\n            ctx.beginPath(); //Start path\r\n            ctx.arc(this._screenX, this._screenY, (elapsed / 1000 * this.velocity + i * this.limit / this.ring) % this.limit, 0, Math.PI * 2, true);\r\n            //ctx.arc(this._screenX, this._screenY, this.limit / this.ring + ((elapsed/1000 + (this.limit - this.limit / this.ring) / this.velocity * (i/(this.ring - 1))) * this.velocity) % this.limit, 0, Math.PI * 2, true);\r\n            ctx.stroke();\r\n        }\r\n        ctx.restore();\r\n    }\r\n}\r\n/**\r\n * 线默认动画效果类\r\n * @remarks\r\n * 类似航线效果\r\n */\r\nexport class LineAnimation extends Animation {\r\n    /**\r\n     * 创建动画效果\r\n     * @param {Polyline} geometry - 线\r\n     */\r\n    constructor(geometry) {\r\n        super();\r\n        this._percent = 0;\r\n        /**\r\n         * 线宽\r\n         */\r\n        this.lineWidth = 2;\r\n        /**\r\n         * 起始色\r\n         */\r\n        this.startColor = \"#ff0000\";\r\n        /**\r\n         * 终止色\r\n         */\r\n        this.endColor = \"#ffff00\";\r\n        /**\r\n         * 二次贝塞尔曲线控制点与线段夹角\r\n         */\r\n        this.angle = Math.PI / 4;\r\n        this._polyline = geometry;\r\n    }\r\n    /**\r\n     * 动画效果初始化\r\n     * @remarks\r\n     * 一般情况下，把一次性逻辑放于此处，以及处理动画的初始状态\r\n     * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n     * @param {Projection} projection - 坐标投影转换\r\n     */\r\n    init(ctx, projection = new WebMercator()) {\r\n        this._polyline.project(projection);\r\n        const matrix = ctx.getTransform();\r\n        this._screen = this._polyline.coordinates.map((point, index) => {\r\n            const screenX = (matrix.a * point[0] + matrix.e), screenY = (matrix.d * point[1] + matrix.f);\r\n            return [screenX, screenY];\r\n        });\r\n        //TODO: polyline, not line; but now just line\r\n        this._start = this._screen[0];\r\n        this._end = this._screen[1];\r\n        const k = (this._end[1] - this._start[1]) / (this._end[0] - this._start[0]);\r\n        const d = Math.sqrt((this._end[1] - this._start[1]) * (this._end[1] - this._start[1]) + (this._end[0] - this._start[0]) * (this._end[0] - this._start[0]));\r\n        const s = d / 2 / Math.cos(this.angle);\r\n        //const a = (Math.atan(k) < 0 ? (Math.PI +  Math.atan(k)) : Math.atan(k)) - this.angle;\r\n        //this._control = this._start[0] >= this._end[0] ? [this._start[0] + s * Math.cos(a), this._start[1] + s * Math.sin(a)] : [this._end[0] + s * Math.cos(a), this._end[1] + s * Math.sin(a)];\r\n        const a = Math.atan(k) - this.angle;\r\n        if (Math.atan(k) < 0) {\r\n            if (this._end[0] > this._start[0]) {\r\n                this._control = [this._start[0] + s * Math.cos(a), this._start[1] + s * Math.sin(a)];\r\n            }\r\n            else {\r\n                this._control = [this._end[0] + s * Math.cos(a), this._end[1] + s * Math.sin(a)];\r\n            }\r\n        }\r\n        else {\r\n            if (this._end[0] > this._start[0]) {\r\n                this._control = [this._start[0] + s * Math.cos(a), this._start[1] + s * Math.sin(a)];\r\n            }\r\n            else {\r\n                this._control = [this._end[0] + s * Math.cos(a), this._end[1] + s * Math.sin(a)];\r\n            }\r\n        }\r\n        this._percent = 0;\r\n    }\r\n    /**\r\n     * 动画效果\r\n     * @remarks\r\n     * 通过Animator中requestAnimationFrame循环调用，因此注意优化代码，保持帧数\r\n     * @param {number} elapsed - 已逝去的时间，毫秒\r\n     * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n     */\r\n    animate(elapsed, ctx) {\r\n        ctx.save();\r\n        ctx.lineWidth = this.lineWidth;\r\n        //keep size\r\n        //地理坐标 转回 屏幕坐标\r\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n        const lineGradient = ctx.createLinearGradient(this._start[0], this._start[1], this._end[0], this._end[1]);\r\n        lineGradient.addColorStop(0, this.startColor);\r\n        // lineGradient.addColorStop(0.3, '#fff');\r\n        lineGradient.addColorStop(1, this.endColor);\r\n        ctx.strokeStyle = lineGradient; //设置线条样式\r\n        this._drawCurvePath(ctx, this._start, this._control, this._end, this._percent);\r\n        this._percent += 0.8; //进程增加,这个控制动画速度\r\n        if (this._percent >= 100) { //没有画完接着调用,画完的话重置进度\r\n            this._percent = 0;\r\n        }\r\n    }\r\n    _drawCurvePath(ctx, start, point, end, percent) {\r\n        ctx.beginPath();\r\n        ctx.moveTo(start[0], start[1]);\r\n        for (let t = 0; t <= percent / 100; t += 0.005) {\r\n            let x = this._quadraticBezier(start[0], point[0], end[0], t);\r\n            let y = this._quadraticBezier(start[1], point[1], end[1], t);\r\n            ctx.lineTo(x, y);\r\n        }\r\n        ctx.stroke();\r\n    }\r\n    _quadraticBezier(p0, p1, p2, t) {\r\n        let k = 1 - t;\r\n        return k * k * p0 + 2 * (1 - t) * t * p1 + t * t * p2; // 二次贝赛尔曲线方程\r\n    }\r\n}\r\n","import { PointAnimation } from \"./animation\";\r\nimport { WebMercator } from \"../projection/web-mercator\";\r\n/**\r\n * 星球或粒子类\r\n */\r\nclass Particle {\r\n    constructor(radius, speed, color) {\r\n        this.pos = Math.random() * 360;\r\n        this.c = color;\r\n        this.r = (Math.random() * radius / 10);\r\n        this.R = radius;\r\n        this.s = speed;\r\n    }\r\n}\r\n/**\r\n * 轨道类\r\n */\r\nclass Orbit {\r\n    constructor(radius, speed, color, count) {\r\n        this.particles = [];\r\n        this.radius = radius;\r\n        this.speed = speed;\r\n        this.color = color;\r\n        for (let index = 0; index < count; index++) {\r\n            let s = Math.random() / 60 * this.speed;\r\n            s = index % 2 ? s : s * -1;\r\n            this.particles.push(new Particle(radius, s, color));\r\n        }\r\n    }\r\n}\r\n/**\r\n * 星球环绕动画效果类\r\n * @remarks\r\n * 轨道星球环绕动画效果\r\n */\r\nexport class ParticleAnimation extends PointAnimation {\r\n    constructor() {\r\n        super(...arguments);\r\n        /**\r\n         * 轨道半径\r\n         */\r\n        this.radius = 20;\r\n        /**\r\n         * 环绕速度\r\n         */\r\n        this.speed = 10;\r\n        /**\r\n         * 颜色\r\n         */\r\n        this.color = \"#E76B76\";\r\n        /**\r\n         * 星球或粒子数\r\n         */\r\n        this.count = 40;\r\n        /**\r\n         * alpha通道\r\n         */\r\n        this.alpha = 0.5;\r\n        /**\r\n         * 颜色合成方式\r\n         */\r\n        this.composite = \"soft-light\";\r\n    }\r\n    /**\r\n     * 动画效果初始化\r\n     * @remarks\r\n     * 一般情况下，把一次性逻辑放于此处，以及处理动画的初始状态\r\n     * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n     * @param {Projection} projection - 坐标投影转换\r\n     */\r\n    init(ctx, projection = new WebMercator()) {\r\n        super.init(ctx, projection);\r\n        this._orbit = new Orbit(this.radius, this.speed, this.color, this.count);\r\n    }\r\n    /**\r\n     * 动画效果\r\n     * @remarks\r\n     * 通过Animator中requestAnimationFrame循环调用，因此注意优化代码，保持帧数\r\n     * @param {number} elapsed - 已逝去的时间，毫秒\r\n     * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n     */\r\n    animate(elapsed, ctx) {\r\n        ctx.save();\r\n        ctx.strokeStyle = this.color;\r\n        ctx.lineWidth = this.lineWidth;\r\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n        this._orbit.particles.forEach(particle => {\r\n            //绕圆形轨道，sin和cos来获得x和y的delta分量\r\n            particle.x = this._screenX + particle.R * Math.sin(Math.PI / 2 + particle.pos);\r\n            particle.y = this._screenY + particle.R * Math.cos(Math.PI / 2 + particle.pos);\r\n            particle.pos += particle.s;\r\n            ctx.beginPath();\r\n            ctx.globalAlpha = this.alpha;\r\n            ctx.globalCompositeOperation = this.composite;\r\n            ctx.fillStyle = particle.c;\r\n            ctx.arc(particle.x, particle.y, particle.r, 0, Math.PI * 2, false);\r\n            ctx.closePath();\r\n            ctx.fill();\r\n        });\r\n        ctx.restore();\r\n    }\r\n}\r\n","import { Subject } from \"./util/subject\";\r\n/**\r\n * 动画效果的管理器\r\n * 已内置于map，可通过map的接口进行添加删除的维护操作\r\n */\r\nexport class Animator extends Subject {\r\n    /**\r\n     * 创建Animator\r\n     * 不应自主创建，map内部创建\r\n     * @param {Map} map - 地图容器\r\n     */\r\n    constructor(map) {\r\n        super([\"mouseover\", \"mouseout\"]); //when mouseover feature\r\n        //图层列表\r\n        //private _layers: FeatureLayer[] = [];\r\n        this._animations = [];\r\n        this._map = map;\r\n        const container = map.container;\r\n        //create canvas\r\n        this._canvas = document.createElement(\"canvas\");\r\n        this._canvas.style.cssText = \"position: absolute; height: 100%; width: 100%; z-index: 80\";\r\n        this._canvas.width = container.clientWidth;\r\n        this._canvas.height = container.clientHeight;\r\n        container.appendChild(this._canvas);\r\n        this._onResize = this._onResize.bind(this);\r\n        this._extentChange = this._extentChange.bind(this);\r\n        this._ctx = this._canvas.getContext(\"2d\");\r\n        this._map.on(\"resize\", this._onResize);\r\n        this._map.on(\"extent\", this._extentChange);\r\n    }\r\n    //与主视图同步\r\n    _onResize(event) {\r\n        this._canvas.width = this._map.container.clientWidth;\r\n        this._canvas.height = this._map.container.clientHeight;\r\n    }\r\n    //与主视图同步\r\n    _extentChange(event) {\r\n        //const matrix = DOMMatrix.fromFloat64Array( new Float64Array([event.matrix.a, 0, 0, event.matrix.d, event.matrix.e, event.matrix.f] ) );\r\n        //this._ctx.setTransform(matrix);\r\n        this._ctx.setTransform(event.matrix.a, 0, 0, event.matrix.d, event.matrix.e, event.matrix.f);\r\n        this.redraw();\r\n    }\r\n    /**\r\n     * 添加动画\r\n     * @param {Animation} animation - 动画\r\n     */\r\n    addAnimation(animation) {\r\n        this._animations.push(animation);\r\n        this.redraw();\r\n    }\r\n    /**\r\n     * 删除动画\r\n     * @param {Animation} animation - 动画\r\n     */\r\n    removeAnimation(animation) {\r\n        const index = this._animations.findIndex(item => item === animation);\r\n        index != -1 && this._animations.splice(index, 1);\r\n        this.redraw();\r\n    }\r\n    /**\r\n     * 清除动画\r\n     */\r\n    clearAnimations() {\r\n        this._animations = [];\r\n        this.redraw();\r\n    }\r\n    /**\r\n     * 重绘\r\n     */\r\n    redraw() {\r\n        this._frame && window.cancelAnimationFrame(this._frame);\r\n        this._start = undefined;\r\n        this._ctx.save();\r\n        this._ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n        this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);\r\n        this._ctx.restore();\r\n        //动画初始化\r\n        this._animations.forEach(animation => {\r\n            animation.init(this._ctx, this._map.projection);\r\n        });\r\n        //this上下文绑定\r\n        this.animate = this.animate.bind(this);\r\n        //动画循环\r\n        this._frame = window.requestAnimationFrame(this.animate);\r\n    }\r\n    /**\r\n     * 动画循环\r\n     * @param {number} timestamp - 时间戳\r\n     */\r\n    animate(timestamp) {\r\n        if (this._start === undefined) {\r\n            this._start = timestamp;\r\n        }\r\n        //计算逝去时间，毫秒\r\n        const elapsed = timestamp - this._start;\r\n        this._ctx.save();\r\n        this._ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n        this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);\r\n        this._ctx.restore();\r\n        //遍历所以动画效果，执行动画\r\n        this._animations.forEach(animation => {\r\n            animation.animate(elapsed, this._ctx);\r\n        });\r\n        //循环，下一帧\r\n        this._frame = window.requestAnimationFrame(this.animate);\r\n    }\r\n    /**\r\n     * 清空画布\r\n     */\r\n    clear() {\r\n        this._ctx.save();\r\n        this._ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n        this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);\r\n        this._ctx.restore();\r\n    }\r\n    /**\r\n     * 销毁\r\n     */\r\n    destroy() {\r\n        this._map.off(\"resize\", this._onResize);\r\n        this._map.off(\"extent\", this._extentChange);\r\n        this._frame && window.cancelAnimationFrame(this._frame);\r\n    }\r\n}\r\n","import { Feature } from \"../element/feature\";\r\nimport { GeometryType } from \"../geometry/geometry\";\r\nimport { Point } from \"../geometry/point\";\r\nimport { Polyline } from \"../geometry/polyline\";\r\nimport { Polygon } from \"../geometry/polygon\";\r\nimport { MultiplePolygon } from \"../geometry/multiple-polygon\";\r\nimport { MultiplePolyline } from \"../geometry/multiple-polyline\";\r\nimport { MultiplePoint } from \"../geometry/multiple-point\";\r\n/**\r\n * 要素类（要素集合）\r\n * @remarks\r\n * TODO: a lot of things to be done\r\n */\r\nexport class FeatureClass {\r\n    /**\r\n     * 创建要素集合\r\n     * @param {GeometryType} type - 空间数据类型：点/线/面\r\n     */\r\n    constructor(type) {\r\n        /**\r\n         * 属性字段集合\r\n         */\r\n        this._fields = [];\r\n        /**\r\n         * 要素集合\r\n         */\r\n        this._features = [];\r\n        this._type = type;\r\n    }\r\n    /**\r\n     * 空间数据类型：点/线/面\r\n     */\r\n    get type() {\r\n        return this._type;\r\n    }\r\n    /**\r\n     * 要素集合\r\n     */\r\n    get features() {\r\n        return this._features;\r\n    }\r\n    /**\r\n     * 属性字段集合\r\n     */\r\n    get fields() {\r\n        return this._fields;\r\n    }\r\n    /**\r\n     * 添加要素\r\n     * @param {Feature} feature - 空间矢量要素\r\n     */\r\n    addFeature(feature) {\r\n        this._features.push(feature);\r\n    }\r\n    /**\r\n     * 删除要素\r\n     * @param {Feature} feature - 空间矢量要素\r\n     */\r\n    removeFeature(feature) {\r\n        const index = this._features.findIndex(item => item === feature);\r\n        index != -1 && this._features.splice(index, 1);\r\n    }\r\n    /**\r\n     * 清空要素集合\r\n     */\r\n    clearFeatures() {\r\n        this._features = [];\r\n    }\r\n    /**\r\n     * 添加字段\r\n     * @param {Field} field - 字段\r\n     */\r\n    addField(field) {\r\n        this._fields.push(field);\r\n    }\r\n    /**\r\n     * 删除字段\r\n     * @param {Field} field - 字段\r\n     */\r\n    removeField(field) {\r\n        const index = this._fields.findIndex(item => item === field);\r\n        index != -1 && this._fields.splice(index, 1);\r\n    }\r\n    /**\r\n     * 清空字段集合\r\n     */\r\n    clearFields() {\r\n        this._fields = [];\r\n    }\r\n    /**\r\n     * 加载GeoJSON数据格式\r\n     * @remarks\r\n     * @param {Object} data - GeoJSON数据\r\n     */\r\n    loadGeoJSON(data) {\r\n        Array.isArray(data.features) && data.features.forEach(item => {\r\n            switch (item.geometry.type) {\r\n                case \"Point\":\r\n                    //TODO: each feature has one type that is ridiculous, cause geojson is a featurecollection, not a featurelayer.\r\n                    this._type = GeometryType.Point;\r\n                    const point = new Point(item.geometry.coordinates[0], item.geometry.coordinates[1]);\r\n                    this.addFeature(new Feature(point, item.properties));\r\n                    break;\r\n                case \"LineString\":\r\n                    this._type = GeometryType.Polyline;\r\n                    const polyline = new Polyline(item.geometry.coordinates);\r\n                    this.addFeature(new Feature(polyline, item.properties));\r\n                    break;\r\n                case \"Polygon\":\r\n                    this._type = GeometryType.Polygon;\r\n                    const polygon = new Polygon(item.geometry.coordinates);\r\n                    this.addFeature(new Feature(polygon, item.properties));\r\n                    break;\r\n                case \"MultiPoint\":\r\n                    this._type = GeometryType.Point;\r\n                    const multipoint = new MultiplePoint(item.geometry.coordinates);\r\n                    this.addFeature(new Feature(multipoint, item.properties));\r\n                    break;\r\n                case \"MultiLineString\":\r\n                    this._type = GeometryType.Polyline;\r\n                    const multipolyline = new MultiplePolyline(item.geometry.coordinates);\r\n                    this.addFeature(new Feature(multipolyline, item.properties));\r\n                    break;\r\n                case \"MultiPolygon\":\r\n                    this._type = GeometryType.Polygon;\r\n                    const multipolygon = new MultiplePolygon(item.geometry.coordinates);\r\n                    this.addFeature(new Feature(multipolygon, item.properties));\r\n                    break;\r\n            }\r\n        });\r\n    }\r\n}\r\n","/**\r\n * 字段类型\r\n */\r\nexport var FieldType;\r\n(function (FieldType) {\r\n    /**\r\n     * 字符串\r\n     */\r\n    FieldType[FieldType[\"String\"] = 1] = \"String\";\r\n    /**\r\n     * 数值型\r\n     */\r\n    FieldType[FieldType[\"Number\"] = 2] = \"Number\";\r\n})(FieldType || (FieldType = {}));\r\n/**\r\n * 字段\r\n * @remarks\r\n * TODO: a lot of things to be done\r\n */\r\nexport class Field {\r\n}\r\n","import { GeometryType } from \"../geometry/geometry\";\r\nimport { GraphicLayer } from \"../layer/graphic-layer\";\r\nimport { Graphic } from \"../element/graphic\";\r\nimport { Feature } from \"../element/feature\";\r\nimport { Point } from \"../geometry/point\";\r\nimport { SimpleFillSymbol, SimpleLineSymbol, SimplePointSymbol, VertexSymbol } from \"../symbol/symbol\";\r\nimport { Subject } from \"../util/subject\";\r\nimport { Polyline } from \"../geometry/polyline\";\r\nimport { Polygon } from \"../geometry/polygon\";\r\nexport var EditorActionType;\r\n(function (EditorActionType) {\r\n    EditorActionType[EditorActionType[\"Select\"] = 0] = \"Select\";\r\n    EditorActionType[EditorActionType[\"Create\"] = 1] = \"Create\";\r\n    EditorActionType[EditorActionType[\"Edit\"] = 2] = \"Edit\";\r\n})(EditorActionType || (EditorActionType = {}));\r\n/**\r\n * Editor\r\n * 相对于Viewer，管理所有编辑状态下的图层\r\n * 优化的产物\r\n */\r\nexport class Editor extends Subject {\r\n    /**\r\n     * 创建Editor\r\n     * 不应自主创建，map内部创建\r\n     * @param {Map} map - 地图容器\r\n     */\r\n    constructor(map) {\r\n        super([\"mouseover\", \"mouseout\", \"startedit\", \"stopedit\", \"click\", \"update\", \"commit\", \"create\", \"delete\"]); //when mouseover feature or vertex\r\n        this._drag = {\r\n            flag: false,\r\n            vertex: null,\r\n            start: {\r\n                x: 0,\r\n                y: 0\r\n            },\r\n            end: {\r\n                x: 0,\r\n                y: 0\r\n            }\r\n        };\r\n        this._create = {\r\n            click: 0,\r\n            graphic: null,\r\n            lnglats: []\r\n        };\r\n        this._action = EditorActionType.Select;\r\n        this._defaultPointSymbol = new SimplePointSymbol();\r\n        this._defaultLineSymbol = new SimpleLineSymbol();\r\n        this._defaultPolygonSymbol = new SimpleFillSymbol();\r\n        this._map = map;\r\n        const container = map.container;\r\n        //create canvas\r\n        this._canvas = document.createElement(\"canvas\");\r\n        this._canvas.style.cssText = \"position: absolute; height: 100%; width: 100%; z-index: 90\";\r\n        this._canvas.width = container.clientWidth;\r\n        this._canvas.height = container.clientHeight;\r\n        container.appendChild(this._canvas);\r\n        this._ctx = this._canvas.getContext(\"2d\");\r\n        this._onResize = this._onResize.bind(this);\r\n        this._extentChange = this._extentChange.bind(this);\r\n        this._switchEditing = this._switchEditing.bind(this);\r\n        this._map.on(\"resize\", this._onResize);\r\n        this._map.on(\"extent\", this._extentChange);\r\n    }\r\n    get editing() {\r\n        return this._editing;\r\n    }\r\n    get editingFeature() {\r\n        return this._editingFeature;\r\n    }\r\n    get action() {\r\n        return this._action;\r\n    }\r\n    set action(value) {\r\n        this._action = value;\r\n    }\r\n    get defaultPointSymbol() {\r\n        return this._defaultPointSymbol;\r\n    }\r\n    set defaultPointSymbol(value) {\r\n        this._defaultPointSymbol = value;\r\n    }\r\n    get defaultLineSymbol() {\r\n        return this._defaultLineSymbol;\r\n    }\r\n    set defaultLineSymbol(value) {\r\n        this._defaultLineSymbol = value;\r\n    }\r\n    get defaultPolygonSymbol() {\r\n        return this._defaultPolygonSymbol;\r\n    }\r\n    set defaultPolygonSymbol(value) {\r\n        this._defaultPolygonSymbol = value;\r\n    }\r\n    setFeatureLayer(layer) {\r\n        if (this._editing) {\r\n            this._featureLayer = layer;\r\n            this._featureLayer.editing = true;\r\n            this._featureLayer.on(\"dblclick\", this._switchEditing);\r\n            this._map.redraw();\r\n            //layer.draw(this._ctx, this._map.projection, this._map.extent, this._map.zoom);\r\n        }\r\n        else {\r\n            throw new Error(\"please start editing!\");\r\n        }\r\n    }\r\n    start() {\r\n        if (!this._editing) {\r\n            this._editing = true;\r\n            this._vertexLayer = new GraphicLayer();\r\n            this._action = EditorActionType.Select;\r\n            this._createLayer = new GraphicLayer();\r\n            this._handlers[\"startedit\"].forEach(handler => handler());\r\n        }\r\n        //TODO: edit stack for undo/redo\r\n    }\r\n    create() {\r\n        this._action = EditorActionType.Create;\r\n        this._vertexLayer.clear();\r\n        this._editingFeature = null;\r\n        this.redraw();\r\n    }\r\n    save() {\r\n    }\r\n    stop() {\r\n        if (this._editing) {\r\n            this._editing = false;\r\n            this._editingFeature = null;\r\n            this._featureLayer.editing = false;\r\n            this._featureLayer.off(\"dblclick\", this._switchEditing);\r\n            this._featureLayer = null;\r\n            this._vertexLayer = null;\r\n            this._action = EditorActionType.Select;\r\n            this._create = {\r\n                click: 0,\r\n                graphic: null,\r\n                lnglats: []\r\n            };\r\n            this._drag = {\r\n                flag: false,\r\n                vertex: null,\r\n                start: {\r\n                    x: 0,\r\n                    y: 0\r\n                },\r\n                end: {\r\n                    x: 0,\r\n                    y: 0\r\n                }\r\n            };\r\n            this.clear();\r\n            this._handlers[\"stopedit\"].forEach(handler => handler());\r\n        }\r\n    }\r\n    addFeature(feature) {\r\n        this._featureLayer.featureClass.addFeature(feature);\r\n        feature.on(\"dblclick\", this._switchEditing);\r\n        this._handlers[\"create\"].forEach(handler => handler({ feature: feature }));\r\n        this.redraw();\r\n    }\r\n    removeFeature(feature) {\r\n        this._featureLayer.featureClass.removeFeature(feature);\r\n        feature.off(\"dblclick\", this._switchEditing);\r\n        this._handlers[\"delete\"].forEach(handler => handler({ feature: feature }));\r\n        this.redraw();\r\n    }\r\n    _onResize(event) {\r\n        this._canvas.width = this._map.container.clientWidth;\r\n        this._canvas.height = this._map.container.clientHeight;\r\n    }\r\n    _extentChange(event) {\r\n        this._ctx.setTransform(event.matrix.a, 0, 0, event.matrix.d, event.matrix.e, event.matrix.f);\r\n        this.redraw();\r\n    }\r\n    _getMiddlePoint(point1, point2) {\r\n        point1.project(this._map.projection);\r\n        point2.project(this._map.projection);\r\n        const [x, y] = [(point1.x + point2.x) / 2, (point1.y + point2.y) / 2];\r\n        const [lng, lat] = this._map.projection.unproject([x, y]);\r\n        return new Point(lng, lat);\r\n    }\r\n    _switchEditing(event) {\r\n        if (!this._editingFeature && this._action === EditorActionType.Select) {\r\n            this._action = EditorActionType.Edit;\r\n            this._editingFeature = event.feature;\r\n            if (this._editingFeature.geometry instanceof Point) {\r\n                const point = this._editingFeature.geometry;\r\n                const vertex = new Graphic(point, new VertexSymbol());\r\n                this._vertexLayer.add(vertex);\r\n                this.redraw();\r\n            }\r\n            else if (this._editingFeature.geometry instanceof Polyline) {\r\n                const polyline = this._editingFeature.geometry;\r\n                polyline.lnglats.forEach((lnglat, index) => {\r\n                    const point = new Point(lnglat[0], lnglat[1]);\r\n                    const vertex = new Graphic(point, new VertexSymbol());\r\n                    this._vertexLayer.add(vertex);\r\n                    vertex.on(\"dragstart\", (event) => {\r\n                        this._drag.vertex = vertex;\r\n                    });\r\n                    vertex.on(\"dblclick\", (event) => {\r\n                        this._vertexLayer.remove(vertex);\r\n                        this._editingFeature.edited = true;\r\n                        polyline.splice(this._ctx, this._map.projection, [point.lng, point.lat]);\r\n                        this.redraw();\r\n                    });\r\n                    //middle point\r\n                    /*if (index < polyline.lnglats.length - 1) {\r\n                        const p1: Point = new Point(lnglat[0], lnglat[1]), p2: Point = new Point(polyline.lnglats[index + 1][0], polyline.lnglats[index + 1][1]);\r\n                        const p: Point = this._getMiddlePoint(p1, p2);\r\n                        const symbol: VertexSymbol = new VertexSymbol();\r\n                        symbol.strokeStyle = \"#888888\";\r\n                        symbol.fillStyle = \"#88888888\";\r\n                        symbol.size = 6;\r\n                        const middle: Graphic = new Graphic(p, symbol);\r\n                        this._vertexLayer.add(middle);\r\n                    }*/\r\n                });\r\n                this.redraw();\r\n            }\r\n            else if (this._editingFeature.geometry instanceof Polygon) {\r\n                const polygon = this._editingFeature.geometry;\r\n                polygon.lnglats.forEach(ring => {\r\n                    ring.forEach(lnglat => {\r\n                        const point = new Point(lnglat[0], lnglat[1]);\r\n                        const vertex = new Graphic(point, new VertexSymbol());\r\n                        this._vertexLayer.add(vertex);\r\n                        vertex.on(\"dragstart\", (event) => {\r\n                            this._drag.vertex = vertex;\r\n                        });\r\n                        vertex.on(\"dblclick\", (event) => {\r\n                            this._vertexLayer.remove(vertex);\r\n                            this._editingFeature.edited = true;\r\n                            polygon.splice(this._ctx, this._map.projection, [point.lng, point.lat]);\r\n                            this.redraw();\r\n                        });\r\n                    });\r\n                });\r\n                this.redraw();\r\n            }\r\n        }\r\n        else if (this._editingFeature === event.feature && this._action === EditorActionType.Edit) {\r\n            this._action = EditorActionType.Select;\r\n            if (this._editingFeature.edited) {\r\n                this._handlers[\"update\"].forEach(handler => handler({ feature: this._editingFeature }));\r\n                this._editingFeature.edited = false;\r\n            }\r\n            this._editingFeature = null;\r\n            this._vertexLayer.clear();\r\n            this.redraw();\r\n        }\r\n    }\r\n    redraw() {\r\n        this._ctx.save();\r\n        this._ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n        this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);\r\n        this._ctx.restore();\r\n        this._featureLayer && this._featureLayer.draw(this._ctx, this._map.projection, this._map.extent, this._map.zoom);\r\n        this._vertexLayer && this._vertexLayer.draw(this._ctx, this._map.projection, this._map.extent, this._map.zoom);\r\n        this._createLayer && this._createLayer.draw(this._ctx, this._map.projection, this._map.extent, this._map.zoom);\r\n    }\r\n    clear() {\r\n        this._ctx.save();\r\n        this._ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n        this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);\r\n        this._ctx.restore();\r\n    }\r\n    _onClick(event) {\r\n        if (event.detail > 1)\r\n            return;\r\n        if (this._action === EditorActionType.Create) {\r\n            if (this._featureLayer.featureClass.type == GeometryType.Point) {\r\n                const point = new Point(event.lng, event.lat);\r\n                const feature = new Feature(point, {}, this._defaultPointSymbol);\r\n                this.addFeature(feature);\r\n                this._action = EditorActionType.Select;\r\n            }\r\n            else if (this._featureLayer.featureClass.type == GeometryType.Polygon) {\r\n                if (this._create.click == 0) {\r\n                    this._createLayer.clear();\r\n                    const point = new Point(event.lng, event.lat);\r\n                    const graphic = new Graphic(point, this._defaultPointSymbol);\r\n                    this._createLayer.add(graphic);\r\n                    this._create.click += 1;\r\n                    this._create.lnglats.push([event.lng, event.lat]);\r\n                }\r\n                else if (this._create.click == 1) {\r\n                    const second = new Point(event.lng, event.lat);\r\n                    const graphic1 = new Graphic(second, this._defaultPointSymbol);\r\n                    this._createLayer.add(graphic1);\r\n                    if (this._create.graphic)\r\n                        this._createLayer.remove(this._create.graphic);\r\n                    this._create.lnglats.push([event.lng, event.lat]);\r\n                    const line = new Polyline(this._create.lnglats);\r\n                    this._create.graphic = new Graphic(line, this._defaultLineSymbol);\r\n                    this._createLayer.add(this._create.graphic);\r\n                    this._create.click += 1;\r\n                }\r\n                else {\r\n                    const second = new Point(event.lng, event.lat);\r\n                    const graphic1 = new Graphic(second, this._defaultPointSymbol);\r\n                    this._createLayer.add(graphic1);\r\n                    if (this._create.graphic)\r\n                        this._createLayer.remove(this._create.graphic);\r\n                    this._create.lnglats.push([event.lng, event.lat]);\r\n                    const polygon = new Polygon([this._create.lnglats]);\r\n                    this._create.graphic = new Graphic(polygon, this._defaultPolygonSymbol);\r\n                    this._createLayer.add(this._create.graphic);\r\n                    this._create.click += 1;\r\n                }\r\n            }\r\n            else if (this._featureLayer.featureClass.type == GeometryType.Polyline) {\r\n                if (this._create.click == 0) {\r\n                    this._createLayer.clear();\r\n                    const point = new Point(event.lng, event.lat);\r\n                    const graphic = new Graphic(point, this._defaultPointSymbol);\r\n                    this._createLayer.add(graphic);\r\n                    this._create.click += 1;\r\n                    this._create.lnglats.push([event.lng, event.lat]);\r\n                }\r\n                else {\r\n                    const second = new Point(event.lng, event.lat);\r\n                    const graphic1 = new Graphic(second, this._defaultPointSymbol);\r\n                    this._createLayer.add(graphic1);\r\n                    if (this._create.graphic)\r\n                        this._createLayer.remove(this._create.graphic);\r\n                    this._create.lnglats.push([event.lng, event.lat]);\r\n                    const line = new Polyline(this._create.lnglats);\r\n                    this._create.graphic = new Graphic(line, this._defaultLineSymbol);\r\n                    this._createLayer.add(this._create.graphic);\r\n                    this._create.click += 1;\r\n                }\r\n            }\r\n            this._handlers[\"click\"].forEach(handler => handler(event));\r\n        }\r\n        else {\r\n            /*if (!this._editingFeature) {\r\n                this._featureLayer.contain(event.offsetX, event.offsetY, this._map.projection, this._map.extent, this._map.zoom, \"click\");\r\n            }*/\r\n        }\r\n    }\r\n    _onDoubleClick(event) {\r\n        if (!this._editing)\r\n            return;\r\n        if (this._action === EditorActionType.Create) {\r\n            if (this._featureLayer.featureClass.type == GeometryType.Polygon) {\r\n                if (this._create.click > 1) {\r\n                    if (this._create.graphic)\r\n                        this._createLayer.remove(this._create.graphic);\r\n                    const polygon = new Polygon([this._create.lnglats]);\r\n                    const feature = new Feature(polygon, {}, this._defaultPolygonSymbol);\r\n                    this._create = {\r\n                        click: 0,\r\n                        graphic: null,\r\n                        lnglats: []\r\n                    };\r\n                    this._createLayer.clear();\r\n                    this.addFeature(feature);\r\n                    this._action = EditorActionType.Select;\r\n                }\r\n            }\r\n            else if (this._featureLayer.featureClass.type == GeometryType.Polyline) {\r\n                if (this._create.click > 0) {\r\n                    if (this._create.graphic)\r\n                        this._createLayer.remove(this._create.graphic);\r\n                    const polyline = new Polyline(this._create.lnglats);\r\n                    const feature = new Feature(polyline, {}, this._defaultLineSymbol);\r\n                    this._create = {\r\n                        click: 0,\r\n                        graphic: null,\r\n                        lnglats: []\r\n                    };\r\n                    this._createLayer.clear();\r\n                    this.addFeature(feature);\r\n                    this._action = EditorActionType.Select;\r\n                }\r\n            }\r\n            return;\r\n        }\r\n        if (this._editingFeature && !(this._editingFeature.geometry instanceof Point)) {\r\n            const flag = this._vertexLayer.contain(event.offsetX, event.offsetY, this._map.projection, this._map.extent, this._map.zoom, \"dblclick\");\r\n            if (flag)\r\n                return;\r\n        }\r\n        this._featureLayer.contain(event.offsetX, event.offsetY, this._map.projection, this._map.extent, this._map.zoom, \"dblclick\");\r\n    }\r\n    _onMouseDown(event) {\r\n        if (this._action === EditorActionType.Create)\r\n            return;\r\n        if (this._editingFeature) {\r\n            this._drag.flag = this._vertexLayer.contain(event.offsetX, event.offsetY, this._map.projection, this._map.extent, this._map.zoom, \"dragstart\");\r\n            this._drag.start.x = event.x;\r\n            this._drag.start.y = event.y;\r\n        }\r\n    }\r\n    _onMouseMove(event) {\r\n        if (this._action === EditorActionType.Create) {\r\n            if (this._featureLayer.featureClass.type == GeometryType.Polygon) {\r\n                if (this._create.click == 1) {\r\n                    if (this._create.graphic)\r\n                        this._createLayer.remove(this._create.graphic);\r\n                    const lnglats = [...this._create.lnglats];\r\n                    lnglats.push([event.lng, event.lat]);\r\n                    const line = new Polyline(lnglats);\r\n                    this._create.graphic = new Graphic(line, this._defaultLineSymbol);\r\n                    this._createLayer.add(this._create.graphic);\r\n                }\r\n                else if (this._create.click > 1) {\r\n                    if (this._create.graphic)\r\n                        this._createLayer.remove(this._create.graphic);\r\n                    const lnglats = [...this._create.lnglats];\r\n                    lnglats.push([event.lng, event.lat]);\r\n                    const polygon = new Polygon([lnglats]);\r\n                    this._create.graphic = new Graphic(polygon, this._defaultPolygonSymbol);\r\n                    this._createLayer.add(this._create.graphic);\r\n                }\r\n            }\r\n            else if (this._featureLayer.featureClass.type == GeometryType.Polyline) {\r\n                if (this._create.click > 0) {\r\n                    if (this._create.graphic)\r\n                        this._createLayer.remove(this._create.graphic);\r\n                    const lnglats = [...this._create.lnglats];\r\n                    lnglats.push([event.lng, event.lat]);\r\n                    const line = new Polyline(lnglats);\r\n                    this._create.graphic = new Graphic(line, this._defaultLineSymbol);\r\n                    this._createLayer.add(this._create.graphic);\r\n                }\r\n            }\r\n            this.redraw();\r\n            return;\r\n        }\r\n        if (!this._drag.flag) {\r\n            const flag1 = this._featureLayer.contain(event.offsetX, event.offsetY, this._map.projection, this._map.extent, this._map.zoom, \"mousemove\");\r\n            const flag2 = this._vertexLayer.contain(event.offsetX, event.offsetY, this._map.projection, this._map.extent, this._map.zoom, \"mousemove\");\r\n            if (flag1 || flag2) {\r\n                this.emit(\"mouseover\", event);\r\n            }\r\n            else {\r\n                this.emit(\"mouseout\", event);\r\n            }\r\n        }\r\n    }\r\n    _onMouseUp(event) {\r\n        if (this._action === EditorActionType.Create)\r\n            return;\r\n        if (this._drag.flag) {\r\n            this._drag.end.x = event.x;\r\n            this._drag.end.y = event.y;\r\n            this._drag.flag = false;\r\n            this._editingFeature.edited = true;\r\n            if (this._editingFeature.geometry instanceof Point) {\r\n                const point = this._editingFeature.geometry;\r\n                point.move(this._ctx, this._map.projection, event.offsetX, event.offsetY);\r\n                this.redraw();\r\n            }\r\n            else if (this._editingFeature.geometry instanceof Polyline) {\r\n                if (this._drag.vertex) {\r\n                    const polyline = this._editingFeature.geometry;\r\n                    const point = this._drag.vertex.geometry;\r\n                    polyline.splice(this._ctx, this._map.projection, [point.lng, point.lat], event.offsetX, event.offsetY, !event.shiftKey);\r\n                    if (event.shiftKey) {\r\n                        const shift = new Point(point.lng, point.lat);\r\n                        shift.move(this._ctx, this._map.projection, event.offsetX, event.offsetY);\r\n                        const vertex = new Graphic(shift, new VertexSymbol());\r\n                        this._vertexLayer.add(vertex);\r\n                        vertex.on(\"dragstart\", (event) => {\r\n                            this._drag.vertex = vertex;\r\n                        });\r\n                        vertex.on(\"dblclick\", (event) => {\r\n                            this._vertexLayer.remove(vertex);\r\n                            this._editingFeature.edited = true;\r\n                            polyline.splice(this._ctx, this._map.projection, [shift.lng, shift.lat]);\r\n                            this.redraw();\r\n                        });\r\n                    }\r\n                    else {\r\n                        point.move(this._ctx, this._map.projection, event.offsetX, event.offsetY);\r\n                    }\r\n                    this._drag.vertex = null;\r\n                    this.redraw();\r\n                }\r\n            }\r\n            else if (this._editingFeature.geometry instanceof Polygon) {\r\n                if (this._drag.vertex) {\r\n                    const polygon = this._editingFeature.geometry;\r\n                    const point = this._drag.vertex.geometry;\r\n                    polygon.splice(this._ctx, this._map.projection, [point.lng, point.lat], event.offsetX, event.offsetY, !event.shiftKey);\r\n                    if (event.shiftKey) {\r\n                        const shift = new Point(point.lng, point.lat);\r\n                        shift.move(this._ctx, this._map.projection, event.offsetX, event.offsetY);\r\n                        const vertex = new Graphic(shift, new VertexSymbol());\r\n                        this._vertexLayer.add(vertex);\r\n                        vertex.on(\"dragstart\", (event) => {\r\n                            this._drag.vertex = vertex;\r\n                        });\r\n                        vertex.on(\"dblclick\", (event) => {\r\n                            this._vertexLayer.remove(vertex);\r\n                            this._editingFeature.edited = true;\r\n                            polygon.splice(this._ctx, this._map.projection, [shift.lng, shift.lat]);\r\n                            this.redraw();\r\n                        });\r\n                    }\r\n                    else {\r\n                        point.move(this._ctx, this._map.projection, event.offsetX, event.offsetY);\r\n                    }\r\n                    this._drag.vertex = null;\r\n                    this.redraw();\r\n                }\r\n            }\r\n        }\r\n    }\r\n    destroy() {\r\n        this._featureLayer = null;\r\n        this._map.off(\"resize\", this._onResize);\r\n        this._map.off(\"extent\", this._extentChange);\r\n    }\r\n}\r\n","import { SimplePointSymbol, SimpleTextSymbol, ClusterSymbol } from \"../symbol/symbol\";\r\nimport { WebMercator } from \"../projection/web-mercator\";\r\nimport { Subject } from \"../util/subject\";\r\n/**\r\n * 矢量要素\r\n * @remarks\r\n * Graphic vs Feature：Graphic作为图形，可以一图形对应一渲染符号；而Feature作为矢量要素，常规应该根据图层设定的渲染方式Renderer来得到各个Feature的渲染符号，而非单一设置。\r\n * Graphic = Geometry + Symbol\r\n * Feature = Geometry + Properties\r\n * ArcGIS AO/AE: Feature = Geometry + Properties\r\n * ArcGIS JS API: Feature = Graphic = Geometry + Properties + Symbol\r\n */\r\nexport class Feature extends Subject {\r\n    /*private _animation: Animation;\r\n    get animation(): Animation {\r\n        return this._animation;\r\n    }\r\n    set animation(value: Animation) {\r\n        this._animation = value;\r\n    }*/\r\n    /**\r\n     * 创建矢量要素\r\n     * @param {Geometry} geometry - 空间图形\r\n     * @param {Object} properties - 属性信息\r\n     * @param {Symbol} symbol - 渲染符号\r\n     */\r\n    constructor(geometry, properties, symbol) {\r\n        super([\"click\", \"dblclick\", \"mouseover\", \"mouseout\"]);\r\n        /**\r\n         * 是否可见\r\n         */\r\n        this.visible = true;\r\n        this._geometry = geometry;\r\n        this._properties = properties;\r\n        this._symbol = symbol;\r\n    }\r\n    //****************重要说明***************\r\n    //有关 getter setter\r\n    //1.如按原先代码规则，private _variable\r\n    //  只做为类内部函数服务：no getter no setter\r\n    //  只读：getter no setter\r\n    //  读写：getter + setter\r\n    //2.后经 public 的定义扩展，可得到：\r\n    //  public = private + getter + setter\r\n    //  另：public 可省略\r\n    //注：两种规则无差别，按习惯编写。\r\n    /**\r\n     * 渲染符号\r\n     */\r\n    get symbol() {\r\n        return this._symbol;\r\n    }\r\n    /**\r\n     * 渲染符号\r\n     */\r\n    set symbol(value) {\r\n        this._symbol = value;\r\n    }\r\n    /**\r\n     * 空间图形\r\n     */\r\n    get geometry() {\r\n        return this._geometry;\r\n    }\r\n    /**\r\n     * 属性信息\r\n     */\r\n    get properties() {\r\n        return this._properties;\r\n    }\r\n    /**\r\n     * 标注符号\r\n     */\r\n    get text() {\r\n        return this._text;\r\n    }\r\n    /**\r\n     * 标注符号\r\n     */\r\n    set text(value) {\r\n        this._text = value;\r\n    }\r\n    /**\r\n     * 包络矩形\r\n     */\r\n    get bound() {\r\n        return this._geometry ? this._geometry.bound : null;\r\n    }\r\n    /**\r\n     * RBush\r\n     */\r\n    get minX() {\r\n        return this.bound ? this.bound.xmin : 0;\r\n    }\r\n    get maxX() {\r\n        return this.bound ? this.bound.xmax : 0;\r\n    }\r\n    get minY() {\r\n        return this.bound ? this.bound.ymin : 0;\r\n    }\r\n    get maxY() {\r\n        return this.bound ? this.bound.ymax : 0;\r\n    }\r\n    /**\r\n     * 是否处于编辑状态\r\n     */\r\n    get edited() {\r\n        return this._edited;\r\n    }\r\n    /**\r\n     * 是否处于编辑状态\r\n     */\r\n    set edited(value) {\r\n        this._edited = value;\r\n    }\r\n    /**\r\n     * 绘制要素\r\n     * @remarks 调用空间坐标信息进行图形绘制\r\n     * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n     * @param {Projection} projection - 坐标投影转换\r\n     * @param {Bound} extent - 当前可视范围\r\n     * @param {Symbol} symbol - 渲染符号，一般来自于renderer\r\n     */\r\n    draw(ctx, projection = new WebMercator(), extent = projection.bound, symbol = new SimplePointSymbol()) {\r\n        if (this.visible)\r\n            this._geometry.draw(ctx, projection, extent, symbol instanceof ClusterSymbol ? symbol : (this._symbol || symbol));\r\n    }\r\n    /*animate(elapsed, ctx: CanvasRenderingContext2D, projection: Projection = new WebMercator(), extent: Bound = projection.bound, animation: Animation = new Animation()) {\r\n        if (this.visible) this._geometry.animate(elapsed, ctx, projection, extent, this._animation || animation);\r\n    }*/\r\n    /**\r\n     * 标注要素\r\n     * @remarks 调用空间坐标信息进行标注绘制\r\n     * @param {Field} field - 标注字段\r\n     * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n     * @param {Projection} projection - 坐标投影转换\r\n     * @param {SimpleTextSymbol} symbol - 标注符号\r\n     */\r\n    label(field, ctx, projection = new WebMercator(), symbol = new SimpleTextSymbol()) {\r\n        if (this.visible)\r\n            this._geometry.label(this._properties[field.name], ctx, projection, this._text || symbol);\r\n    }\r\n    /**\r\n     * 判断是否在可视范围内\r\n     * @param {Projection} projection - 坐标投影转换\r\n     * @param {Bound} extent - 当前可视范围\r\n     * @return {boolean} 是否在可视范围内\r\n     */\r\n    intersect(projection = new WebMercator(), extent = projection.bound) {\r\n        if (this.visible)\r\n            return this._geometry.intersect(projection, extent);\r\n    }\r\n    /**\r\n     * 交互判断\r\n     * @remarks 鼠标坐标是否落入要素\r\n     * @param {number} screenX - 鼠标屏幕坐标X\r\n     * @param {number} screenX - 鼠标屏幕坐标Y\r\n     * @param {string} event - 当前事件名称\r\n     * @return {boolean} 是否落入\r\n     */\r\n    contain(screenX, screenY, event = undefined) {\r\n        if (this.visible) {\r\n            const flag = this._geometry.contain(screenX, screenY);\r\n            if (event == \"mousemove\") {\r\n                if (!this._contained && flag) {\r\n                    //this._handlers[\"mouseover\"].forEach(handler => handler({feature: this, screenX: screenX, screenY: screenY}));\r\n                    this.emit(\"mouseover\", { feature: this, screenX: screenX, screenY: screenY });\r\n                }\r\n                else if (this._contained && !flag) {\r\n                    //this._handlers[\"mouseout\"].forEach(handler => handler({feature: this, screenX: screenX, screenY: screenY}));\r\n                    this.emit(\"mouseout\", { feature: this, screenX: screenX, screenY: screenY });\r\n                }\r\n            }\r\n            this._contained = flag;\r\n            return flag;\r\n        }\r\n    }\r\n}\r\n","import { WebMercator } from \"../projection/web-mercator\";\r\nimport { Subject } from \"../util/subject\";\r\n/**\r\n * 图形要素\r\n * @remarks\r\n * 区别与Feature，单纯的图形\r\n */\r\nexport class Graphic extends Subject {\r\n    /*private _animation: Animation;\r\n    get animation(): Animation {\r\n        return this._animation;\r\n    }\r\n    set animation(value: Animation) {\r\n        this._animation = value;\r\n    }*/\r\n    /**\r\n     * 创建图形要素\r\n     * @param {Geometry} geometry - 空间图形\r\n     * @param {Symbol} symbol - 渲染符号\r\n     */\r\n    constructor(geometry, symbol) {\r\n        super([\"click\", \"dblclick\", \"mouseover\", \"mouseout\", \"dragstart\"]);\r\n        /**\r\n         * 是否可见\r\n         */\r\n        this.visible = true;\r\n        this._geometry = geometry;\r\n        this._symbol = symbol;\r\n    }\r\n    /**\r\n     * 包络矩形\r\n     */\r\n    get bound() {\r\n        return this._geometry ? this._geometry.bound : null;\r\n    }\r\n    /**\r\n     * 空间图形\r\n     */\r\n    get geometry() {\r\n        return this._geometry;\r\n    }\r\n    /**\r\n     * 渲染符号\r\n     */\r\n    get symbol() {\r\n        return this._symbol;\r\n    }\r\n    /**\r\n     * 渲染符号\r\n     */\r\n    set symbol(value) {\r\n        this._symbol = value;\r\n    }\r\n    /**\r\n     * 绘制图形\r\n     * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n     * @param {Projection} projection - 坐标投影转换\r\n     * @param {Bound} extent - 当前可视范围\r\n     */\r\n    draw(ctx, projection = new WebMercator(), extent = projection.bound) {\r\n        if (this.visible)\r\n            this._geometry.draw(ctx, projection, extent, this._symbol);\r\n    }\r\n    /*animate(elapsed, ctx: CanvasRenderingContext2D, projection: Projection = new WebMercator(), extent: Bound = projection.bound) {\r\n        if (this.visible) this._geometry.animate(elapsed, ctx, projection, extent, this._animation);\r\n    }*/\r\n    /**\r\n     * 判断是否在可视范围内\r\n     * @param {Projection} projection - 坐标投影转换\r\n     * @param {Bound} extent - 当前可视范围\r\n     * @return {boolean} 是否在可视范围内\r\n     */\r\n    intersect(projection = new WebMercator(), extent = projection.bound) {\r\n        if (this.visible)\r\n            return this._geometry.intersect(projection, extent);\r\n    }\r\n    /**\r\n     * 交互判断\r\n     * @remarks 鼠标坐标是否落入图形\r\n     * @param {number} screenX - 鼠标屏幕坐标X\r\n     * @param {number} screenX - 鼠标屏幕坐标Y\r\n     * @param {string} event - 当前事件名称\r\n     * @return {boolean} 是否落入\r\n     */\r\n    contain(screenX, screenY, event = undefined) {\r\n        if (this.visible) {\r\n            const flag = this._geometry.contain(screenX, screenY);\r\n            if (event == \"mousemove\") {\r\n                if (!this._contained && flag) {\r\n                    this.emit(\"mouseover\", { feature: this, screenX: screenX, screenY: screenY });\r\n                }\r\n                else if (this._contained && !flag) {\r\n                    this.emit(\"mouseout\", { feature: this, screenX: screenX, screenY: screenY });\r\n                }\r\n            }\r\n            this._contained = flag;\r\n            return flag;\r\n        }\r\n    }\r\n}\r\n","import { Bound } from \"../util/bound\";\r\nimport { WebMercator } from \"../projection/web-mercator\";\r\n/*\r\n * 栅格\r\n */\r\nexport class Raster {\r\n    /**\r\n     * 创建栅格\r\n     * @remarks\r\n     * 遍历图形集合进行绘制\r\n     * @param {number} xmin - 经度左值\r\n     * @param {number} ymin - 纬度下值\r\n     * @param {number} xmax - 经度右值\r\n     * @param {number} ymax - 纬度上值\r\n     * @param {number} width - 栅格宽度\r\n     * @param {number} height - 栅格高度\r\n     * @param {number} cellsize - 栅格大小\r\n     */\r\n    constructor(xmin, ymin, xmax, ymax, width = 1000, height = 1000) {\r\n        this._canvas = document.createElement(\"canvas\");\r\n        this._canvas.width = width;\r\n        this._canvas.height = height;\r\n        this._bound = new Bound(xmin, ymin, xmax, ymax);\r\n    }\r\n    /*\r\n     * 动态栅格（实时渲染）\r\n     */\r\n    get dynamic() {\r\n        return false;\r\n    }\r\n    /*\r\n     * 画布存放Image\r\n     */\r\n    get canvas() {\r\n        return this._canvas;\r\n    }\r\n    /*\r\n     * 栅格经纬度边界\r\n     */\r\n    get bound() {\r\n        return this._bound;\r\n    }\r\n    /**\r\n     * 绘制栅格\r\n     * @remarks\r\n     * 遍历图形集合进行绘制\r\n     * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n     * @param {Projection} projection - 坐标投影转换\r\n     * @param {Bound} extent - 当前可视范围\r\n     * @param {number} zoom - 当前缩放级别\r\n     */\r\n    draw(ctx, projection = new WebMercator(), extent = projection.bound, zoom = 10) {\r\n    }\r\n}\r\n","/**\r\n * 实体基类（保留）\r\n */\r\nexport class Entity {\r\n    /**\r\n     * 创建实体\r\n     */\r\n    constructor() {\r\n        this._id = null;\r\n        this.create();\r\n    }\r\n    /**\r\n     * 全局唯一ID\r\n     */\r\n    get ID() {\r\n        return this._id;\r\n    }\r\n    /**\r\n     * 输出字符串\r\n     */\r\n    toString() {\r\n        return this._id;\r\n    }\r\n    /**\r\n     * 打印输出\r\n     */\r\n    print() {\r\n        Object.keys(this).forEach(property => {\r\n            console.log(property + \": \" + this[property]);\r\n        });\r\n    }\r\n    /**\r\n     * 生成ID\r\n     */\r\n    create() {\r\n        const timestamp = (new Date().getTime() / 1000 | 0).toString(16);\r\n        this._id = timestamp + 'xxxxxxxxxxxxxxxx'.replace(/[x]/g, function () {\r\n            return (Math.random() * 16 | 0).toString(16);\r\n        }).toLowerCase();\r\n    }\r\n    /**\r\n     * 浅复制\r\n     */\r\n    copy(entity) {\r\n        Object.keys(this).forEach(property => {\r\n            this[property] = entity[property];\r\n        });\r\n    }\r\n}\r\n","import { Bound } from \"../util/bound\";\r\nimport { SimplePointSymbol, SimpleTextSymbol } from \"../symbol/symbol\";\r\nimport { WebMercator } from \"../projection/web-mercator\";\r\n/**\r\n * 坐标类型\r\n * @enum {number}\r\n */\r\nexport var CoordinateType;\r\n(function (CoordinateType) {\r\n    //经纬度坐标\r\n    CoordinateType[CoordinateType[\"Latlng\"] = 1] = \"Latlng\";\r\n    //地理平面坐标\r\n    CoordinateType[CoordinateType[\"Projection\"] = 2] = \"Projection\";\r\n    //屏幕平面坐标\r\n    CoordinateType[CoordinateType[\"Screen\"] = 3] = \"Screen\";\r\n})(CoordinateType || (CoordinateType = {}));\r\n/**\r\n * 图形类型\r\n * @enum {number}\r\n */\r\nexport var GeometryType;\r\n(function (GeometryType) {\r\n    //点\r\n    GeometryType[GeometryType[\"Point\"] = 1] = \"Point\";\r\n    //线\r\n    GeometryType[GeometryType[\"Polyline\"] = 2] = \"Polyline\";\r\n    //面\r\n    GeometryType[GeometryType[\"Polygon\"] = 3] = \"Polygon\";\r\n})(GeometryType || (GeometryType = {}));\r\n/**\r\n * 图形基类\r\n */\r\nexport class Geometry {\r\n    /**\r\n     * 包络矩形\r\n     * @remarks\r\n     * 注意bound的坐标类型：一般为地理平面坐标，即投影后坐标\r\n     */\r\n    get bound() {\r\n        return this._bound;\r\n    }\r\n    /**\r\n     * 输出GeoJSON格式字符串\r\n     */\r\n    toGeoJSON() { }\r\n    /**\r\n     * 投影变换虚函数\r\n     * @param {Projection} projection - 坐标投影转换\r\n     */\r\n    project(projection) { }\r\n    ;\r\n    /**\r\n     * 图形绘制虚函数\r\n     * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n     * @param {Projection} projection - 坐标投影转换\r\n     * @param {Bound} extent - 当前可视范围\r\n     * @param {Symbol} symbol - 渲染符号\r\n     */\r\n    draw(ctx, projection = new WebMercator(), extent = projection.bound, symbol = new SimplePointSymbol()) { }\r\n    ;\r\n    //animate(elapsed, ctx: CanvasRenderingContext2D, projection: Projection = new WebMercator(), extent: Bound = projection.bound, animation: Animation) {};\r\n    /**\r\n     * 是否包含传入坐标\r\n     * @remarks 主要用于鼠标交互\r\n     * @param {number} screenX - 鼠标屏幕坐标X\r\n     * @param {number} screenX - 鼠标屏幕坐标Y\r\n     * @return {boolean} 是否落入\r\n     */\r\n    contain(screenX, screenY) { return false; }\r\n    /**\r\n     * 图形包络矩形与可见视图范围是否包含或相交\r\n     * @param {Projection} projection - 坐标投影转换\r\n     * @param {Bound} extent - 当前可视范围\r\n     * @return {boolean} 是否在可视范围内\r\n     */\r\n    intersect(projection = new WebMercator(), extent = projection.bound) {\r\n        if (!this._projected)\r\n            this.project(projection);\r\n        return extent.intersect(this._bound);\r\n    }\r\n    /**\r\n     * 标注绘制\r\n     * @remarks\r\n     * 标注文本支持多行，/r/n换行\r\n     * @param {string} text - 标注文本\r\n     * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n     * @param {Projection} projection - 坐标投影转换\r\n     * @param {SimpleTextSymbol} symbol - 标注符号\r\n     */\r\n    label(text, ctx, projection = new WebMercator(), symbol = new SimpleTextSymbol()) {\r\n        if (!text)\r\n            return;\r\n        if (!this._projected)\r\n            this.project(projection);\r\n        ctx.save();\r\n        ctx.strokeStyle = symbol.strokeStyle;\r\n        ctx.fillStyle = symbol.fillStyle;\r\n        ctx.lineWidth = symbol.lineWidth;\r\n        ctx.lineJoin = \"round\";\r\n        ctx.font = symbol.fontSize + \"px/1 \" + symbol.fontFamily + \" \" + symbol.fontWeight;\r\n        const center = this.getCenter(CoordinateType.Projection, projection);\r\n        const matrix = ctx.getTransform();\r\n        //keep pixel\r\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n        const array = text.split(\"/r/n\");\r\n        let widths = array.map(str => ctx.measureText(str).width + symbol.padding * 2);\r\n        let width = Math.max(...widths);\r\n        let height = symbol.fontSize * array.length + symbol.padding * 2 + symbol.padding * (array.length - 1);\r\n        const screenX = (matrix.a * center[0] + matrix.e);\r\n        const screenY = (matrix.d * center[1] + matrix.f);\r\n        let totalX, totalY;\r\n        switch (symbol.placement) {\r\n            case \"TOP\":\r\n                totalX = -width / 2;\r\n                totalY = -symbol.pointSymbolHeight / 2 - height;\r\n                break;\r\n            case \"BOTTOM\":\r\n                totalX = -width / 2;\r\n                totalY = symbol.pointSymbolHeight / 2;\r\n                break;\r\n            case \"RIGHT\":\r\n                totalX = symbol.pointSymbolWidth / 2;\r\n                totalY = -height / 2;\r\n                break;\r\n            case \"LEFT\":\r\n                totalX = -symbol.pointSymbolWidth / 2 - width;\r\n                totalY = -height / 2;\r\n                break;\r\n        }\r\n        ctx.strokeRect(screenX + totalX, screenY + totalY, width, height);\r\n        ctx.fillRect(screenX + totalX, screenY + totalY, width, height);\r\n        ctx.textBaseline = \"top\";\r\n        ctx.fillStyle = symbol.fontColor;\r\n        array.forEach((str, index) => {\r\n            ctx.fillText(str, screenX + totalX + symbol.padding + (width - widths[index]) / 2, screenY + totalY + symbol.padding + index * (symbol.fontSize + symbol.padding));\r\n        });\r\n        ctx.restore();\r\n    }\r\n    ;\r\n    /**\r\n     * 标注量算\r\n     * @remarks\r\n     * 标注文本支持多行，/r/n换行\r\n     * 目前用于寻找自动标注最合适的方位：top bottom left right\r\n     * @param {string} text - 标注文本\r\n     * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n     * @param {Projection} projection - 坐标投影转换\r\n     * @param {SimpleTextSymbol} symbol - 标注符号\r\n     */\r\n    measure(text, ctx, projection = new WebMercator(), symbol = new SimpleTextSymbol()) {\r\n        if (!text)\r\n            return;\r\n        ctx.save();\r\n        ctx.font = symbol.fontSize + \"px/1 \" + symbol.fontFamily + \" \" + symbol.fontWeight;\r\n        const center = this.getCenter(CoordinateType.Projection, projection);\r\n        const matrix = ctx.getTransform();\r\n        //keep pixel\r\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n        const array = text.split(\"/r/n\");\r\n        let widths = array.map(str => ctx.measureText(str).width + symbol.padding * 2);\r\n        let width = Math.max(...widths);\r\n        let height = symbol.fontSize * array.length + symbol.padding * 2 + symbol.padding * (array.length - 1);\r\n        const screenX = (matrix.a * center[0] + matrix.e);\r\n        const screenY = (matrix.d * center[1] + matrix.f);\r\n        ctx.restore();\r\n        let totalX, totalY;\r\n        switch (symbol.placement) {\r\n            case \"TOP\":\r\n                totalX = -width / 2;\r\n                totalY = -symbol.pointSymbolHeight / 2 - height;\r\n                break;\r\n            case \"BOTTOM\":\r\n                totalX = -width / 2;\r\n                totalY = symbol.pointSymbolHeight / 2;\r\n                break;\r\n            case \"RIGHT\":\r\n                totalX = symbol.pointSymbolWidth / 2;\r\n                totalY = -height / 2;\r\n                break;\r\n            case \"LEFT\":\r\n                totalX = -symbol.pointSymbolWidth / 2 - width;\r\n                totalY = -height / 2;\r\n                break;\r\n        }\r\n        return new Bound(screenX + totalX, screenY + totalY, screenX + totalX + width, screenY + totalY + height);\r\n    }\r\n    ;\r\n    /**\r\n     * 获取图形中心点虚函数\r\n     * @param {CoordinateType} type - 坐标类型\r\n     * @param {Projection} projection - 坐标投影转换\r\n     * @return {number[]} 中心点坐标\r\n     */\r\n    getCenter(type = CoordinateType.Latlng, projection = new WebMercator()) { }\r\n    ;\r\n    /**\r\n     * 获取图形包络矩形\r\n     * 针对新建图形，还未进行投影的情况\r\n     * @param {Projection} projection - 坐标投影转换\r\n     * @return {number[]} 包络矩形\r\n     */\r\n    getBound(projection = new WebMercator()) {\r\n        if (!this._projected)\r\n            this.project(projection);\r\n        return this._bound;\r\n    }\r\n    ;\r\n    /**\r\n     * 获取两个图形间距离\r\n     * @remarks\r\n     * 当前为两图形中心点间的直线距离\r\n     * 多用于聚合判断\r\n     * @param {Geometry} geometry - 另一图形\r\n     * @param {CoordinateType} type - 坐标类型\r\n     * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n     * @param {Projection} projection - 坐标投影转换\r\n     * @return {number} 距离\r\n     */\r\n    distance(geometry, type, ctx, projection = new WebMercator()) {\r\n        const center = this.getCenter(type == CoordinateType.Screen ? CoordinateType.Projection : type, projection);\r\n        const point = geometry.getCenter(type == CoordinateType.Screen ? CoordinateType.Projection : type, projection);\r\n        if (type == CoordinateType.Screen) {\r\n            const matrix = ctx.getTransform();\r\n            const screenX1 = (matrix.a * center[0] + matrix.e), screenY1 = (matrix.d * center[1] + matrix.f);\r\n            const screenX2 = (matrix.a * point[0] + matrix.e), screenY2 = (matrix.d * point[1] + matrix.f);\r\n            return Math.sqrt((screenX2 - screenX1) * (screenX2 - screenX1) + (screenY2 - screenY1) * (screenY2 - screenY1));\r\n        }\r\n        else {\r\n            return Math.sqrt((point[0] - center[0]) * (point[0] - center[0]) + (point[1] - center[1]) * (point[1] - center[1]));\r\n        }\r\n    }\r\n    simplify(points, tolerance = 2.0) {\r\n        let sqTolerance = tolerance * tolerance;\r\n        // stage 1: vertex reduction\r\n        points = this._reducePoints(points, sqTolerance);\r\n        // stage 2: Douglas-Peucker simplification\r\n        // points = this._simplifyDP(points, sqTolerance);\r\n        return points;\r\n    }\r\n    // reduce points that are too close to each other to a single point\r\n    // sqTolerance = tolerance * tolerance\r\n    _reducePoints(points, sqTolerance = 1.0) {\r\n        const reducedPoints = [points[0]];\r\n        let prev = 0;\r\n        for (let i = 1; i < points.length; i++) {\r\n            if ((points[i][0] - points[prev][0]) * (points[i][0] - points[prev][0]) + (points[i][1] - points[prev][1]) * (points[i][1] - points[prev][1]) > sqTolerance) {\r\n                reducedPoints.push(points[i]);\r\n                prev = i;\r\n            }\r\n        }\r\n        if (prev < points.length - 1) {\r\n            reducedPoints.push(points[points.length - 1]);\r\n        }\r\n        return reducedPoints;\r\n    }\r\n    // Douglas-Peucker simplification, see http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm\r\n    _simplifyDP(points, sqTolerance = 1.0) {\r\n        let len = points.length, ArrayConstructor = typeof Uint8Array !== undefined + '' ? Uint8Array : Array, markers = new ArrayConstructor(len);\r\n        markers[0] = markers[len - 1] = 1;\r\n        this._simplifyDPStep(points, markers, sqTolerance, 0, len - 1);\r\n        let i, newPoints = [];\r\n        for (i = 0; i < len; i++) {\r\n            if (markers[i]) {\r\n                newPoints.push(points[i]);\r\n            }\r\n        }\r\n        return newPoints;\r\n    }\r\n    _simplifyDPStep(points, markers, sqTolerance, first, last) {\r\n        let maxSqDist = 0, index, i, sqDist;\r\n        for (i = first + 1; i <= last - 1; i++) {\r\n            sqDist = this._sqClosestPointOnSegment(points[i], points[first], points[last]);\r\n            if (sqDist > maxSqDist) {\r\n                index = i;\r\n                maxSqDist = sqDist;\r\n            }\r\n        }\r\n        if (maxSqDist > sqTolerance) {\r\n            markers[index] = 1;\r\n            this._simplifyDPStep(points, markers, sqTolerance, first, index);\r\n            this._simplifyDPStep(points, markers, sqTolerance, index, last);\r\n        }\r\n    }\r\n    // return closest point on segment or distance to that point\r\n    _sqClosestPointOnSegment(p, p1, p2) {\r\n        let x = p1[0], y = p1[1], dx = p2[0] - x, dy = p2[1] - y, dot = dx * dx + dy * dy, t;\r\n        if (dot > 0) {\r\n            t = ((p[0] - x) * dx + (p[1] - y) * dy) / dot;\r\n            if (t > 1) {\r\n                x = p2[0];\r\n                y = p2[1];\r\n            }\r\n            else if (t > 0) {\r\n                x += dx * t;\r\n                y += dy * t;\r\n            }\r\n        }\r\n        dx = p[0] - x;\r\n        dy = p[1] - y;\r\n        return dx * dx + dy * dy;\r\n    }\r\n}\r\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nimport { CoordinateType, Geometry } from \"./geometry\";\r\nimport { Bound } from \"../util/bound\";\r\nimport { SimpleMarkerSymbol, SimplePointSymbol } from \"../symbol/symbol\";\r\nimport { WebMercator } from \"../projection/web-mercator\";\r\n/**\r\n * 多点\r\n * @remarks\r\n * 数据结构：such as [[1,1],[2,2]]\r\n */\r\nexport class MultiplePoint extends Geometry {\r\n    /**\r\n     * 创建多点\r\n     * @param {number[][]} lnglats - 坐标集合，二维数组\r\n     */\r\n    constructor(lnglats) {\r\n        super();\r\n        this._lnglats = lnglats;\r\n    }\r\n    ;\r\n    /**\r\n     * 输出GeoJSON格式字符串\r\n     */\r\n    toGeoJSON() {\r\n        return {\r\n            \"type\": \"MultiPoint\",\r\n            \"coordinates\": this._lnglats\r\n        };\r\n    }\r\n    /**\r\n     * 投影变换\r\n     * @param {Projection} projection - 坐标投影转换\r\n     */\r\n    project(projection) {\r\n        this._projection = projection;\r\n        this._coordinates = this._lnglats.map((point) => this._projection.project(point));\r\n        let xmin = Number.MAX_VALUE, ymin = Number.MAX_VALUE, xmax = -Number.MAX_VALUE, ymax = -Number.MAX_VALUE;\r\n        this._coordinates.forEach(point => {\r\n            xmin = Math.min(xmin, point[0]);\r\n            ymin = Math.min(ymin, point[1]);\r\n            xmax = Math.max(xmax, point[0]);\r\n            ymax = Math.max(ymax, point[1]);\r\n        });\r\n        this._bound = new Bound(xmin, ymin, xmax, ymax);\r\n        this._projected = true;\r\n    }\r\n    /**\r\n     * 绘制点\r\n     * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n     * @param {Projection} projection - 坐标投影转换\r\n     * @param {Bound} extent - 当前可视范围\r\n     * @param {Symbol} symbol - 渲染符号\r\n     */\r\n    draw(ctx, projection = new WebMercator(), extent = projection.bound, symbol = new SimplePointSymbol()) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!this._projected)\r\n                this.project(projection);\r\n            if (!extent.intersect(this._bound))\r\n                return;\r\n            const matrix = ctx.getTransform();\r\n            this._screen = [];\r\n            this._symbol = symbol;\r\n            this._coordinates.forEach((point) => {\r\n                const screenX = (matrix.a * point[0] + matrix.e), screenY = (matrix.d * point[1] + matrix.f);\r\n                this._screen.push([screenX, screenY]);\r\n                this._symbol.draw(ctx, screenX, screenY);\r\n            });\r\n        });\r\n    }\r\n    ;\r\n    /**\r\n     * 是否包含传入坐标\r\n     * @remarks\r\n     * 由于点是0维，主要根据渲染的符号大小来判断传入坐标是否落到点内\r\n     * @param {number} screenX - 鼠标屏幕坐标X\r\n     * @param {number} screenX - 鼠标屏幕坐标Y\r\n     * @return {boolean} 是否落入\r\n     */\r\n    contain(screenX, screenY) {\r\n        return this._screen.some((point) => {\r\n            if (this._symbol instanceof SimplePointSymbol) {\r\n                return Math.sqrt((point[0] - screenX) * (point[0] - screenX) + (point[1] - screenY) * (point[1] - screenY)) <= this._symbol.radius;\r\n            }\r\n            else if (this._symbol instanceof SimpleMarkerSymbol) {\r\n                return screenX >= (point[0] - this._symbol.offsetX) && screenX <= (point[0] - this._symbol.offsetX + this._symbol.width) && screenY >= (point[1] - this._symbol.offsetY) && screenY <= (point[1] - this._symbol.offsetY + this._symbol.height);\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * 获取中心点\r\n     * TODO: now return first point center\r\n     * @param {CoordinateType} type - 坐标类型\r\n     * @param {Projection} projection - 坐标投影转换\r\n     * @return {number[]} 中心点坐标\r\n     */\r\n    getCenter(type = CoordinateType.Latlng, projection = new WebMercator()) {\r\n        if (!this._projected)\r\n            this.project(projection);\r\n        if (type = CoordinateType.Latlng) {\r\n            return [this._lnglats[0][0], this._lnglats[0][1]];\r\n        }\r\n        else {\r\n            return [this._coordinates[0][0], this._coordinates[0][1]];\r\n        }\r\n    }\r\n}\r\n","import { CoordinateType, Geometry } from \"./geometry\";\r\nimport { Bound } from \"../util/bound\";\r\nimport { SimpleFillSymbol } from \"../symbol/symbol\";\r\nimport { WebMercator } from \"../projection/web-mercator\";\r\n/**\r\n * 多个面\r\n * @remarks\r\n * 数据结构：[polygon[ring[point[xy]]]]：such as [[[[1,1],[2,2],[1,2]]], [[[3,3],[3,4],[4,4]]]]\r\n */\r\nexport class MultiplePolygon extends Geometry {\r\n    /**\r\n     * 创建多个面\r\n     * @param {number[][][][]} lnglats - 坐标集合，四维数组\r\n     */\r\n    constructor(lnglats) {\r\n        super();\r\n        this._lnglats = lnglats;\r\n    }\r\n    ;\r\n    /**\r\n     * 输出GeoJSON格式字符串\r\n     */\r\n    toGeoJSON() {\r\n        return {\r\n            \"type\": \"MultiPolygon\",\r\n            \"coordinates\": this._lnglats\r\n        };\r\n    }\r\n    /**\r\n     * 投影变换\r\n     * @param {Projection} projection - 坐标投影转换\r\n     */\r\n    project(projection) {\r\n        this._projection = projection;\r\n        this._coordinates = this._lnglats.map((polygon) => polygon.map((ring) => ring.map((point) => this._projection.project(point))));\r\n        let xmin = Number.MAX_VALUE, ymin = Number.MAX_VALUE, xmax = -Number.MAX_VALUE, ymax = -Number.MAX_VALUE;\r\n        this._coordinates.forEach(polygon => {\r\n            polygon.forEach(ring => {\r\n                ring.forEach(point => {\r\n                    xmin = Math.min(xmin, point[0]);\r\n                    ymin = Math.min(ymin, point[1]);\r\n                    xmax = Math.max(xmax, point[0]);\r\n                    ymax = Math.max(ymax, point[1]);\r\n                });\r\n            });\r\n        });\r\n        this._bound = new Bound(xmin, ymin, xmax, ymax);\r\n        this._projected = true;\r\n    }\r\n    /**\r\n     * 绘制面\r\n     * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n     * @param {Projection} projection - 坐标投影转换\r\n     * @param {Bound} extent - 当前可视范围\r\n     * @param {Symbol} symbol - 渲染符号\r\n     */\r\n    draw(ctx, projection = new WebMercator(), extent = projection.bound, symbol = new SimpleFillSymbol()) {\r\n        if (!this._projected)\r\n            this.project(projection);\r\n        if (!extent.intersect(this._bound))\r\n            return;\r\n        const matrix = ctx.getTransform();\r\n        this._screen = this._coordinates.map(polygon => polygon.map(ring => {\r\n            const points = ring.map((point, index) => {\r\n                const screenX = (matrix.a * point[0] + matrix.e), screenY = (matrix.d * point[1] + matrix.f);\r\n                return [screenX, screenY];\r\n            });\r\n            return this.simplify(points);\r\n        }));\r\n        this._screen.forEach(polygon => {\r\n            symbol.draw(ctx, polygon);\r\n        });\r\n    }\r\n    /**\r\n     * 是否包含传入坐标\r\n     * @remarks\r\n     * 点是不是落在面内\r\n     * from https://github.com/substack/point-in-polygon\r\n     * ray-casting algorithm based on\r\n     * http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\r\n     * @param {number} screenX - 鼠标屏幕坐标X\r\n     * @param {number} screenX - 鼠标屏幕坐标Y\r\n     * @return {boolean} 是否落入\r\n     */\r\n    contain(screenX, screenY) {\r\n        //first ring contained && others no contained\r\n        const _pointInPolygon = (point, vs) => {\r\n            let x = point[0], y = point[1];\r\n            let inside = false;\r\n            for (let i = 0, j = vs.length - 1; i < vs.length; j = i++) {\r\n                let xi = vs[i][0], yi = vs[i][1];\r\n                let xj = vs[j][0], yj = vs[j][1];\r\n                let intersect = ((yi > y) != (yj > y))\r\n                    && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);\r\n                if (intersect)\r\n                    inside = !inside;\r\n            }\r\n            return inside;\r\n        };\r\n        //TODO: only test first polygon, ring is not supported\r\n        return this._screen.some(polygon => _pointInPolygon([screenX, screenY], polygon[0]));\r\n    }\r\n    /**\r\n     * 获取面的中心点\r\n     * @remarks\r\n     * from Leaflet\r\n     * TODO: now return first polygon center\r\n     * @param {CoordinateType} type - 坐标类型\r\n     * @param {Projection} projection - 坐标投影转换\r\n     * @return {number[]} 中心点坐标\r\n     */\r\n    getCenter(type = CoordinateType.Latlng, projection = new WebMercator()) {\r\n        if (!this._projected)\r\n            this.project(projection);\r\n        let i, j, p1, p2, f, area, x, y, center;\r\n        // get more points polygon\r\n        const counts = this._coordinates.map(polygon => {\r\n            let count = 0;\r\n            polygon.forEach(ring => {\r\n                count = count + ring.length;\r\n            });\r\n            return count;\r\n        });\r\n        let index = counts.indexOf(Math.max(...counts));\r\n        let points = this._coordinates[index][0], len = points.length;\r\n        if (!len) {\r\n            return null;\r\n        }\r\n        // polygon centroid algorithm; only uses the first ring if there are multiple\r\n        area = x = y = 0;\r\n        for (i = 0, j = len - 1; i < len; j = i++) {\r\n            p1 = points[i];\r\n            p2 = points[j];\r\n            f = p1[1] * p2[0] - p2[1] * p1[0];\r\n            x += (p1[0] + p2[0]) * f;\r\n            y += (p1[1] + p2[1]) * f;\r\n            area += f * 3;\r\n        }\r\n        if (area === 0) {\r\n            // Polygon is so small that all points are on same pixel.\r\n            center = points[0];\r\n        }\r\n        else {\r\n            center = [x / area, y / area];\r\n        }\r\n        if (type === CoordinateType.Latlng) {\r\n            return projection.unproject(center);\r\n        }\r\n        else {\r\n            return center;\r\n        }\r\n    }\r\n}\r\n","import { CoordinateType, Geometry } from \"./geometry\";\r\nimport { Bound } from \"../util/bound\";\r\nimport { SimpleLineSymbol } from \"../symbol/symbol\";\r\nimport { WebMercator } from \"../projection/web-mercator\";\r\nimport { Polyline } from \"./polyline\";\r\n/**\r\n * 多段线\r\n * @remarks\r\n * 数据结构：such as [[[1,1],[2,2]],[[3,3],[4,4]]]\r\n * [polyline[point[xy]]]\r\n */\r\nexport class MultiplePolyline extends Geometry {\r\n    /**\r\n     * 创建多段线\r\n     * @param {number[][][} lnglats - 坐标集合，三维数组\r\n     */\r\n    constructor(lnglats) {\r\n        super();\r\n        this._tolerance = 4; //TOLERANCE + symbol.lineWidth\r\n        this._lnglats = lnglats;\r\n    }\r\n    ;\r\n    /**\r\n     * 输出GeoJSON格式字符串\r\n     */\r\n    toGeoJSON() {\r\n        return {\r\n            \"type\": \"MultiPolyline\",\r\n            \"coordinates\": this._lnglats\r\n        };\r\n    }\r\n    /**\r\n     * 投影变换\r\n     * @param {Projection} projection - 坐标投影转换\r\n     */\r\n    project(projection) {\r\n        this._projection = projection;\r\n        this._coordinates = this._lnglats.map((polyline) => polyline.map((point) => this._projection.project(point)));\r\n        let xmin = Number.MAX_VALUE, ymin = Number.MAX_VALUE, xmax = -Number.MAX_VALUE, ymax = -Number.MAX_VALUE;\r\n        this._coordinates.forEach(polyline => {\r\n            polyline.forEach(point => {\r\n                xmin = Math.min(xmin, point[0]);\r\n                ymin = Math.min(ymin, point[1]);\r\n                xmax = Math.max(xmax, point[0]);\r\n                ymax = Math.max(ymax, point[1]);\r\n            });\r\n        });\r\n        this._bound = new Bound(xmin, ymin, xmax, ymax);\r\n        this._projected = true;\r\n    }\r\n    /**\r\n     * 绘制线\r\n     * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n     * @param {Projection} projection - 坐标投影转换\r\n     * @param {Bound} extent - 当前可视范围\r\n     * @param {Symbol} symbol - 渲染符号\r\n     */\r\n    draw(ctx, projection = new WebMercator(), extent = projection.bound, symbol = new SimpleLineSymbol()) {\r\n        if (!this._projected)\r\n            this.project(projection);\r\n        if (!extent.intersect(this._bound))\r\n            return;\r\n        this._tolerance = Polyline.TOLERANCE + symbol.lineWidth;\r\n        const matrix = ctx.getTransform();\r\n        this._screen = this._coordinates.map(polyline => {\r\n            const points = polyline.map((point, index) => {\r\n                const screenX = (matrix.a * point[0] + matrix.e), screenY = (matrix.d * point[1] + matrix.f);\r\n                return [screenX, screenY];\r\n            });\r\n            return this.simplify(points);\r\n        });\r\n        this._screen.forEach(polyline => {\r\n            symbol.draw(ctx, polyline);\r\n        });\r\n    }\r\n    /**\r\n     * 是否包含传入坐标\r\n     * @remarks\r\n     * 线是1维，所以要设置一个tolerance容差，来判断坐标是否落到线上\r\n     * @param {number} screenX - 鼠标屏幕坐标X\r\n     * @param {number} screenX - 鼠标屏幕坐标Y\r\n     * @return {boolean} 是否落入\r\n     */\r\n    contain(screenX, screenY) {\r\n        let p2;\r\n        const _distanceToSegment = (p, p1, p2) => {\r\n            let x = p1[0], y = p1[1], dx = p2[0] - x, dy = p2[1] - y, dot = dx * dx + dy * dy, t;\r\n            if (dot > 0) {\r\n                t = ((p[0] - x) * dx + (p[1] - y) * dy) / dot;\r\n                if (t > 1) {\r\n                    x = p2[0];\r\n                    y = p2[1];\r\n                }\r\n                else if (t > 0) {\r\n                    x += dx * t;\r\n                    y += dy * t;\r\n                }\r\n            }\r\n            dx = p[0] - x;\r\n            dy = p[1] - y;\r\n            return Math.sqrt(dx * dx + dy * dy);\r\n        };\r\n        return this._screen.some(polyline => {\r\n            const distance = polyline.reduce((acc, cur) => {\r\n                if (p2) {\r\n                    const p1 = p2;\r\n                    p2 = cur;\r\n                    return Math.min(acc, _distanceToSegment([screenX, screenY], p1, p2));\r\n                }\r\n                else {\r\n                    p2 = cur;\r\n                    return acc;\r\n                }\r\n            }, Number.MAX_VALUE);\r\n            return distance <= this._tolerance;\r\n        });\r\n    }\r\n    /**\r\n     * 获取线的中心点\r\n     * @remarks\r\n     * from Leaflet\r\n     * TODO: now return first polyline center\r\n     * @param {CoordinateType} type - 坐标类型\r\n     * @param {Projection} projection - 坐标投影转换\r\n     * @return {number[]} 中心点坐标\r\n     */\r\n    getCenter(type = CoordinateType.Latlng, projection = new WebMercator()) {\r\n        if (!this._projected)\r\n            this.project(projection);\r\n        let i, halfDist, segDist, dist, p1, p2, ratio, points = this._coordinates[0], len = points.length;\r\n        if (!len) {\r\n            return null;\r\n        }\r\n        // polyline centroid algorithm; only uses the first ring if there are multiple\r\n        for (i = 0, halfDist = 0; i < len - 1; i++) {\r\n            halfDist += Math.sqrt((points[i + 1][0] - points[i][0]) * (points[i + 1][0] - points[i][0]) + (points[i + 1][1] - points[i][1]) * (points[i + 1][1] - points[i][1])) / 2;\r\n        }\r\n        let center;\r\n        // The line is so small in the current view that all points are on the same pixel.\r\n        if (halfDist === 0) {\r\n            center = points[0];\r\n        }\r\n        for (i = 0, dist = 0; i < len - 1; i++) {\r\n            p1 = points[i];\r\n            p2 = points[i + 1];\r\n            segDist = Math.sqrt((p2[0] - p1[0]) * (p2[0] - p1[0]) + (p2[1] - p1[1]) * (p2[1] - p1[1]));\r\n            dist += segDist;\r\n            if (dist > halfDist) {\r\n                ratio = (dist - halfDist) / segDist;\r\n                center = [\r\n                    p2[0] - ratio * (p2[0] - p1[0]),\r\n                    p2[1] - ratio * (p2[1] - p1[1])\r\n                ];\r\n            }\r\n        }\r\n        if (type === CoordinateType.Latlng) {\r\n            return projection.unproject(center);\r\n        }\r\n        else {\r\n            return center;\r\n        }\r\n    }\r\n}\r\nMultiplePolyline.TOLERANCE = 4; //screen pixel\r\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nimport { CoordinateType, Geometry } from \"./geometry\";\r\nimport { Bound } from \"../util/bound\";\r\nimport { SimplePointSymbol } from \"../symbol/symbol\";\r\nimport { WebMercator } from \"../projection/web-mercator\";\r\n/**\r\n * 点\r\n */\r\nexport class Point extends Geometry {\r\n    /**\r\n     * 创建点\r\n     * @param {number} lng - 经度\r\n     * @param {number} lat - 纬度\r\n     */\r\n    constructor(lng, lat) {\r\n        super();\r\n        this._lng = lng;\r\n        this._lat = lat;\r\n    }\r\n    /**\r\n     * 经纬度-经度\r\n     */\r\n    get lng() {\r\n        return this._lng;\r\n    }\r\n    /**\r\n     * 经纬度-纬度\r\n     */\r\n    get lat() {\r\n        return this._lat;\r\n    }\r\n    /**\r\n     * 平面坐标-X\r\n     */\r\n    get x() {\r\n        return this._x;\r\n    }\r\n    /**\r\n     * 平面坐标-Y\r\n     */\r\n    get y() {\r\n        return this._y;\r\n    }\r\n    ;\r\n    /**\r\n     * 输出GeoJSON格式字符串\r\n     */\r\n    toGeoJSON() {\r\n        return {\r\n            \"type\": \"Point\",\r\n            \"coordinates\": [this._lng, this._lat]\r\n        };\r\n    }\r\n    /**\r\n     * 投影变换\r\n     * @param {Projection} projection - 坐标投影转换\r\n     */\r\n    project(projection) {\r\n        this._projection = projection;\r\n        [this._x, this._y] = this._projection.project([this._lng, this._lat]);\r\n        //TODO: bound tolerance\r\n        this._bound = new Bound(this._x, this._y, this._x, this._y);\r\n        this._projected = true;\r\n    }\r\n    /**\r\n     * 移动点（用于编辑）\r\n     * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n     * @param {Projection} projection - 坐标投影转换\r\n     * @param {number} screenX - 屏幕坐标X\r\n     * @param {number} screenY - 屏幕坐标Y\r\n     */\r\n    move(ctx, projection, screenX, screenY) {\r\n        const matrix = ctx.getTransform();\r\n        this._screenX = screenX;\r\n        this._screenY = screenY;\r\n        this._x = (this._screenX - matrix.e) / matrix.a;\r\n        this._y = (this._screenY - matrix.f) / matrix.d;\r\n        this._bound = new Bound(this._x, this._y, this._x, this._y);\r\n        this._projection = projection;\r\n        [this._lng, this._lat] = this._projection.unproject([this._x, this._y]);\r\n        this._projected = true;\r\n    }\r\n    /**\r\n     * 绘制点\r\n     * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n     * @param {Projection} projection - 坐标投影转换\r\n     * @param {Bound} extent - 当前可视范围\r\n     * @param {Symbol} symbol - 渲染符号\r\n     */\r\n    draw(ctx, projection = new WebMercator(), extent = projection.bound, symbol = new SimplePointSymbol()) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!this._projected)\r\n                this.project(projection);\r\n            //if (!extent.intersect(this._bound)) return;\r\n            const matrix = ctx.getTransform();\r\n            this._screenX = (matrix.a * this._x + matrix.e);\r\n            this._screenY = (matrix.d * this._y + matrix.f);\r\n            this._symbol = symbol;\r\n            this._symbol.draw(ctx, this._screenX, this._screenY);\r\n        });\r\n    }\r\n    ;\r\n    /*animate(elapsed, ctx: CanvasRenderingContext2D, projection: Projection = new WebMercator(), extent: Bound = projection.bound, animation: Animation) {\r\n        if (!this._projected) this.project(projection);\r\n        if (!extent.intersect(this._bound)) return;\r\n        const matrix = (ctx as any).getTransform();\r\n        this._screenX = (matrix.a * this._x + matrix.e);\r\n        this._screenY = (matrix.d * this._y + matrix.f);\r\n        animation.animate(elapsed, ctx, this._screenX, this._screenY);\r\n    };*/\r\n    /**\r\n     * 是否包含传入坐标\r\n     * @remarks\r\n     * 由于点是0维，主要根据渲染的符号大小来判断传入坐标是否落到点内\r\n     * @param {number} screenX - 鼠标屏幕坐标X\r\n     * @param {number} screenX - 鼠标屏幕坐标Y\r\n     * @return {boolean} 是否落入\r\n     */\r\n    contain(screenX, screenY) {\r\n        return this._symbol ? this._symbol.contain(this._screenX, this._screenY, screenX, screenY) : false;\r\n    }\r\n    /**\r\n     * 获取中心点\r\n     * @param {CoordinateType} type - 坐标类型\r\n     * @param {Projection} projection - 坐标投影转换\r\n     * @return {number[]} 中心点坐标\r\n     */\r\n    getCenter(type = CoordinateType.Latlng, projection = new WebMercator()) {\r\n        if (!this._projected)\r\n            this.project(projection);\r\n        if (type === CoordinateType.Latlng) {\r\n            return [this._lng, this._lat];\r\n        }\r\n        else {\r\n            return [this._x, this._y];\r\n        }\r\n    }\r\n}\r\n","import { CoordinateType, Geometry } from \"./geometry\";\r\nimport { Bound } from \"../util/bound\";\r\nimport { SimpleFillSymbol } from \"../symbol/symbol\";\r\nimport { WebMercator } from \"../projection/web-mercator\";\r\n/**\r\n * 面\r\n * @remarks\r\n * 数据结构：[ring[point[x,y]]]：such as [[[1,1],[2,2],[1,2]], [[1.5,1.5],[1.9,1.9],[1.5,1.9]]]\r\n */\r\nexport class Polygon extends Geometry {\r\n    /**\r\n     * 创建面\r\n     * @param {number[][][]} lnglats - 坐标集合，三维数组\r\n     */\r\n    constructor(lnglats) {\r\n        super();\r\n        this._lnglats = lnglats;\r\n    }\r\n    /**\r\n     * 经纬度\r\n     */\r\n    get lnglats() {\r\n        return this._lnglats;\r\n    }\r\n    /**\r\n     * 平面坐标\r\n     */\r\n    get coordinates() {\r\n        return this._coordinates;\r\n    }\r\n    ;\r\n    /**\r\n     * 输出GeoJSON格式字符串\r\n     */\r\n    toGeoJSON() {\r\n        return {\r\n            \"type\": \"Polygon\",\r\n            \"coordinates\": this._lnglats\r\n        };\r\n    }\r\n    /**\r\n     * 投影变换\r\n     * @param {Projection} projection - 坐标投影转换\r\n     */\r\n    project(projection) {\r\n        this._projection = projection;\r\n        this._coordinates = this._lnglats.map((ring) => ring.map((point) => this._projection.project(point)));\r\n        let xmin = Number.MAX_VALUE, ymin = Number.MAX_VALUE, xmax = -Number.MAX_VALUE, ymax = -Number.MAX_VALUE;\r\n        this._coordinates.forEach(ring => {\r\n            ring.forEach(point => {\r\n                xmin = Math.min(xmin, point[0]);\r\n                ymin = Math.min(ymin, point[1]);\r\n                xmax = Math.max(xmax, point[0]);\r\n                ymax = Math.max(ymax, point[1]);\r\n            });\r\n        });\r\n        this._bound = new Bound(xmin, ymin, xmax, ymax);\r\n        this._projected = true;\r\n    }\r\n    /**\r\n     * 编辑面\r\n     * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n     * @param {Projection} projection - 坐标投影转换\r\n     * @param {number[]} lnglat - 边线上点坐标（被替换或删除的拐点）\r\n     * @param {number} screenX - 替换的屏幕坐标X（拖动后）\r\n     * @param {number} screenY - 替换的屏幕坐标Y（拖动后）\r\n     * @param {boolean} replaced - true 替换 false 删除\r\n     */\r\n    splice(ctx, projection, lnglat, screenX = undefined, screenY = undefined, replaced = true) {\r\n        if (screenX == undefined && screenY == undefined) {\r\n            this._lnglats.forEach(ring => {\r\n                const index = ring.findIndex(point => point[0] == lnglat[0] && point[1] == lnglat[1]);\r\n                ring.length > 3 && index != -1 && ring.splice(index, 1);\r\n            });\r\n        }\r\n        else {\r\n            const matrix = ctx.getTransform();\r\n            const x = (screenX - matrix.e) / matrix.a;\r\n            const y = (screenY - matrix.f) / matrix.d;\r\n            this._projection = projection;\r\n            const [lng, lat] = this._projection.unproject([x, y]);\r\n            this._lnglats.forEach(ring => {\r\n                const index = ring.findIndex(point => point[0] == lnglat[0] && point[1] == lnglat[1]);\r\n                index != -1 && ring.splice(index, replaced ? 1 : 0, [lng, lat]);\r\n            });\r\n        }\r\n        this.project(projection);\r\n    }\r\n    /**\r\n     * 绘制面\r\n     * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n     * @param {Projection} projection - 坐标投影转换\r\n     * @param {Bound} extent - 当前可视范围\r\n     * @param {Symbol} symbol - 渲染符号\r\n     */\r\n    draw(ctx, projection = new WebMercator(), extent = projection.bound, symbol = new SimpleFillSymbol()) {\r\n        if (!this._projected)\r\n            this.project(projection);\r\n        if (!extent.intersect(this._bound))\r\n            return;\r\n        const matrix = ctx.getTransform();\r\n        this._screen = this._coordinates.map(ring => {\r\n            const points = ring.map((point, index) => {\r\n                const screenX = (matrix.a * point[0] + matrix.e), screenY = (matrix.d * point[1] + matrix.f);\r\n                return [screenX, screenY];\r\n            });\r\n            return this.simplify(points);\r\n        });\r\n        //减少一次循环的优化，效果并不显著，不如增加可读性，见上！\r\n        /*this._screen = this._coordinates.map( ring => {\r\n            const points = [];\r\n            const reducedPoints = [];\r\n            let prev = 0;\r\n            for (let i = 0; i < ring.length; i++) {\r\n                const screenX = (matrix.a * ring[i][0] + matrix.e), screenY = (matrix.d * ring[i][1] + matrix.f);\r\n                points.push([screenX, screenY]);\r\n                if (i == 0) {\r\n                    reducedPoints.push([screenX, screenY]);\r\n                }\r\n                if ((points[i][0]-points[prev][0]) * (points[i][0]-points[prev][0]) + (points[i][1]-points[prev][1]) * (points[i][1]-points[prev][1])> 1.0) {\r\n                    reducedPoints.push([screenX, screenY]);\r\n                    prev = i;\r\n                }\r\n            }\r\n            if (prev < points.length - 1) {\r\n                reducedPoints.push(points[points.length - 1]);\r\n            }\r\n            return reducedPoints;\r\n        });*/\r\n        symbol.draw(ctx, this._screen);\r\n    }\r\n    /**\r\n     * 是否包含传入坐标\r\n     * @remarks\r\n     * 点是不是落在面内\r\n     * from https://github.com/substack/point-in-polygon\r\n     * ray-casting algorithm based on\r\n     * http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\r\n     * @param {number} screenX - 鼠标屏幕坐标X\r\n     * @param {number} screenX - 鼠标屏幕坐标Y\r\n     * @return {boolean} 是否落入\r\n     */\r\n    contain(screenX, screenY) {\r\n        const first = this._screen[0];\r\n        const others = this._screen.slice(1);\r\n        //first ring contained && others no contained\r\n        const _pointInPolygon = (point, vs) => {\r\n            let x = point[0], y = point[1];\r\n            let inside = false;\r\n            for (let i = 0, j = vs.length - 1; i < vs.length; j = i++) {\r\n                let xi = vs[i][0], yi = vs[i][1];\r\n                let xj = vs[j][0], yj = vs[j][1];\r\n                let intersect = ((yi > y) != (yj > y))\r\n                    && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);\r\n                if (intersect)\r\n                    inside = !inside;\r\n            }\r\n            return inside;\r\n        };\r\n        return _pointInPolygon([screenX, screenY], first) && others.every(ring => !_pointInPolygon([screenX, screenY], ring));\r\n        //return this._screen.some(ring => this._pointInPolygon([screenX, screenY], ring));\r\n    }\r\n    /**\r\n     * 获取面的中心点\r\n     * @remarks\r\n     * from Leaflet\r\n     * @param {CoordinateType} type - 坐标类型\r\n     * @param {Projection} projection - 坐标投影转换\r\n     * @return {number[]} 中心点坐标\r\n     */\r\n    getCenter(type = CoordinateType.Latlng, projection = new WebMercator()) {\r\n        if (!this._projected)\r\n            this.project(projection);\r\n        let i, j, p1, p2, f, area, x, y, center, points = this._coordinates[0], len = points.length;\r\n        if (!len) {\r\n            return null;\r\n        }\r\n        // polygon centroid algorithm; only uses the first ring if there are multiple\r\n        area = x = y = 0;\r\n        for (i = 0, j = len - 1; i < len; j = i++) {\r\n            p1 = points[i];\r\n            p2 = points[j];\r\n            f = p1[1] * p2[0] - p2[1] * p1[0];\r\n            x += (p1[0] + p2[0]) * f;\r\n            y += (p1[1] + p2[1]) * f;\r\n            area += f * 3;\r\n        }\r\n        if (area === 0) {\r\n            // Polygon is so small that all points are on same pixel.\r\n            center = points[0];\r\n        }\r\n        else {\r\n            center = [x / area, y / area];\r\n        }\r\n        if (type === CoordinateType.Latlng) {\r\n            return projection.unproject(center);\r\n        }\r\n        else {\r\n            return center;\r\n        }\r\n    }\r\n    /**\r\n     * 获取面的周长\r\n     * @remarks\r\n     * from Leaflet\r\n     * @param {Projection} projection - 坐标投影转换\r\n     * @return {number} 周长\r\n     */\r\n    getLength(projection = new WebMercator()) {\r\n        if (!this._projected)\r\n            this.project(projection);\r\n        let sum = 0;\r\n        this._coordinates.forEach((ring, index) => {\r\n            if (index == 0) {\r\n                ring.forEach((point, index) => {\r\n                    if (index > 0) {\r\n                        sum += Math.sqrt(Math.pow(point[0] - ring[index - 1][0], 2) + Math.pow(point[1] - ring[index - 1][1], 2));\r\n                    }\r\n                });\r\n            }\r\n        });\r\n        return sum;\r\n    }\r\n    /**\r\n     * 获取面的面积\r\n     * @remarks\r\n     * from Leaflet\r\n     * @param {Projection} projection - 坐标投影转换\r\n     * @return {number} 面积\r\n     */\r\n    getArea(projection = new WebMercator()) {\r\n        if (!this._projected)\r\n            this.project(projection);\r\n        let sum = 0;\r\n        this._coordinates.forEach((ring, index) => {\r\n            if (index == 0) {\r\n                ring.forEach((point, index) => {\r\n                    if (index > 0) {\r\n                        //梯形面积\r\n                        sum += 1 / 2 * (point[0] - ring[index - 1][0]) * (point[1] + ring[index - 1][1]);\r\n                    }\r\n                });\r\n                sum += 1 / 2 * (ring[0][0] - ring[ring.length - 1][0]) * (ring[ring.length - 1][1] + ring[0][1]);\r\n            }\r\n        });\r\n        //顺时针为正，逆时针为负\r\n        return Math.abs(sum);\r\n    }\r\n}\r\n","import { CoordinateType, Geometry } from \"./geometry\";\r\nimport { Bound } from \"../util/bound\";\r\nimport { SimpleLineSymbol } from \"../symbol/symbol\";\r\nimport { WebMercator } from \"../projection/web-mercator\";\r\n/**\r\n * 线\r\n * @remarks\r\n * 数据结构：such as [[1,1],[2,2],[1,2]]\r\n */\r\nexport class Polyline extends Geometry {\r\n    /**\r\n     * 创建线\r\n     * @param {number[][]} lnglats - 坐标集合，二维数组\r\n     */\r\n    constructor(lnglats) {\r\n        super();\r\n        /**\r\n         * 交互鼠标坐标到线垂直距离的可选范围\r\n         * @remarks\r\n         * 可选范围 = 容差 + 线宽\r\n         * TOLERANCE + symbol.lineWidth\r\n         */\r\n        this._tolerance = 4;\r\n        this._lnglats = lnglats;\r\n    }\r\n    /**\r\n     * 经纬度\r\n     */\r\n    get lnglats() {\r\n        return this._lnglats;\r\n    }\r\n    /**\r\n     * 平面坐标\r\n     */\r\n    get coordinates() {\r\n        return this._coordinates;\r\n    }\r\n    ;\r\n    /**\r\n     * 输出GeoJSON格式字符串\r\n     */\r\n    toGeoJSON() {\r\n        return {\r\n            \"type\": \"LineString\",\r\n            \"coordinates\": this._lnglats\r\n        };\r\n    }\r\n    /**\r\n     * 投影变换\r\n     * @param {Projection} projection - 坐标投影转换\r\n     */\r\n    project(projection) {\r\n        this._projection = projection;\r\n        this._coordinates = this._lnglats.map((point) => this._projection.project(point));\r\n        let xmin = Number.MAX_VALUE, ymin = Number.MAX_VALUE, xmax = -Number.MAX_VALUE, ymax = -Number.MAX_VALUE;\r\n        this._coordinates.forEach(point => {\r\n            xmin = Math.min(xmin, point[0]);\r\n            ymin = Math.min(ymin, point[1]);\r\n            xmax = Math.max(xmax, point[0]);\r\n            ymax = Math.max(ymax, point[1]);\r\n        });\r\n        this._bound = new Bound(xmin, ymin, xmax, ymax);\r\n        this._projected = true;\r\n    }\r\n    /**\r\n     * 编辑线\r\n     * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n     * @param {Projection} projection - 坐标投影转换\r\n     * @param {number[]} lnglat - 线上点坐标（被替换或删除的拐点）\r\n     * @param {number} screenX - 替换的屏幕坐标X（拖动后）\r\n     * @param {number} screenY - 替换的屏幕坐标Y（拖动后）\r\n     * @param {boolean} replaced - true 替换 false 删除\r\n     */\r\n    splice(ctx, projection, lnglat, screenX = undefined, screenY = undefined, replaced = true) {\r\n        if (screenX == undefined && screenY == undefined) {\r\n            const index = this._lnglats.findIndex(point => point[0] == lnglat[0] && point[1] == lnglat[1]);\r\n            this._lnglats.length > 2 && index != -1 && this._lnglats.splice(index, 1);\r\n        }\r\n        else {\r\n            const matrix = ctx.getTransform();\r\n            const x = (screenX - matrix.e) / matrix.a;\r\n            const y = (screenY - matrix.f) / matrix.d;\r\n            this._projection = projection;\r\n            const [lng, lat] = this._projection.unproject([x, y]);\r\n            const index = this._lnglats.findIndex(point => point[0] == lnglat[0] && point[1] == lnglat[1]);\r\n            index != -1 && this._lnglats.splice(index, replaced ? 1 : 0, [lng, lat]);\r\n        }\r\n        this.project(projection);\r\n    }\r\n    /**\r\n     * 绘制线\r\n     * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n     * @param {Projection} projection - 坐标投影转换\r\n     * @param {Bound} extent - 当前可视范围\r\n     * @param {Symbol} symbol - 渲染符号\r\n     */\r\n    draw(ctx, projection = new WebMercator(), extent = projection.bound, symbol = new SimpleLineSymbol()) {\r\n        if (!this._projected)\r\n            this.project(projection);\r\n        if (!extent.intersect(this._bound))\r\n            return;\r\n        this._tolerance = Polyline.TOLERANCE + symbol.lineWidth;\r\n        const matrix = ctx.getTransform();\r\n        this._screen = this._coordinates.map((point, index) => {\r\n            const screenX = (matrix.a * point[0] + matrix.e), screenY = (matrix.d * point[1] + matrix.f);\r\n            return [screenX, screenY];\r\n        });\r\n        this._screen = this.simplify(this._screen);\r\n        symbol.draw(ctx, this._screen);\r\n    }\r\n    /*//已知 起点和终点  求沿线距起点定长的点\r\n    _getPointAlongLine(p1, p2, d) {\r\n        //line length\r\n        let l = Math.sqrt((p2[0] - p1[0]) * (p2[0] - p1[0]) + (p2[1] - p1[1]) * (p2[1] - p1[1]));\r\n        let t = d / l;\r\n        return [(1 - t) * p1[0] + t * p2[0], (1 - t) * p1[1] + t * p2[1]];\r\n    }\r\n\r\n    //已知 起点 y = kx + b   求沿线距起点定长的点 两个点\r\n    _getPointAlongLine2(k, b, p, d) {\r\n        let x0 = p[0] + Math.sqrt( (d * d) / (k * k + 1)), x1 = p[0] - Math.sqrt( (d * d) / (k * k + 1));\r\n        return [[x0, k * x0 + b], [x1, k * x1 + b]];\r\n    }*/\r\n    /**\r\n     * 是否包含传入坐标\r\n     * @remarks\r\n     * 线是1维，所以要设置一个tolerance容差，来判断坐标是否落到线上\r\n     * @param {number} screenX - 鼠标屏幕坐标X\r\n     * @param {number} screenX - 鼠标屏幕坐标Y\r\n     * @return {boolean} 是否落入\r\n     */\r\n    contain(screenX, screenY) {\r\n        let p2;\r\n        //from Leaflet\r\n        //点到线段的距离，垂直距离\r\n        const _distanceToSegment = (p, p1, p2) => {\r\n            let x = p1[0], y = p1[1], dx = p2[0] - x, dy = p2[1] - y, dot = dx * dx + dy * dy, t;\r\n            if (dot > 0) {\r\n                t = ((p[0] - x) * dx + (p[1] - y) * dy) / dot;\r\n                if (t > 1) {\r\n                    x = p2[0];\r\n                    y = p2[1];\r\n                }\r\n                else if (t > 0) {\r\n                    x += dx * t;\r\n                    y += dy * t;\r\n                }\r\n            }\r\n            dx = p[0] - x;\r\n            dy = p[1] - y;\r\n            return Math.sqrt(dx * dx + dy * dy);\r\n        };\r\n        const distance = this._screen.reduce((acc, cur) => {\r\n            if (p2) {\r\n                const p1 = p2;\r\n                p2 = cur;\r\n                return Math.min(acc, _distanceToSegment([screenX, screenY], p1, p2));\r\n            }\r\n            else {\r\n                p2 = cur;\r\n                return acc;\r\n            }\r\n        }, Number.MAX_VALUE);\r\n        return distance <= this._tolerance;\r\n    }\r\n    /**\r\n     * 获取线的中心点\r\n     * @remarks\r\n     * from Leaflet\r\n     * @param {CoordinateType} type - 坐标类型\r\n     * @param {Projection} projection - 坐标投影转换\r\n     * @return {number[]} 中心点坐标\r\n     */\r\n    getCenter(type = CoordinateType.Latlng, projection = new WebMercator()) {\r\n        if (!this._projected)\r\n            this.project(projection);\r\n        let i, halfDist, segDist, dist, p1, p2, ratio, points = this._coordinates, len = points.length;\r\n        if (!len) {\r\n            return null;\r\n        }\r\n        // polyline centroid algorithm; only uses the first ring if there are multiple\r\n        for (i = 0, halfDist = 0; i < len - 1; i++) {\r\n            halfDist += Math.sqrt((points[i + 1][0] - points[i][0]) * (points[i + 1][0] - points[i][0]) + (points[i + 1][1] - points[i][1]) * (points[i + 1][1] - points[i][1])) / 2;\r\n        }\r\n        let center;\r\n        // The line is so small in the current view that all points are on the same pixel.\r\n        if (halfDist === 0) {\r\n            center = points[0];\r\n        }\r\n        for (i = 0, dist = 0; i < len - 1; i++) {\r\n            p1 = points[i];\r\n            p2 = points[i + 1];\r\n            segDist = Math.sqrt((p2[0] - p1[0]) * (p2[0] - p1[0]) + (p2[1] - p1[1]) * (p2[1] - p1[1]));\r\n            dist += segDist;\r\n            if (dist > halfDist) {\r\n                ratio = (dist - halfDist) / segDist;\r\n                center = [\r\n                    p2[0] - ratio * (p2[0] - p1[0]),\r\n                    p2[1] - ratio * (p2[1] - p1[1])\r\n                ];\r\n            }\r\n        }\r\n        if (type === CoordinateType.Latlng) {\r\n            return projection.unproject(center);\r\n        }\r\n        else {\r\n            return center;\r\n        }\r\n    }\r\n    /**\r\n     * 获取线的长度\r\n     * @remarks\r\n     * from Leaflet\r\n     * @param {Projection} projection - 坐标投影转换\r\n     * @return {number} 长度\r\n     */\r\n    getLength(projection = new WebMercator()) {\r\n        if (!this._projected)\r\n            this.project(projection);\r\n        let sum = 0;\r\n        this._coordinates.forEach((point, index) => {\r\n            if (index > 0) {\r\n                sum += Math.sqrt(Math.pow(point[0] - this._coordinates[index - 1][0], 2) + Math.pow(point[1] - this._coordinates[index - 1][1], 2));\r\n            }\r\n        });\r\n        return sum;\r\n    }\r\n}\r\n/**\r\n * 容差\r\n * @remarks\r\n * 用于交互（线宽较小的情况下，难以选中）\r\n * screen pixel\r\n */\r\nPolyline.TOLERANCE = 4;\r\n","import { Subject } from \"./util/subject\";\r\nimport { Polyline } from \"./geometry/polyline\";\r\nimport { Feature } from \"./element/feature\";\r\nimport { Polygon } from \"./geometry/polygon\";\r\nimport { MultiplePolygon } from \"./geometry/multiple-polygon\";\r\nimport { MultiplePoint } from \"./geometry/multiple-point\";\r\nimport { Point } from \"./geometry/point\";\r\nimport { MultiplePolyline } from \"./geometry/multiple-polyline\";\r\nimport { SimpleFillSymbol, SimpleLineSymbol, SimplePointSymbol } from \"./symbol/symbol\";\r\n/**\r\n * 矢量切片管理器\r\n * 已内置于map，可通过map的接口进行添加删除的维护操作\r\n */\r\nexport class Grid extends Subject {\r\n    /**\r\n     * 创建Grid\r\n     * 不应自主创建，map内部创建\r\n     * @param {Map} map - 地图容器\r\n     */\r\n    constructor(map) {\r\n        super([\"mouseover\", \"mouseout\"]); //when mouseover feature\r\n        this._layers = [];\r\n        this._map = map;\r\n        const container = map.container;\r\n        this._canvas = document.createElement(\"canvas\");\r\n        this._canvas.style.cssText = \"position: absolute; height: 100%; width: 100%; z-index: 80\";\r\n        this._canvas.width = container.clientWidth;\r\n        this._canvas.height = container.clientHeight;\r\n        container.appendChild(this._canvas);\r\n        this._onResize = this._onResize.bind(this);\r\n        this._extentChange = this._extentChange.bind(this);\r\n        this._ctx = this._canvas.getContext(\"2d\");\r\n        this._map.on(\"resize\", this._onResize);\r\n        this._map.on(\"extent\", this._extentChange);\r\n        this._layers = [];\r\n    }\r\n    /**\r\n     * server url\r\n     */\r\n    get url() {\r\n        return this._url;\r\n    }\r\n    /**\r\n     * server url\r\n     */\r\n    set url(value) {\r\n        this._url = value;\r\n    }\r\n    //与主视图同步\r\n    _onResize(event) {\r\n        this._canvas.width = this._map.container.clientWidth;\r\n        this._canvas.height = this._map.container.clientHeight;\r\n    }\r\n    //与主视图同步\r\n    _extentChange(event) {\r\n        this._ctx.setTransform(event.matrix.a, 0, 0, event.matrix.d, event.matrix.e, event.matrix.f);\r\n        this.redraw();\r\n    }\r\n    //layer: green gis server layer\r\n    addLayer(layer) {\r\n        this._layers.push(layer);\r\n    }\r\n    removeLayer(layer) {\r\n        const index = this._layers.find(item => item._id == layer._id);\r\n        index && this._layers.splice(index, 1);\r\n    }\r\n    clearLayers() {\r\n        this._layers = [];\r\n    }\r\n    /**\r\n     * 重绘\r\n     */\r\n    redraw() {\r\n        if (!this._url)\r\n            return;\r\n        this._ctx.save();\r\n        this._ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n        this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);\r\n        this._ctx.restore();\r\n        const lngLat2Tile = (lng, lat, z) => {\r\n            let tileX = Math.floor((lng + 180) / 360 * Math.pow(2, z));\r\n            let tileY = Math.floor((1 / 2 - (Math.log(Math.tan(lat * Math.PI / 180) + 1 / Math.cos(lat * Math.PI / 180))) / (2 * Math.PI)) * Math.pow(2, z));\r\n            return [tileX, tileY];\r\n        };\r\n        const lngLat2Pixel = (lng, lat, z) => {\r\n            let pixelX = Math.floor(((lng + 180) / 360 * Math.pow(2, z) * 256) % 256);\r\n            let pixelY = Math.floor(((1 - (Math.log(Math.tan(lat * Math.PI / 180) + 1 / Math.cos(lat * Math.PI / 180))) / (2 * Math.PI)) * Math.pow(2, z) * 256) % 256);\r\n            return [pixelX, pixelY];\r\n        };\r\n        const getUrl = (url, id, x, y, z) => {\r\n            return url.replace(\"{id}\", id).replace(\"{x}\", x).replace(\"{y}\", y).replace(\"{z}\", z);\r\n        };\r\n        const projection = this._map.projection;\r\n        const extent = this._map.extent;\r\n        const zoom = this._map.zoom;\r\n        const [lng1, lat1] = projection.unproject([extent.xmin, extent.ymax]);\r\n        const [lng2, lat2] = projection.unproject([extent.xmax, extent.ymin]);\r\n        const [tileMinX, tileMinY] = lngLat2Tile(lng1, lat1, zoom);\r\n        const [tileMaxX, tileMaxY] = lngLat2Tile(lng2, lat2, zoom);\r\n        const me = this;\r\n        for (let x = tileMinX; x <= tileMaxX; x++) {\r\n            for (let y = tileMinY; y <= tileMaxY; y++) {\r\n                this._layers.forEach(layer => {\r\n                    const url = getUrl(this._url, layer._id, x, y, zoom);\r\n                    const req = new XMLHttpRequest();\r\n                    req.onload = (event) => {\r\n                        const array = JSON.parse(req.responseText);\r\n                        array.forEach(item => {\r\n                            let geometry, symbol;\r\n                            switch (item.geometry.type) {\r\n                                case \"Point\":\r\n                                    geometry = new Point(item.geometry.coordinates[0], item.geometry.coordinates[1]);\r\n                                    symbol = new SimplePointSymbol();\r\n                                    break;\r\n                                case \"LineString\":\r\n                                    geometry = new Polyline(item.geometry.coordinates);\r\n                                    symbol = new SimpleLineSymbol();\r\n                                    break;\r\n                                case \"Polygon\":\r\n                                    geometry = new Polygon(item.geometry.coordinates);\r\n                                    symbol = new SimpleFillSymbol();\r\n                                    break;\r\n                                case \"MultiPoint\":\r\n                                    geometry = new MultiplePoint(item.geometry.coordinates);\r\n                                    symbol = new SimplePointSymbol();\r\n                                    break;\r\n                                case \"MultiLineString\":\r\n                                    geometry = new MultiplePolyline(item.geometry.coordinates);\r\n                                    symbol = new SimpleLineSymbol();\r\n                                    break;\r\n                                case \"MultiPolygon\":\r\n                                    geometry = new MultiplePolygon(item.geometry.coordinates);\r\n                                    symbol = new SimpleFillSymbol();\r\n                                    break;\r\n                            }\r\n                            const feature = new Feature(geometry, item.properties);\r\n                            feature.draw(me._ctx, me._map.projection, me._map.extent, symbol);\r\n                        });\r\n                    };\r\n                    req.open(\"GET\", url, true);\r\n                    req.send(null);\r\n                });\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * 销毁\r\n     */\r\n    destroy() {\r\n        this._map.off(\"resize\", this._onResize);\r\n        this._map.off(\"extent\", this._extentChange);\r\n    }\r\n}\r\n","export * from './map';\r\nexport * from './viewer';\r\nexport * from './entity';\r\nexport * from './data/feature-class';\r\nexport * from './data/field';\r\nexport * from './editor/editor';\r\nexport * from './element/graphic';\r\nexport * from './element/feature';\r\nexport * from './geometry/geometry';\r\nexport * from './geometry/point';\r\nexport * from './geometry/polyline';\r\nexport * from './geometry/polygon';\r\nexport * from './geometry/multiple-point';\r\nexport * from './geometry/multiple-polyline';\r\nexport * from './geometry/multiple-polygon';\r\nexport * from './layer/layer';\r\nexport * from './layer/graphic-layer';\r\nexport * from './layer/feature-layer';\r\nexport * from './label/collision';\r\nexport * from './label/label';\r\nexport * from './tooltip/tooltip';\r\nexport * from './symbol/symbol';\r\nexport * from './renderer/renderer';\r\nexport * from './renderer/simple-renderer';\r\nexport * from './renderer/category-renderer';\r\nexport * from './renderer/class-renderer';\r\nexport * from './renderer/dot-renderer';\r\nexport * from './projection/projection';\r\nexport * from './projection/web-mercator';\r\nexport * from './projection/bd09';\r\nexport * from './projection/gcj02';\r\nexport * from './projection/noop-projection';\r\nexport * from './util/utility';\r\nexport * from './util/bound';\r\nexport * from './util/color';\r\nexport * from './util/subject';\r\nexport * from './animation/animation';\r\nexport * from './animation/particle-animation';\r\nexport * from './element/raster';\r\nexport * from './layer/raster-layer';\r\nexport * from './analysis/interpolation/kriging';\r\nexport * from './analysis/heat/heat';\r\nexport * from './analysis/interpolation/inverse-distance-weight';\r\nexport * from './tile';\r\nexport * from './measurer';\r\nexport * from './grid';\r\n","import { CoordinateType } from \"../geometry/geometry\";\r\nimport { WebMercator } from \"../projection/web-mercator\";\r\nimport { SimpleTextSymbol } from \"../symbol/symbol\";\r\n/**\r\n * 冲突检测基类\r\n */\r\nexport class Collision {\r\n    /**\r\n     * 冲突检测\r\n     * @param {Feature[]} features - 准备绘制标注的要素集合\r\n     * @param {Field} field - 标注字段\r\n     * @param {SimpleTextSymbol} symbol - 标注文本符号\r\n     * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n     * @param {Projection} projection - 坐标投影转换\r\n     * @return {Feature[]} 返回可绘制标注的要素集合\r\n     */\r\n    test(features, field, symbol, ctx, projection = new WebMercator()) { return []; }\r\n}\r\n/**\r\n * 无检测机制\r\n */\r\nexport class NullCollision {\r\n    /**\r\n     * 冲突检测\r\n     * @param {Feature[]} features - 准备绘制标注的要素集合\r\n     * @param {Field} field - 标注字段\r\n     * @param {SimpleTextSymbol} symbol - 标注文本符号\r\n     * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n     * @param {Projection} projection - 坐标投影转换\r\n     * @return {Feature[]} 返回可绘制标注的要素集合\r\n     */\r\n    test(features, field, symbol, ctx, projection = new WebMercator()) {\r\n        //没有任何检测逻辑，直接原样返回\r\n        return features;\r\n    }\r\n}\r\n/**\r\n * 简单碰撞冲突\r\n * @remarks\r\n * 类似聚合，距离判断，速度快\r\n */\r\nexport class SimpleCollision {\r\n    constructor() {\r\n        /**\r\n         * 检测距离\r\n         * @remarks\r\n         * 单位 pixel\r\n         */\r\n        this.distance = 50;\r\n    }\r\n    /**\r\n     * 冲突检测\r\n     * @param {Feature[]} features - 准备绘制标注的要素集合\r\n     * @param {Field} field - 标注字段\r\n     * @param {SimpleTextSymbol} symbol - 标注文本符号\r\n     * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n     * @param {Projection} projection - 坐标投影转换\r\n     * @return {Feature[]} 返回可绘制标注的要素集合\r\n     */\r\n    test(features, field, symbol, ctx, projection = new WebMercator()) {\r\n        //根据距离聚合\r\n        return features.reduce((acc, cur) => {\r\n            const item = acc.find((item) => {\r\n                const distance = cur.geometry.distance(item.geometry, CoordinateType.Screen, ctx, projection);\r\n                return distance <= this.distance;\r\n            });\r\n            if (!item)\r\n                acc.push(cur);\r\n            return acc;\r\n        }, []); // [feature]\r\n    }\r\n}\r\n/**\r\n * 叠盖碰撞冲突\r\n * @remarks\r\n * 试算标注宽高，并和已通过检测的标注，进行边界的交叉判断，速度慢\r\n */\r\nexport class CoverCollision {\r\n    constructor() {\r\n        /**\r\n         * 已通过检测的标注的边界集合\r\n         */\r\n        this._bounds = [];\r\n        /**\r\n         * 判断边界碰撞时的buffer\r\n         * @remarks\r\n         * buffer越小，标注越密，单位：pixel\r\n         */\r\n        this.buffer = 10;\r\n    }\r\n    /**\r\n     * 冲突检测\r\n     * @param {Feature[]} features - 准备绘制标注的要素集合\r\n     * @param {Field} field - 标注字段\r\n     * @param {SimpleTextSymbol} symbol - 标注文本符号\r\n     * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n     * @param {Projection} projection - 坐标投影转换\r\n     * @return {Feature[]} 返回可绘制标注的要素集合\r\n     */\r\n    test(features, field, symbol, ctx, projection = new WebMercator()) {\r\n        if (!field || !symbol)\r\n            return [];\r\n        this._bounds = [];\r\n        const measure = (feature, symbol) => {\r\n            const bound = feature.geometry.measure(feature.properties[field.name], ctx, projection, symbol);\r\n            bound.buffer(this.buffer);\r\n            if (bound) {\r\n                const item = this._bounds.find(item => item.intersect(bound));\r\n                if (!item) {\r\n                    return bound;\r\n                }\r\n            }\r\n            return null;\r\n        };\r\n        const replace = (feature, symbol, count) => {\r\n            const symbol2 = new SimpleTextSymbol();\r\n            symbol2.copy(symbol);\r\n            symbol2.replacement();\r\n            const bound = measure(feature, symbol2);\r\n            if (bound) {\r\n                return [bound, symbol2];\r\n            }\r\n            else {\r\n                if (count == 0) {\r\n                    return [null, null];\r\n                }\r\n                else {\r\n                    count -= 1;\r\n                    return replace(feature, symbol2, count);\r\n                }\r\n            }\r\n        };\r\n        //根据标注宽高的量算，得到标注的size，并和已通过检测的标注，进行边界的交叉判断，来决定是否可绘制该要素的标注\r\n        return features.reduce((acc, cur) => {\r\n            cur.text = null;\r\n            let bound = measure(cur, symbol);\r\n            if (bound) {\r\n                acc.push(cur);\r\n                this._bounds.push(bound);\r\n            }\r\n            else {\r\n                if (symbol.auto) {\r\n                    const [bound, symbol2] = replace(cur, symbol, 3); //一共4个方向，再测试剩余3个方向\r\n                    if (bound) {\r\n                        cur.text = symbol2;\r\n                        acc.push(cur);\r\n                        this._bounds.push(bound);\r\n                    }\r\n                }\r\n            }\r\n            return acc;\r\n        }, []); // [feature]\r\n    }\r\n}\r\n","import { SimpleTextSymbol } from \"../symbol/symbol\";\r\nimport { SimpleCollision } from \"./collision\";\r\nimport { WebMercator } from \"../projection/web-mercator\";\r\n/**\r\n * 图层标注设置\r\n */\r\nexport class Label {\r\n    constructor() {\r\n        /**\r\n         * 标注符号\r\n         * @remarks\r\n         * 参考Renderer和Feature中的相关重要说明\r\n         */\r\n        this.symbol = new SimpleTextSymbol();\r\n        /**\r\n         * 标注冲突解决方式\r\n         */\r\n        this.collision = new SimpleCollision();\r\n    }\r\n    /**\r\n     * 绘制图层标注\r\n     * @param {Feature[]} features - 准备绘制标注的要素集合\r\n     * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n     * @param {Projection} projection - 坐标投影转换\r\n     */\r\n    draw(features, ctx, projection = new WebMercator()) {\r\n        //通过冲突检测，得到要绘制的要素集合\r\n        const remain = this.collision.test(features, this.field, this.symbol, ctx, projection);\r\n        //遍历绘制要素标注\r\n        remain.forEach((feature) => {\r\n            feature.label(this.field, ctx, projection, this.symbol);\r\n        });\r\n    }\r\n}\r\n","import { Layer } from \"./layer\";\r\nimport { WebMercator } from \"../projection/web-mercator\";\r\nimport { GeometryType, CoordinateType } from \"../geometry/geometry\";\r\nimport { Point } from \"../geometry/point\";\r\nimport { ClusterSymbol } from \"../symbol/symbol\";\r\n//import RBush from \"rbush\";\r\n/**\r\n * 聚合类型\r\n * @enum {number}\r\n */\r\nexport var ClusterType;\r\n(function (ClusterType) {\r\n    //聚合\r\n    ClusterType[ClusterType[\"Default\"] = 0] = \"Default\";\r\n    //抽稀\r\n    ClusterType[ClusterType[\"Thinning\"] = 1] = \"Thinning\";\r\n})(ClusterType || (ClusterType = {}));\r\nexport class FeatureLayer extends Layer {\r\n    constructor() {\r\n        super(...arguments);\r\n        /**\r\n         * 图层可见缩放级别\r\n         */\r\n        this._zoom = [3, 20];\r\n        /**\r\n         * 是否显示标注\r\n         */\r\n        this.labeled = false;\r\n        /**\r\n         * 是否聚合\r\n         */\r\n        this.cluster = false;\r\n        /**\r\n         * 聚合类型\r\n         */\r\n        this.clusterType = ClusterType.Default;\r\n        /**\r\n         * 是否正在编辑\r\n         */\r\n        this.editing = false;\r\n    }\r\n    //private _tree: RBush<Feature> = new RBush(16);\r\n    //private _inited: boolean = false;\r\n    /**\r\n     * 矢量要素类（数据源）\r\n     */\r\n    get featureClass() {\r\n        return this._featureClass;\r\n    }\r\n    /**\r\n     * 矢量要素类（数据源）\r\n     */\r\n    set featureClass(value) {\r\n        this._featureClass = value;\r\n    }\r\n    /**\r\n     * 图层标注设置\r\n     */\r\n    get label() {\r\n        return this._label;\r\n    }\r\n    set label(value) {\r\n        this._label = value;\r\n    }\r\n    /**\r\n     * 图层渲染方式设置\r\n     */\r\n    get renderer() {\r\n        return this._renderer;\r\n    }\r\n    set renderer(value) {\r\n        this._renderer = value;\r\n    }\r\n    /**\r\n     * 图层可见缩放级别设置\r\n     */\r\n    get minZoom() {\r\n        return this._zoom[0];\r\n    }\r\n    get maxZoom() {\r\n        return this._zoom[1];\r\n    }\r\n    set minZoom(value) {\r\n        this._zoom[0] = value;\r\n    }\r\n    set maxZoom(value) {\r\n        this._zoom[1] = value;\r\n    }\r\n    set zoom(value) {\r\n        this._zoom = value;\r\n    }\r\n    /**\r\n     * 重写事件注册监听\r\n     * @remarks\r\n     * 对图层的监听，重写为遍历对该图层下所有要素的监听\r\n     * 该写法只是一种简写，无他。\r\n     * @param {string} event - 事件名称\r\n     * @param {Function} handler - 回调函数\r\n     */\r\n    on(event, handler) {\r\n        this._featureClass.features.forEach((feature) => {\r\n            feature.on(event, handler);\r\n        });\r\n    }\r\n    /**\r\n     * 重写事件取消监听\r\n     * @param {string} event - 事件名称\r\n     * @param {Function} handler - 回调函数\r\n     */\r\n    off(event, handler) {\r\n        this._featureClass.features.forEach((feature) => {\r\n            feature.off(event, handler);\r\n        });\r\n    }\r\n    /**\r\n     * 重写事件激发\r\n     * @param {string} event - 事件名称\r\n     * @param {Object} param - 事件参数\r\n     */\r\n    emit(event, param) {\r\n        this._featureClass.features.forEach((feature) => {\r\n            feature.emit(event, param);\r\n        });\r\n    }\r\n    /* initTree(projection: Projection = new WebMercator()) {\r\n        if (!this._inited) {\r\n            this._featureClass.features.forEach(feature => {\r\n                feature.geometry.project(projection);\r\n            });\r\n            this._tree.load(this._featureClass.features);\r\n            this._inited = true;\r\n        }\r\n    } */\r\n    /**\r\n     * 绘制图层\r\n     * @remarks\r\n     * 遍历图形集合进行绘制\r\n     * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n     * @param {Projection} projection - 坐标投影转换\r\n     * @param {Bound} extent - 当前可视范围\r\n     * @param {number} zoom - 当前缩放级别\r\n     */\r\n    draw(ctx, projection = new WebMercator(), extent = projection.bound, zoom = 10) {\r\n        console.time(\"draw\");\r\n        if (this.visible && this._zoom[0] <= zoom && this._zoom[1] >= zoom) {\r\n            //过滤可见视图范围内的要素\r\n            const features = this._featureClass.features.filter((feature) => feature.intersect(projection, extent));\r\n            /* this.initTree(projection);\r\n            const features = this._tree.search({\r\n                minX: extent.xmin,\r\n                minY: extent.ymin,\r\n                maxX: extent.xmax,\r\n                maxY: extent.ymax\r\n            } as any); */\r\n            //获取当前渲染方式下，某一要素对应的渲染符号\r\n            const _getSymbol = (feature) => {\r\n                /*if (this._renderer instanceof SimpleRenderer) {\r\n                    return (this._renderer as SimpleRenderer).symbol;\r\n                } else if (this._renderer instanceof CategoryRenderer) {\r\n                    const renderer: CategoryRenderer = this._renderer;\r\n                    const item = renderer.items.find( item => item.value == feature.properties[renderer.field.name]);\r\n                    if (item) return item.symbol;\r\n                } else if (this._renderer instanceof ClassRenderer) {\r\n                    const renderer: ClassRenderer = this._renderer;\r\n                    const item = renderer.items.find( item => item.low <= feature.properties[renderer.field.name] && item.high >= feature.properties[renderer.field.name]);\r\n                    if (item) return item.symbol;\r\n                } else if (this._renderer instanceof DotRenderer) {\r\n                    const renderer: DotRenderer = this._renderer;\r\n                    const symbol = new SimplePointSymbol();\r\n                    symbol.radius = Number(feature.properties[renderer.field.name] || 0);\r\n                    return symbol;\r\n                }*/\r\n                return this._renderer.getSymbol(feature);\r\n            };\r\n            //如果是点图层，同时又设置为聚合显示时\r\n            if (this._featureClass.type == GeometryType.Point && this.cluster) {\r\n                const cluster = features.reduce((acc, cur) => {\r\n                    if (cur.geometry instanceof Point) {\r\n                        const point = cur.geometry;\r\n                        const item = acc.find((item) => {\r\n                            const distance = point.distance(item.feature.geometry, CoordinateType.Screen, ctx, projection);\r\n                            return distance <= 50;\r\n                        });\r\n                        if (item) {\r\n                            item.count += 1;\r\n                        }\r\n                        else {\r\n                            acc.push({ feature: cur, count: 1 });\r\n                        }\r\n                        return acc;\r\n                    }\r\n                }, []); // [{feature, count}]\r\n                cluster.forEach((item) => {\r\n                    if (item.count == 1) {\r\n                        item.feature.draw(ctx, projection, extent, _getSymbol(item.feature));\r\n                    }\r\n                    else {\r\n                        item.feature.draw(ctx, projection, extent, this.clusterType == ClusterType.Thinning ? _getSymbol(item.feature) : new ClusterSymbol(item.count));\r\n                    }\r\n                });\r\n            }\r\n            else {\r\n                features.forEach((feature) => {\r\n                    feature.draw(ctx, projection, extent, _getSymbol(feature));\r\n                });\r\n            }\r\n        }\r\n        console.timeEnd(\"draw\");\r\n    }\r\n    /*animate(elapsed, ctx: CanvasRenderingContext2D, projection: Projection = new WebMercator(), extent: Bound = projection.bound, zoom: number = 10) {\r\n        if (this.visible && this._zoom[0] <= zoom && this._zoom[1] >= zoom) {\r\n            const features = this._featureClass.features.filter((feature: Feature) => feature.intersect(projection, extent));\r\n            features.forEach( (feature: Feature) => {\r\n                feature.animate(elapsed, ctx, projection, extent, new Animation());\r\n            });\r\n        }\r\n    }*/\r\n    /**\r\n     * 绘制标注\r\n     * @remarks\r\n     * 本应起名为label，但与属性中setter重名，故起名为drawLabel，无奈。。。\r\n     * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n     * @param {Projection} projection - 坐标投影转换\r\n     * @param {Bound} extent - 当前可视范围\r\n     * @param {number} zoom - 当前缩放级别\r\n     */\r\n    drawLabel(ctx, projection = new WebMercator(), extent = projection.bound, zoom = 10) {\r\n        console.time(\"label\");\r\n        if (this.visible && this._zoom[0] <= zoom && this._zoom[1] >= zoom) {\r\n            const features = this._featureClass.features.filter((feature) => feature.intersect(projection, extent));\r\n            this._label.draw(features, ctx, projection);\r\n            /*features.forEach( feature => {\r\n                feature.label(this._label.field, ctx, projection, extent, this._label.symbol);\r\n            });*/\r\n            /*const cluster = features.reduce( (acc, cur) => {\r\n                const item: any = acc.find((item: any) => {\r\n                    const distance = cur.geometry.distance(item.feature.geometry, CoordinateType.Screen, ctx, projection);\r\n                    return distance <= 50;\r\n                });\r\n                if (item) {\r\n                    item.count += 1;\r\n                } else {\r\n                    acc.push({feature: cur, count: 1});\r\n                }\r\n                return acc;\r\n            }, []); // [{feature, count}]\r\n            cluster.forEach( (item: any) => {\r\n                item.feature.label(this._label.field, ctx, projection, extent, this._label.symbol);\r\n            });*/\r\n        }\r\n        console.timeEnd(\"label\");\r\n    }\r\n    /**\r\n     * 图层交互\r\n     * @remarks 当前鼠标是否落入该图层某要素\r\n     * @param {number} screenX - 鼠标屏幕坐标X\r\n     * @param {number} screenX - 鼠标屏幕坐标Y\r\n     * @param {Projection} projection - 坐标投影转换\r\n     * @param {Bound} extent - 当前可视范围\r\n     * @param {number} zoom - 当前缩放级别\r\n     * @param {string} event - 当前事件名称\r\n     * @return {boolean} 是否落入\r\n     */\r\n    contain(screenX, screenY, projection = new WebMercator(), extent = projection.bound, zoom = 10, event = undefined) {\r\n        if (this.visible && this._zoom[0] <= zoom && this._zoom[1] >= zoom) {\r\n            //if call Array.some, maybe abort mouseout last feature which mouseover!!! but filter maybe cause slow!!!no choice\r\n            //return this._featureClass.features.filter((feature: Feature) => feature.intersect(projection, extent)).some( (feature: Feature) => {\r\n            const features = this._featureClass.features.filter((feature) => feature.intersect(projection, extent)).filter((feature) => {\r\n                return feature.contain(screenX, screenY, event);\r\n            });\r\n            if (features.length > 0) {\r\n                if (event == \"dblclick\") {\r\n                    features[0].emit(\"dblclick\", { feature: features[0], screenX: screenX, screenY: screenY });\r\n                }\r\n                else if (event == \"click\") {\r\n                    features[0].emit(\"click\", { feature: features[0], screenX: screenX, screenY: screenY });\r\n                }\r\n                return true;\r\n            }\r\n            else {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n}\r\n","import { Layer } from \"./layer\";\r\nimport { WebMercator } from \"../projection/web-mercator\";\r\n/**\r\n * 图形要素图层\r\n */\r\nexport class GraphicLayer extends Layer {\r\n    constructor() {\r\n        super(...arguments);\r\n        /**\r\n         * 图形要素集合\r\n         */\r\n        this._graphics = [];\r\n    }\r\n    get graphics() {\r\n        return this._graphics;\r\n    }\r\n    /**\r\n     * 重写事件注册监听\r\n     * @remarks\r\n     * 对图层的监听，重写为遍历对该图层下所有要素的监听\r\n     * 该写法只是一种简写，无他。\r\n     * @param {string} event - 事件名称\r\n     * @param {Function} handler - 回调函数\r\n     */\r\n    on(event, handler) {\r\n        this._graphics.forEach((graphic) => {\r\n            graphic.on(event, handler);\r\n        });\r\n    }\r\n    /**\r\n     * 重写事件取消监听\r\n     * @param {string} event - 事件名称\r\n     * @param {Function} handler - 回调函数\r\n     */\r\n    off(event, handler) {\r\n        this._graphics.forEach((graphic) => {\r\n            graphic.off(event, handler);\r\n        });\r\n    }\r\n    /**\r\n     * 重写事件激发\r\n     * @param {string} event - 事件名称\r\n     * @param {Object} param - 事件参数\r\n     */\r\n    emit(event, param) {\r\n        this._graphics.forEach((graphic) => {\r\n            graphic.emit(event, param);\r\n        });\r\n    }\r\n    /**\r\n     * 添加图形\r\n     * @param {Graphic} graphic - 图形\r\n     */\r\n    add(graphic) {\r\n        this._graphics.push(graphic);\r\n    }\r\n    /**\r\n     * 删除图形\r\n     * @param {Graphic} graphic - 图形\r\n     */\r\n    remove(graphic) {\r\n        const index = this._graphics.findIndex(item => item === graphic);\r\n        index != -1 && this._graphics.splice(index, 1);\r\n    }\r\n    /**\r\n     * 清空图形集合\r\n     */\r\n    clear() {\r\n        this._graphics = [];\r\n    }\r\n    /**\r\n     * 绘制图层\r\n     * @remarks\r\n     * 遍历图形集合进行绘制\r\n     * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n     * @param {Projection} projection - 坐标投影转换\r\n     * @param {Bound} extent - 当前可视范围\r\n     * @param {number} zoom - 当前缩放级别\r\n     */\r\n    draw(ctx, projection = new WebMercator(), extent = projection.bound, zoom = 10) {\r\n        if (this.visible) {\r\n            this._graphics.forEach((graphic) => {\r\n                graphic.draw(ctx, projection, extent);\r\n            });\r\n        }\r\n    }\r\n    /*animate(elapsed, ctx: CanvasRenderingContext2D, projection: Projection = new WebMercator(), extent: Bound = projection.bound, zoom: number = 10) {\r\n        if (this.visible) {\r\n            this._graphics.forEach( (graphic: Graphic) => {\r\n                graphic.animate(elapsed, ctx, projection, extent);\r\n            });\r\n        }\r\n    }*/\r\n    /**\r\n     * 图层交互\r\n     * @remarks 当前鼠标是否落入该图层某要素\r\n     * @param {number} screenX - 鼠标屏幕坐标X\r\n     * @param {number} screenX - 鼠标屏幕坐标Y\r\n     * @param {Projection} projection - 坐标投影转换\r\n     * @param {Bound} extent - 当前可视范围\r\n     * @param {number} zoom - 当前缩放级别\r\n     * @param {string} event - 当前事件名称\r\n     * @return {boolean} 是否落入\r\n     */\r\n    contain(screenX, screenY, projection = new WebMercator(), extent = projection.bound, zoom = 10, event = undefined) {\r\n        if (this.visible) {\r\n            const graphics = this._graphics.filter((graphic) => graphic.intersect(projection, extent)).filter((graphic) => {\r\n                return graphic.contain(screenX, screenY, event);\r\n            });\r\n            if (graphics.length > 0) {\r\n                if (event == \"dblclick\") {\r\n                    graphics[0].emit(\"dblclick\", { graphic: graphics[0], screenX: screenX, screenY: screenY });\r\n                }\r\n                else if (event == \"click\") {\r\n                    graphics[0].emit(\"click\", { graphic: graphics[0], screenX: screenX, screenY: screenY });\r\n                }\r\n                else if (event == \"dragstart\") {\r\n                    graphics[0].emit(\"dragstart\", { graphic: graphics[0], screenX: screenX, screenY: screenY });\r\n                }\r\n                return true;\r\n            }\r\n            else {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n}\r\n","import { WebMercator } from \"../projection/web-mercator\";\r\nimport { Subject } from \"../util/subject\";\r\n/**\r\n * 图层基类\r\n */\r\nexport class Layer extends Subject {\r\n    /**\r\n     * 创建图层\r\n     */\r\n    constructor() {\r\n        super([]);\r\n        /**\r\n         * 图层可见设置\r\n         */\r\n        this._visible = true;\r\n        /**\r\n         * 图层可交互设置\r\n         */\r\n        this._interactive = true;\r\n        /**\r\n         * 图层顺序（z-index）\r\n         * @remarks\r\n         * TODO: marker的异步加载，会影响绘制顺序\r\n         */\r\n        this._index = 0; //z-index\r\n    }\r\n    /**\r\n     * 图层是否可见\r\n     */\r\n    get visible() {\r\n        return this._visible;\r\n    }\r\n    /**\r\n     * 图层可见设置\r\n     */\r\n    set visible(value) {\r\n        this._visible = value;\r\n    }\r\n    /**\r\n     * 图层是否可交互\r\n     */\r\n    get interactive() {\r\n        return this._interactive;\r\n    }\r\n    /**\r\n     * 图层可交互设置\r\n     */\r\n    set interactive(value) {\r\n        this._interactive = value;\r\n    }\r\n    /**\r\n     * 图层顺序\r\n     */\r\n    get index() {\r\n        return this._index;\r\n    }\r\n    /**\r\n     * 图层顺序设置\r\n     */\r\n    set index(value) {\r\n        this._index = value;\r\n    }\r\n    /**\r\n     * 绘制图层\r\n     * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n     * @param {Projection} projection - 坐标投影转换\r\n     * @param {Bound} extent - 当前可视范围\r\n     * @param {number} zoom - 当前缩放级别\r\n     */\r\n    draw(ctx, projection = new WebMercator(), extent = projection.bound, zoom = 10) { }\r\n    ;\r\n    //animate(elapsed, ctx: CanvasRenderingContext2D, projection: Projection = new WebMercator(), extent: Bound = projection.bound, zoom: number = 10) {};\r\n    /**\r\n     * 图层交互\r\n     * @remarks 当前鼠标是否落入该图层某要素\r\n     * @param {number} screenX - 鼠标屏幕坐标X\r\n     * @param {number} screenX - 鼠标屏幕坐标Y\r\n     * @param {Projection} projection - 坐标投影转换\r\n     * @param {Bound} extent - 当前可视范围\r\n     * @param {number} zoom - 当前缩放级别\r\n     * @param {string} event - 当前事件名称\r\n     * @return {boolean} 是否落入\r\n     */\r\n    contain(screenX, screenY, projection = new WebMercator(), extent = projection.bound, zoom = 10, event = undefined) { return false; }\r\n}\r\n","import { WebMercator } from \"../projection/web-mercator\";\r\nimport { Layer } from \"./layer\";\r\n/**\r\n * 栅格图层\r\n */\r\nexport class RasterLayer extends Layer {\r\n    constructor() {\r\n        super(...arguments);\r\n        /**\r\n         * 图层可交互设置\r\n         */\r\n        this._interactive = false;\r\n    }\r\n    /**\r\n     * 绘制图层\r\n     * @remarks\r\n     * 遍历图形集合进行绘制\r\n     * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n     * @param {Projection} projection - 坐标投影转换\r\n     * @param {Bound} extent - 当前可视范围\r\n     * @param {number} zoom - 当前缩放级别\r\n     */\r\n    draw(ctx, projection = new WebMercator(), extent = projection.bound, zoom = 10) {\r\n        if (this.visible) {\r\n            this.raster && this.raster.draw(ctx, projection, extent, zoom);\r\n        }\r\n    }\r\n}\r\n","import { CoordinateType } from \"./geometry/geometry\";\r\nimport { Bound } from \"./util/bound\";\r\nimport { WebMercator } from \"./projection/web-mercator\";\r\nimport { GraphicLayer } from \"./layer/graphic-layer\";\r\nimport { Graphic } from \"./element/graphic\";\r\nimport { Utility } from \"./util/utility\";\r\nimport { Editor } from \"./editor/editor\";\r\nimport { Viewer } from \"./viewer\";\r\nimport { Subject } from \"./util/subject\";\r\nimport { Tooltip } from \"./tooltip/tooltip\";\r\nimport { Animator } from \"./animator\";\r\nimport { Point } from \"./geometry/point\";\r\nimport { MultiplePoint } from \"./geometry/multiple-point\";\r\nimport { Polyline } from \"./geometry/polyline\";\r\nimport { MultiplePolyline } from \"./geometry/multiple-polyline\";\r\nimport { SimpleFillSymbol, SimpleLineSymbol, SimplePointSymbol } from \"./symbol/symbol\";\r\nimport { MultiplePolygon } from \"./geometry/multiple-polygon\";\r\nimport { Polygon } from \"./geometry/polygon\";\r\nimport { Tile } from \"./tile\";\r\nimport { Grid } from \"./grid\";\r\nimport { Measurer } from \"./measurer\";\r\n/**\r\n * 地图\r\n * 容器: 1 viewer 1 editor 1 animator 1 tooltip\r\n */\r\nexport class Map extends Subject {\r\n    /**\r\n     * 创建地图\r\n     * @param {string | HTMLDivElement} id - HTMLDivElement | id\r\n     * @param {Object} option - 选项配置\r\n     */\r\n    constructor(id, option) {\r\n        //extent: 视图范围更新时\r\n        //click:  单击地图时\r\n        //dblclick: 双击地图时\r\n        //mousemove: 鼠标移动时\r\n        //resize: 视图容器尺寸调整时\r\n        super([\"extent\", \"click\", \"dblclick\", \"mousemove\", \"resize\"]);\r\n        this._option = {\r\n            disableDoubleClick: false,\r\n            disableInteractive: false\r\n        };\r\n        this._drag = {\r\n            flag: false,\r\n            start: {\r\n                x: 0,\r\n                y: 0\r\n            },\r\n            end: {\r\n                x: 0,\r\n                y: 0\r\n            }\r\n        };\r\n        this._touch = {\r\n            zooming: false,\r\n            dragging: false,\r\n            finger_dist: 0\r\n        };\r\n        //地图缩放等级\r\n        this._zoom = 1;\r\n        this.minZoom = 3;\r\n        this.maxZoom = 20;\r\n        //地图视图中心\r\n        this._center = [0, 0];\r\n        //默认图形图层\r\n        this._defaultGraphicLayer = new GraphicLayer();\r\n        //选择图层\r\n        this._selectionLayer = new GraphicLayer();\r\n        //option\r\n        this._option.disableDoubleClick = option && option.hasOwnProperty('disableDoubleClick') ? option.disableDoubleClick : false;\r\n        this._option.disableInteractive = option && option.hasOwnProperty('disableInteractive') ? option.disableInteractive : false;\r\n        this.minZoom = option && option.hasOwnProperty('minZoom') ? option.minZoom : 3;\r\n        this.maxZoom = option && option.hasOwnProperty('minZoom') ? option.minZoom : 20;\r\n        this._container = id instanceof HTMLDivElement ? id : document.getElementById(id);\r\n        //create canvas\r\n        this._canvas = document.createElement(\"canvas\");\r\n        this._canvas.style.cssText = \"position: absolute; height: 100%; width: 100%; z-index: 100\";\r\n        this._canvas.width = this._container.clientWidth;\r\n        this._canvas.height = this._container.clientHeight;\r\n        this._container.appendChild(this._canvas);\r\n        this._onClick = this._onClick.bind(this);\r\n        this._onDoubleClick = this._onDoubleClick.bind(this);\r\n        this._onMouseDown = this._onMouseDown.bind(this);\r\n        this._onMouseMove = this._onMouseMove.bind(this);\r\n        this._onMouseUp = this._onMouseUp.bind(this);\r\n        this._onWheel = this._onWheel.bind(this);\r\n        this._onTouchStart = this._onTouchStart.bind(this);\r\n        this._onTouchMove = this._onTouchMove.bind(this);\r\n        this._onTouchEnd = this._onTouchEnd.bind(this);\r\n        this._ctx = this._canvas.getContext(\"2d\");\r\n        this._canvas.addEventListener(\"click\", this._onClick);\r\n        if (!this._option.disableInteractive) {\r\n            this._canvas.addEventListener(\"dblclick\", this._onDoubleClick);\r\n            this._canvas.addEventListener(\"mousedown\", this._onMouseDown);\r\n            this._canvas.addEventListener(\"mousemove\", this._onMouseMove, false);\r\n            this._canvas.addEventListener(\"mouseup\", this._onMouseUp);\r\n            this._canvas.addEventListener(\"wheel\", this._onWheel);\r\n            this._canvas.addEventListener(\"touchstart\", this._onTouchStart, false);\r\n            this._canvas.addEventListener(\"touchmove\", this._onTouchMove, false);\r\n            this._canvas.addEventListener(\"touchend\", this._onTouchEnd, false);\r\n        }\r\n        //viewer\r\n        this._viewer = new Viewer(this);\r\n        this._viewer.on(\"mouseover\", () => { Utility.addClass(this._canvas, \"green-hover\"); });\r\n        this._viewer.on(\"mouseout\", () => { Utility.removeClass(this._canvas, \"green-hover\"); });\r\n        //editor\r\n        this._editor = new Editor(this);\r\n        this._editor.on(\"mouseover\", () => { Utility.addClass(this._canvas, \"green-hover\"); });\r\n        this._editor.on(\"mouseout\", () => { Utility.removeClass(this._canvas, \"green-hover\"); });\r\n        this._editor.on(\"startedit\", () => { this._viewer.redraw(); });\r\n        this._editor.on(\"stopedit\", () => { this._viewer.redraw(); });\r\n        //measurer\r\n        this._measurer = new Measurer(this);\r\n        //animator\r\n        this._animator = new Animator(this);\r\n        //tile\r\n        this._tile = new Tile(this);\r\n        //grid\r\n        this._grid = new Grid(this);\r\n        //tooltip\r\n        this._tooltip = new Tooltip(this);\r\n        this._projection = new WebMercator();\r\n        //this._center = [0, 0];\r\n        //this._zoom = 10;\r\n        //Latlng [-180, 180] [-90, 90]\r\n        //this._ctx.setTransform(256/180 * Math.pow(2, this._zoom - 1), 0, 0, -256/90 * Math.pow(2, this._zoom - 1), this._canvas.width/2, this._canvas.height/2);\r\n        //const bound: Bound = this._projection.bound;\r\n        //设置初始矩阵，由于地图切片是256*256，Math.pow(2, this._zoom)代表在一定缩放级别下x与y轴的切片数量\r\n        //this._ctx.setTransform(256 * Math.pow(2, this._zoom) / (bound.xmax - bound.xmin) * bound.xscale , 0, 0, 256 * Math.pow(2, this._zoom) / (bound.ymax - bound.ymin) * bound.yscale, this._canvas.width / 2, this._canvas.height / 2);\r\n        this.setView([0, 0], 10);\r\n        this._onResize = this._onResize.bind(this);\r\n        window.addEventListener(\"resize\", this._onResize);\r\n        //selection\r\n        this._selectionPointSymbol = new SimplePointSymbol();\r\n        this._selectionPointSymbol.strokeStyle = \"#00ffff\";\r\n        this._selectionPointSymbol.fillStyle = \"#00ffff88\";\r\n        this._selectionLineSymbol = new SimpleLineSymbol();\r\n        this._selectionLineSymbol.lineWidth = 3;\r\n        this._selectionLineSymbol.strokeStyle = \"#00ffff\";\r\n        this._selectionPolygonSymbol = new SimpleFillSymbol();\r\n        this._selectionPolygonSymbol.lineWidth = 3;\r\n        this._selectionPolygonSymbol.strokeStyle = \"#00ffff\";\r\n        this._selectionPolygonSymbol.fillStyle = \"#00ffff33\";\r\n    }\r\n    /**\r\n     * DIV容器\r\n     */\r\n    get container() {\r\n        return this._container;\r\n    }\r\n    /**\r\n     * Viewer\r\n     */\r\n    get viewer() {\r\n        return this._viewer;\r\n    }\r\n    /**\r\n     * Tooltip\r\n     */\r\n    get tooltip() {\r\n        return this._tooltip;\r\n    }\r\n    /**\r\n     * Editor\r\n     */\r\n    get editor() {\r\n        return this._editor;\r\n    }\r\n    set editor(value) {\r\n        this._editor = value;\r\n    }\r\n    get grid() {\r\n        return this._grid;\r\n    }\r\n    get tile() {\r\n        return this._tile;\r\n    }\r\n    /**\r\n     * Measurer\r\n     */\r\n    get measurer() {\r\n        return this._measurer;\r\n    }\r\n    /**\r\n     * 视图中心\r\n     */\r\n    get center() {\r\n        return this._center;\r\n    }\r\n    /**\r\n     * 可视范围\r\n     */\r\n    get extent() {\r\n        return this._extent;\r\n    }\r\n    /**\r\n     * 缩放级别\r\n     */\r\n    get zoom() {\r\n        return this._zoom;\r\n    }\r\n    /**\r\n     * 坐标投影变换\r\n     */\r\n    get projection() {\r\n        return this._projection;\r\n    }\r\n    /**\r\n     * 点选中符号\r\n     */\r\n    get selectionPointSymbol() {\r\n        return this._selectionPointSymbol;\r\n    }\r\n    /**\r\n     * 线选中符号\r\n     */\r\n    get selectionLineSymbol() {\r\n        return this._selectionLineSymbol;\r\n    }\r\n    /**\r\n     * 面选中符号\r\n     */\r\n    get selectionPolygonSymbol() {\r\n        return this._selectionPolygonSymbol;\r\n    }\r\n    /**\r\n     * 禁用双击交互\r\n     */\r\n    disableDoubleClick() {\r\n        this._option.disableDoubleClick = true;\r\n    }\r\n    /**\r\n     * 启用双击交互\r\n     */\r\n    enableDoubleClick() {\r\n        this._option.disableDoubleClick = false;\r\n    }\r\n    /**\r\n     * 设置坐标投影变换\r\n     * @param {Projection} projection - 坐标投影变换\r\n     */\r\n    setProjection(projection) {\r\n        this._projection = projection;\r\n        //const bound: Bound = this._projection.bound;\r\n        //this._ctx.setTransform(256 * Math.pow(2, this._zoom) / (bound.xmax - bound.xmin) * bound.xscale , 0, 0, 256 * Math.pow(2, this._zoom) / (bound.ymax - bound.ymin) * bound.yscale, this._canvas.width / 2, this._canvas.height / 2);\r\n        //center为经纬度，转化为平面坐标\r\n        const origin = this._projection.project(this._center);\r\n        const bound = this._projection.bound;\r\n        //已知：地理坐标origin，转换后屏幕坐标 即canvas的中心 [this._canvas.width / 2, this._canvas.height / 2]\r\n        //求：平面坐标转换矩阵=Map初始矩阵:  地理坐标——屏幕坐标\r\n        //解法如下：\r\n        const a = 256 * Math.pow(2, this._zoom) / (bound.xmax - bound.xmin) * bound.xscale;\r\n        const d = 256 * Math.pow(2, this._zoom) / (bound.ymax - bound.ymin) * bound.yscale;\r\n        const e = this._canvas.width / 2 - a * origin[0];\r\n        const f = this._canvas.height / 2 - d * origin[1];\r\n        this._ctx.setTransform(a, 0, 0, d, e, f);\r\n    }\r\n    /**\r\n     * 设置视图级别及视图中心\r\n     * @param {number[]} center - 视图中心\r\n     * @param {number} zoom - 视图级别\r\n     */\r\n    setView(center = [0, 0], zoom = 3) {\r\n        this._center = center;\r\n        this._zoom = Math.max(this.minZoom, Math.min(this.maxZoom, zoom));\r\n        //center为经纬度，转化为平面坐标\r\n        const origin = this._projection.project(center);\r\n        const bound = this._projection.bound;\r\n        //已知：地理坐标origin，转换后屏幕坐标 即canvas的中心 [this._canvas.width / 2, this._canvas.height / 2]\r\n        //求：平面坐标转换矩阵=Map初始矩阵:  地理坐标——屏幕坐标\r\n        //解法如下：\r\n        const a = 256 * Math.pow(2, this._zoom) / (bound.xmax - bound.xmin) * bound.xscale;\r\n        const d = 256 * Math.pow(2, this._zoom) / (bound.ymax - bound.ymin) * bound.yscale;\r\n        const e = this._canvas.width / 2 - a * origin[0];\r\n        const f = this._canvas.height / 2 - d * origin[1];\r\n        this._ctx.setTransform(a, 0, 0, d, e, f);\r\n        this.redraw();\r\n    }\r\n    /**\r\n     * 设置缩放到某一范围\r\n     * 默认该范围2倍. 用于缩放到某一要素对应的bound\r\n     * @param {Bound} bound - 视图范围\r\n     */\r\n    fitBound(bound) {\r\n        const origin = bound.getCenter();\r\n        const center = this._projection.unproject(origin, true);\r\n        bound.scale(2);\r\n        const x_mpp = (bound.xmax - bound.xmin) / this._canvas.width; //x  meter per pixel\r\n        const y_mpp = (bound.ymax - bound.ymin) / this._canvas.height; //y  meter per pixel\r\n        //反算 zoom : x_mpp = (bound.xmax - bound.xmin) / (256 * Math.pow(2, this._zoom))\r\n        if (x_mpp == 0 || y_mpp == 0) {\r\n            this.setView(center, this.maxZoom);\r\n        }\r\n        else {\r\n            const full_bound = this._projection.bound;\r\n            const x_zoom = Math.log2((full_bound.xmax - full_bound.xmin) / x_mpp / 256);\r\n            const y_zoom = Math.log2((full_bound.ymax - full_bound.ymin) / y_mpp / 256);\r\n            const zoom = Math.floor(Math.min(x_zoom, y_zoom, this.maxZoom));\r\n            this.setView(center, zoom);\r\n        }\r\n    }\r\n    /**\r\n     * 添加图层\r\n     * @param {Layer} layer - 图层\r\n     */\r\n    addLayer(layer) {\r\n        this._viewer.addLayer(layer);\r\n    }\r\n    /**\r\n     * 插入图层\r\n     * @param {Layer} layer - 图层\r\n     * @param {number} index - 图层顺序\r\n     */\r\n    insertLayer(layer, index = -1) {\r\n        this._viewer.insertLayer(layer, index);\r\n    }\r\n    /**\r\n     * 移除图层\r\n     * @param {Layer} layer - 图层\r\n     */\r\n    removeLayer(layer) {\r\n        this._viewer.removeLayer(layer);\r\n    }\r\n    /**\r\n     * 清空图层\r\n     */\r\n    clearLayers() {\r\n        this._viewer.clearLayers();\r\n    }\r\n    /**\r\n     * 添加动画\r\n     * @param {Animation} animation - 动画\r\n     */\r\n    addAnimation(animation) {\r\n        this._animator.addAnimation(animation);\r\n    }\r\n    /**\r\n     * 删除动画\r\n     * @param {Animation} animation - 动画\r\n     */\r\n    removeAnimation(animation) {\r\n        this._animator.removeAnimation(animation);\r\n    }\r\n    /**\r\n     * 清除动画\r\n     */\r\n    clearAnimations() {\r\n        this._animator.clearAnimations();\r\n    }\r\n    /**\r\n     * 设置切片url\r\n     */\r\n    setTileUrl(url) {\r\n        this._tile.url = url;\r\n    }\r\n    /**\r\n     * 添加图形\r\n     * 参考_defaultGraphicLayer定义处的说明\r\n     * shortcut\r\n     * @param {Graphic} graphic - 图形\r\n     */\r\n    addGraphic(graphic) {\r\n        this._defaultGraphicLayer.add(graphic);\r\n        graphic.draw(this._ctx, this._projection, this._extent);\r\n    }\r\n    /**\r\n     * 删除图形\r\n     * 参考_defaultGraphicLayer定义处的说明\r\n     * shortcut\r\n     * @param {Graphic} graphic - 图形\r\n     */\r\n    removeGraphic(graphic) {\r\n        this._defaultGraphicLayer.remove(graphic);\r\n        this._defaultGraphicLayer.draw(this._ctx, this._projection, this._extent, this._zoom);\r\n    }\r\n    /**\r\n     * 清除图形\r\n     * 参考_defaultGraphicLayer定义处的说明\r\n     * shortcut\r\n     */\r\n    clearGraphics() {\r\n        this._defaultGraphicLayer.clear();\r\n        this._defaultGraphicLayer.draw(this._ctx, this._projection, this._extent, this._zoom);\r\n    }\r\n    /**\r\n     * 添加选中\r\n     * @param {Geometry} geometry - 图形\r\n     */\r\n    addSelection(geometry) {\r\n        if (geometry instanceof Point || geometry instanceof MultiplePoint) {\r\n            this._selectionLayer.add(new Graphic(geometry, this._selectionPointSymbol));\r\n        }\r\n        else if (geometry instanceof Polyline || geometry instanceof MultiplePolyline) {\r\n            this._selectionLayer.add(new Graphic(geometry, this._selectionLineSymbol));\r\n        }\r\n        else if (geometry instanceof Polygon || geometry instanceof MultiplePolygon) {\r\n            this._selectionLayer.add(new Graphic(geometry, this._selectionPolygonSymbol));\r\n        }\r\n        this._selectionLayer.draw(this._ctx, this._projection, this._extent, this._zoom);\r\n    }\r\n    /**\r\n     * 清除选中\r\n     */\r\n    clearSelection() {\r\n        this._selectionLayer.clear();\r\n        this._selectionLayer.draw(this._ctx, this._projection, this._extent, this._zoom);\r\n    }\r\n    /**\r\n     * 更新地图视图范围以及中心点\r\n     */\r\n    updateExtent() {\r\n        const matrix = this._ctx.getTransform();\r\n        const x1 = (0 - matrix.e) / matrix.a, y1 = (0 - matrix.f) / matrix.d, x2 = (this._canvas.width - matrix.e) / matrix.a, y2 = (this._canvas.height - matrix.f) / matrix.d;\r\n        this._extent = new Bound(Math.min(x1, x2), Math.min(y1, y2), Math.max(x1, x2), Math.max(y1, y2));\r\n        this._center = this._projection.unproject([(x1 + x2) / 2, (y1 + y2) / 2]);\r\n        //this._handlers[\"extent\"].forEach(handler => handler({extent: this._extent, center: this._center, zoom: this._zoom, matrix: matrix}));\r\n        this.emit(\"extent\", { extent: this._extent, center: this._center, zoom: this._zoom, matrix: matrix });\r\n    }\r\n    /**\r\n     * 重绘\r\n     */\r\n    redraw() {\r\n        this._ctx.save();\r\n        this._ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n        this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);\r\n        this._ctx.restore();\r\n        this.updateExtent();\r\n        this._defaultGraphicLayer.draw(this._ctx, this._projection, this._extent, this._zoom);\r\n        this._selectionLayer.draw(this._ctx, this._projection, this._extent, this._zoom);\r\n        this.hideTooltip();\r\n    }\r\n    /**\r\n     * 清空视图\r\n     */\r\n    clear() {\r\n        this._ctx.save();\r\n        this._ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n        this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);\r\n        this._ctx.restore();\r\n        this.updateExtent();\r\n    }\r\n    /**\r\n     * 响应窗体resize\r\n     */\r\n    resize() {\r\n        this._onResize(null);\r\n    }\r\n    //响应窗体resize\r\n    _onResize(event) {\r\n        this._canvas.width = this._container.clientWidth;\r\n        this._canvas.height = this._container.clientHeight;\r\n        //this._handlers[\"resize\"].forEach(handler => handler(event));\r\n        this.emit(\"resize\", event);\r\n        this.setView(this._center, this._zoom);\r\n    }\r\n    //响应canvas被点击\r\n    _onClick(event) {\r\n        const matrix = this._ctx.getTransform();\r\n        const x = (event.offsetX - matrix.e) / matrix.a;\r\n        const y = (event.offsetY - matrix.f) / matrix.d;\r\n        [event.lng, event.lat] = this._projection.unproject([x, y]);\r\n        //保存偏移前的坐标\r\n        [event.originalLng, event.originalLat] = this._projection.unproject([x, y], true);\r\n        if (this._editor && this._editor.editing) {\r\n            this._editor._onClick(event);\r\n            return;\r\n        }\r\n        if (this._measurer && this._measurer.measuring) {\r\n            this._measurer._onClick(event);\r\n            return;\r\n        }\r\n        //this._handlers[\"click\"].forEach(handler => handler(event));\r\n        this.emit(\"click\", event);\r\n    }\r\n    //响应canvas被双击\r\n    //默认交互，双击放大一倍\r\n    _onDoubleClick(event) {\r\n        if (this._editor.editing) {\r\n            this._editor._onDoubleClick(event);\r\n            return;\r\n        }\r\n        if (this._measurer.measuring) {\r\n            this._measurer._onDoubleClick(event);\r\n            return;\r\n        }\r\n        if (!this._option.disableDoubleClick) {\r\n            if (this._zoom >= this.maxZoom)\r\n                return;\r\n            const scale = 2;\r\n            this._zoom += 1;\r\n            const matrix = this._ctx.getTransform();\r\n            const a1 = matrix.a, e1 = matrix.e, x1 = event.offsetX, x2 = x1; //放大到中心点 x2 = this._canvas.width / 2\r\n            const e = (x2 - scale * (x1 - e1) - e1) / a1;\r\n            const d1 = matrix.d, f1 = matrix.f, y1 = event.offsetY, y2 = y1; //放大到中心点 y2 = this._canvas.height / 2\r\n            const f = (y2 - scale * (y1 - f1) - f1) / d1;\r\n            this._ctx.transform(scale, 0, 0, scale, e, f);\r\n            this.redraw();\r\n        }\r\n        //this._handlers[\"dblclick\"].forEach(handler => handler(event));\r\n        this.emit(\"dblclick\", event);\r\n    }\r\n    //响应canvas mousedown\r\n    //漫游起始\r\n    _onMouseDown(event) {\r\n        if (this._editor.editing && this._editor.editingFeature) {\r\n            this._editor._onMouseDown(event);\r\n            return;\r\n        }\r\n        this._drag.flag = true;\r\n        this._drag.start.x = event.x;\r\n        this._drag.start.y = event.y;\r\n    }\r\n    _onMouseMove(event) {\r\n        if (this._editor.editing) {\r\n            const matrix = this._ctx.getTransform();\r\n            const x = (event.offsetX - matrix.e) / matrix.a;\r\n            const y = (event.offsetY - matrix.f) / matrix.d;\r\n            [event.lng, event.lat] = this._projection.unproject([x, y]);\r\n            [event.originalLng, event.originalLat] = this._projection.unproject([x, y], true);\r\n            this._editor._onMouseMove(event);\r\n            return;\r\n        }\r\n        if (this._measurer.measuring) {\r\n            const matrix = this._ctx.getTransform();\r\n            const x = (event.offsetX - matrix.e) / matrix.a;\r\n            const y = (event.offsetY - matrix.f) / matrix.d;\r\n            [event.lng, event.lat] = this._projection.unproject([x, y]);\r\n            //保存偏移前的坐标\r\n            [event.originalLng, event.originalLat] = this._projection.unproject([x, y], true);\r\n            this._measurer._onMouseMove(event);\r\n            return;\r\n        }\r\n        if (!this._drag.flag) {\r\n            this._handlers[\"mousemove\"].forEach(handler => handler(event));\r\n        }\r\n    }\r\n    //响应canvas mouseup\r\n    //漫游结束\r\n    _onMouseUp(event) {\r\n        if (this._editor.editing && this._editor.editingFeature) {\r\n            this._editor._onMouseUp(event);\r\n            return;\r\n        }\r\n        if (this._drag.flag) {\r\n            this._drag.end.x = event.x;\r\n            this._drag.end.y = event.y;\r\n            const matrix = this._ctx.getTransform();\r\n            this._ctx.translate((this._drag.end.x - this._drag.start.x) / matrix.a, (this._drag.end.y - this._drag.start.y) / matrix.d);\r\n            this.redraw();\r\n        }\r\n        this._drag.flag = false;\r\n    }\r\n    //响应滚轮缩放\r\n    _onWheel(event) {\r\n        this._wheelTimer && clearTimeout(this._wheelTimer);\r\n        this._wheelTimer = setTimeout(() => {\r\n            event.preventDefault();\r\n            //级别缩放\r\n            const sensitivity = 5;\r\n            if (Math.abs(event.deltaY) <= sensitivity)\r\n                return;\r\n            const delta = event.deltaY < 0 ? -1 : 1;\r\n            let scale = 1;\r\n            if (delta < 0) {\r\n                // 放大\r\n                scale *= delta * -2;\r\n            }\r\n            else {\r\n                // 缩小\r\n                scale /= delta * 2;\r\n            }\r\n            let zoom = Math.round(Math.log(scale));\r\n            //无级缩放\r\n            /*const sensitivity = 100;\r\n            const delta = event.deltaY / sensitivity;\r\n            if (Math.abs(delta) <= 0.05) return;\r\n            let scale = 1;\r\n            let zoom = -delta;*/\r\n            //------------------------------------------------------------\r\n            if (zoom > 0) {\r\n                // 放大\r\n                zoom = this._zoom + zoom >= this.maxZoom ? this.maxZoom - this._zoom : zoom;\r\n            }\r\n            else if (zoom < 0) {\r\n                // 缩小\r\n                zoom = this._zoom + zoom <= this.minZoom ? this.minZoom - this._zoom : zoom;\r\n            }\r\n            if (zoom == 0)\r\n                return;\r\n            this._zoom += zoom;\r\n            scale = Math.pow(2, zoom);\r\n            //交互表现为 鼠标当前位置 屏幕坐标不变 进行缩放 即x2 = x1，y2=y1\r\n            //其它设定：变换前矩阵(a1,0,0,d1,e1,f1)   变换矩阵(a,0,0,d,e,f)  变换后矩阵(a2,0,0,d2,e2,f2)\r\n            //scale已通过滚轮变化，换算得到，且a=d=scale，求e和f\r\n            //1.将原屏幕坐标 x1 转成 地理坐标 x0 = (x1 - e1) / a1\r\n            //2.地理坐标x0 转成 现屏幕坐标x2  a2 * x0 + e2 = x2 e2 = x2 - a2 * x0 代入1式 e2 = x2 - a2 * (x1 - e1) / a1\r\n            //3.已知scale = a2 / a1 故 e2 = x2 - scale * (x1 - e1)\r\n            //4.另矩阵变换 a1 * e + e1 = e2\r\n            //5.联立3和4 求得 e = (x2 - scale * (x1 - e1) - e1) / a1\r\n            const matrix = this._ctx.getTransform();\r\n            const a1 = matrix.a, e1 = matrix.e, x1 = event.offsetX, x2 = x1; //放大到中心点 x2 = this._canvas.width / 2\r\n            const e = (x2 - scale * (x1 - e1) - e1) / a1;\r\n            const d1 = matrix.d, f1 = matrix.f, y1 = event.offsetY, y2 = y1; //放大到中心点 y2 = this._canvas.height / 2\r\n            const f = (y2 - scale * (y1 - f1) - f1) / d1;\r\n            this._ctx.transform(scale, 0, 0, scale, e, f);\r\n            this.redraw();\r\n        }, 50);\r\n    }\r\n    //响应触摸\r\n    _onTouchStart(event) {\r\n        if (event.touches.length == 2) { // if multiple touches (pinch zooming)\r\n            let diffX = event.touches[0].clientX - event.touches[1].clientX;\r\n            let diffY = event.touches[0].clientY - event.touches[1].clientY;\r\n            this._touch.finger_dist = Math.sqrt(diffX * diffX + diffY * diffY); // Save current finger distance\r\n            this._touch.dragging = false;\r\n            this._touch.zooming = true;\r\n            //console.log(\"zoom start(cancel drag)\");\r\n        } // Else just moving around\r\n        else if (event.touches.length == 1) {\r\n            this._onMouseDown({ x: event.changedTouches[0].clientX, y: event.changedTouches[0].clientY });\r\n            this._touch.dragging = true;\r\n            //console.log(\"drag start\");\r\n        }\r\n    }\r\n    _onTouchMove(event) {\r\n        event.preventDefault(); // Stop the window from moving\r\n        if (event.touches.length == 2 && this._touch.zooming) { // If pinch-zooming\r\n            let diffX = event.touches[0].clientX - event.touches[1].clientX;\r\n            let diffY = event.touches[0].clientY - event.touches[1].clientY;\r\n            let new_finger_dist = Math.sqrt(diffX * diffX + diffY * diffY); // Get current distance between fingers\r\n            //let scale = Math.abs(new_finger_dist / this._touch.finger_dist); // Zoom is proportional to change\r\n            /*let zoom = Math.round(Math.log(scale));\r\n            if (zoom > 0) {\r\n                // 放大\r\n                zoom = this._zoom + zoom >= this.maxZoom ? this.maxZoom - this._zoom : zoom;\r\n            } else if (zoom < 0) {\r\n                // 缩小\r\n                zoom = this._zoom + zoom <= this.minZoom ? this.minZoom - this._zoom : zoom;\r\n            }*/\r\n            let zoom = 0;\r\n            let sensitivity = 50; //pixel\r\n            if (new_finger_dist - this._touch.finger_dist > sensitivity) {\r\n                // 放大\r\n                zoom = this._zoom + 1 >= this.maxZoom ? this.maxZoom - this._zoom : 1;\r\n            }\r\n            else if (this._touch.finger_dist - new_finger_dist > sensitivity) {\r\n                // 缩小\r\n                zoom = this._zoom - 1 <= this.minZoom ? this.minZoom - this._zoom : -1;\r\n            }\r\n            else {\r\n                return;\r\n            }\r\n            if (zoom == 0)\r\n                return;\r\n            let scale = Math.pow(2, zoom);\r\n            this._zoom += zoom;\r\n            //console.log(\"zoom:\" + this._zoom + \" dist:\" + this._touch.finger_dist + \"-\" + new_finger_dist);\r\n            this._touch.finger_dist = new_finger_dist; // Save current distance for next time\r\n            const matrix = this._ctx.getTransform();\r\n            const a1 = matrix.a, e1 = matrix.e, x1 = (event.touches[0].clientX + event.touches[1].clientX) / 2, x2 = x1; //放大到中心点 x2 = this._canvas.width / 2\r\n            const e = (x2 - scale * (x1 - e1) - e1) / a1;\r\n            const d1 = matrix.d, f1 = matrix.f, y1 = (event.touches[0].clientY + event.touches[1].clientY) / 2, y2 = y1; //放大到中心点 y2 = this._canvas.height / 2\r\n            const f = (y2 - scale * (y1 - f1) - f1) / d1;\r\n            this._ctx.transform(scale, 0, 0, scale, e, f);\r\n            this.redraw();\r\n        }\r\n    }\r\n    _onTouchEnd(event) {\r\n        if (this._touch.zooming) {\r\n            this._touch.zooming = false;\r\n            //console.log(\"zoom end\");\r\n        }\r\n        else if (this._touch.dragging) {\r\n            this._touch.dragging = false;\r\n            this._onMouseUp({ x: event.changedTouches[0].clientX, y: event.changedTouches[0].clientY });\r\n            //console.log(\"drag end\");\r\n        }\r\n    }\r\n    /**\r\n     * 显示Tooltip\r\n     * shortcut\r\n     * @param {Feature} feature - 要素\r\n     * @param {Field} field - 字段\r\n     */\r\n    showTooltip(feature, field) {\r\n        const text = feature.properties[field.name];\r\n        const center = feature.geometry.getCenter(CoordinateType.Projection, this.projection);\r\n        const matrix = this._ctx.getTransform();\r\n        const screenX = (matrix.a * center[0] + matrix.e);\r\n        const screenY = (matrix.d * center[1] + matrix.f);\r\n        this._tooltip.show(text, screenX, screenY);\r\n    }\r\n    /**\r\n     * 隐藏Tooltip\r\n     * shortcut\r\n     */\r\n    hideTooltip() {\r\n        this._tooltip.hide();\r\n    }\r\n    /**\r\n     * 销毁\r\n     */\r\n    destroy() {\r\n        window.removeEventListener(\"resize\", this._onResize);\r\n        this._canvas.removeEventListener(\"click\", this._onClick);\r\n        if (!this._option.disableInteractive) {\r\n            this._canvas.removeEventListener(\"dblclick\", this._onDoubleClick);\r\n            this._canvas.removeEventListener(\"mousedown\", this._onMouseDown);\r\n            this._canvas.removeEventListener(\"mousemove\", this._onMouseMove);\r\n            this._canvas.removeEventListener(\"mouseup\", this._onMouseUp);\r\n            this._canvas.removeEventListener(\"wheel\", this._onWheel);\r\n            this._canvas.removeEventListener(\"touchstart\", this._onTouchStart);\r\n            this._canvas.removeEventListener(\"touchmove\", this._onTouchMove);\r\n            this._canvas.removeEventListener(\"touchend\", this._onTouchEnd);\r\n        }\r\n        this._viewer = null;\r\n        this._editor = null;\r\n    }\r\n}\r\n","import { CoordinateType } from \"./geometry/geometry\";\r\nimport { GraphicLayer } from \"./layer/graphic-layer\";\r\nimport { Graphic } from \"./element/graphic\";\r\nimport { Point } from \"./geometry/point\";\r\nimport { SimpleFillSymbol, SimpleLineSymbol, SimplePointSymbol, SimpleTextSymbol } from \"./symbol/symbol\";\r\nimport { Subject } from \"./util/subject\";\r\nimport { Polyline } from \"./geometry/polyline\";\r\nimport { Polygon } from \"./geometry/polygon\";\r\nexport var MeasureActionType;\r\n(function (MeasureActionType) {\r\n    MeasureActionType[MeasureActionType[\"Default\"] = 0] = \"Default\";\r\n    MeasureActionType[MeasureActionType[\"Polyline\"] = 1] = \"Polyline\";\r\n    MeasureActionType[MeasureActionType[\"Polygon\"] = 2] = \"Polygon\";\r\n})(MeasureActionType || (MeasureActionType = {}));\r\n/**\r\n * Measurer\r\n */\r\nexport class Measurer extends Subject {\r\n    /**\r\n     * 创建Editor\r\n     * 不应自主创建，map内部创建\r\n     * @param {Map} map - 地图容器\r\n     */\r\n    constructor(map) {\r\n        super([\"mouseover\", \"mouseout\", \"startedit\", \"stopedit\", \"click\", \"update\", \"commit\", \"create\", \"delete\"]); //when mouseover feature or vertex\r\n        this._create = {\r\n            click: 0,\r\n            graphic: null,\r\n            lnglats: []\r\n        };\r\n        this._action = MeasureActionType.Default;\r\n        this._defaultPointSymbol = new SimplePointSymbol();\r\n        this._defaultLineSymbol = new SimpleLineSymbol();\r\n        this._defaultPolygonSymbol = new SimpleFillSymbol();\r\n        this._map = map;\r\n        const container = map.container;\r\n        //create canvas\r\n        this._canvas = document.createElement(\"canvas\");\r\n        this._canvas.style.cssText = \"position: absolute; height: 100%; width: 100%; z-index: 90\";\r\n        this._canvas.width = container.clientWidth;\r\n        this._canvas.height = container.clientHeight;\r\n        container.appendChild(this._canvas);\r\n        this._ctx = this._canvas.getContext(\"2d\");\r\n        this._onResize = this._onResize.bind(this);\r\n        this._extentChange = this._extentChange.bind(this);\r\n        this._map.on(\"resize\", this._onResize);\r\n        this._map.on(\"extent\", this._extentChange);\r\n        this._measureLayer = new GraphicLayer();\r\n    }\r\n    get measuring() {\r\n        return this._measuring;\r\n    }\r\n    get action() {\r\n        return this._action;\r\n    }\r\n    set action(value) {\r\n        this._action = value;\r\n    }\r\n    get defaultPointSymbol() {\r\n        return this._defaultPointSymbol;\r\n    }\r\n    set defaultPointSymbol(value) {\r\n        this._defaultPointSymbol = value;\r\n    }\r\n    get defaultLineSymbol() {\r\n        return this._defaultLineSymbol;\r\n    }\r\n    set defaultLineSymbol(value) {\r\n        this._defaultLineSymbol = value;\r\n    }\r\n    get defaultPolygonSymbol() {\r\n        return this._defaultPolygonSymbol;\r\n    }\r\n    set defaultPolygonSymbol(value) {\r\n        this._defaultPolygonSymbol = value;\r\n    }\r\n    measurePolyLine() {\r\n        this._measuring = true;\r\n        this._action = MeasureActionType.Polyline;\r\n        this._createLayer = new GraphicLayer();\r\n    }\r\n    measurePolygon() {\r\n        this._measuring = true;\r\n        this._action = MeasureActionType.Polygon;\r\n        this._createLayer = new GraphicLayer();\r\n    }\r\n    clear() {\r\n        this._measuring = false;\r\n        this._action = MeasureActionType.Default;\r\n        this._create = {\r\n            click: 0,\r\n            graphic: null,\r\n            lnglats: []\r\n        };\r\n        this._measureLayer.clear();\r\n        this._ctx.save();\r\n        this._ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n        this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);\r\n        this._ctx.restore();\r\n    }\r\n    addGraphic(g) {\r\n        this._measureLayer.add(g);\r\n        this.redraw();\r\n    }\r\n    removeGraphic(g) {\r\n        this._measureLayer.remove(g);\r\n        this.redraw();\r\n    }\r\n    _onResize(event) {\r\n        this._canvas.width = this._map.container.clientWidth;\r\n        this._canvas.height = this._map.container.clientHeight;\r\n    }\r\n    _extentChange(event) {\r\n        this._ctx.setTransform(event.matrix.a, 0, 0, event.matrix.d, event.matrix.e, event.matrix.f);\r\n        this.redraw();\r\n    }\r\n    redraw() {\r\n        this._ctx.save();\r\n        this._ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n        this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);\r\n        this._ctx.restore();\r\n        this._createLayer && this._createLayer.draw(this._ctx, this._map.projection, this._map.extent, this._map.zoom);\r\n        this._measureLayer && this._measureLayer.draw(this._ctx, this._map.projection, this._map.extent, this._map.zoom);\r\n        this._measureLayer.graphics.forEach(graphic => this._label(graphic.geometry));\r\n    }\r\n    _onClick(event) {\r\n        if (!this._measuring)\r\n            return;\r\n        if (event.detail > 1)\r\n            return;\r\n        if (this._action === MeasureActionType.Polygon) {\r\n            if (this._create.click == 0) {\r\n                this._createLayer.clear();\r\n                const point = new Point(event.originalLng, event.originalLat);\r\n                const graphic = new Graphic(point, this._defaultPointSymbol);\r\n                this._createLayer.add(graphic);\r\n                this._create.click += 1;\r\n                this._create.lnglats.push([event.originalLng, event.originalLat]);\r\n            }\r\n            else if (this._create.click == 1) {\r\n                const second = new Point(event.originalLng, event.originalLat);\r\n                const graphic1 = new Graphic(second, this._defaultPointSymbol);\r\n                this._createLayer.add(graphic1);\r\n                if (this._create.graphic)\r\n                    this._createLayer.remove(this._create.graphic);\r\n                this._create.lnglats.push([event.originalLng, event.originalLat]);\r\n                const line = new Polyline(this._create.lnglats);\r\n                this._create.graphic = new Graphic(line, this._defaultLineSymbol);\r\n                this._createLayer.add(this._create.graphic);\r\n                this._create.click += 1;\r\n            }\r\n            else {\r\n                const second = new Point(event.originalLng, event.originalLat);\r\n                const graphic1 = new Graphic(second, this._defaultPointSymbol);\r\n                this._createLayer.add(graphic1);\r\n                if (this._create.graphic)\r\n                    this._createLayer.remove(this._create.graphic);\r\n                this._create.lnglats.push([event.originalLng, event.originalLat]);\r\n                const polygon = new Polygon([this._create.lnglats]);\r\n                this._create.graphic = new Graphic(polygon, this._defaultPolygonSymbol);\r\n                this._createLayer.add(this._create.graphic);\r\n                this._create.click += 1;\r\n            }\r\n        }\r\n        else if (this._action === MeasureActionType.Polyline) {\r\n            if (this._create.click == 0) {\r\n                this._createLayer.clear();\r\n                const point = new Point(event.originalLng, event.originalLat);\r\n                const graphic = new Graphic(point, this._defaultPointSymbol);\r\n                this._createLayer.add(graphic);\r\n                this._create.click += 1;\r\n                this._create.lnglats.push([event.originalLng, event.originalLat]);\r\n            }\r\n            else {\r\n                const second = new Point(event.originalLng, event.originalLat);\r\n                const graphic1 = new Graphic(second, this._defaultPointSymbol);\r\n                this._createLayer.add(graphic1);\r\n                if (this._create.graphic)\r\n                    this._createLayer.remove(this._create.graphic);\r\n                this._create.lnglats.push([event.originalLng, event.originalLat]);\r\n                const line = new Polyline(this._create.lnglats);\r\n                this._create.graphic = new Graphic(line, this._defaultLineSymbol);\r\n                this._createLayer.add(this._create.graphic);\r\n                this._create.click += 1;\r\n            }\r\n        }\r\n    }\r\n    _onDoubleClick(event) {\r\n        if (!this._measuring)\r\n            return;\r\n        if (this._action === MeasureActionType.Polygon) {\r\n            if (this._create.click > 1) {\r\n                if (this._create.graphic)\r\n                    this._createLayer.remove(this._create.graphic);\r\n                const polygon = new Polygon([this._create.lnglats]);\r\n                const graphic = new Graphic(polygon, this._defaultPolygonSymbol);\r\n                this._create = {\r\n                    click: 0,\r\n                    graphic: null,\r\n                    lnglats: []\r\n                };\r\n                this._createLayer.clear();\r\n                this.addGraphic(graphic);\r\n                //this._label(polygon);\r\n            }\r\n        }\r\n        else if (this._action === MeasureActionType.Polyline) {\r\n            if (this._create.click > 0) {\r\n                if (this._create.graphic)\r\n                    this._createLayer.remove(this._create.graphic);\r\n                const polyline = new Polyline(this._create.lnglats);\r\n                const graphic = new Graphic(polyline, this._defaultLineSymbol);\r\n                this._create = {\r\n                    click: 0,\r\n                    graphic: null,\r\n                    lnglats: []\r\n                };\r\n                this._createLayer.clear();\r\n                this.addGraphic(graphic);\r\n                //this._label(polyline);\r\n            }\r\n        }\r\n    }\r\n    _label(geometry) {\r\n        let projection = this._map.projection;\r\n        geometry.project(projection);\r\n        let ctx = this._canvas.getContext(\"2d\");\r\n        ctx.save();\r\n        let symbol = new SimpleTextSymbol();\r\n        ctx.strokeStyle = symbol.strokeStyle;\r\n        ctx.fillStyle = symbol.fillStyle;\r\n        ctx.lineWidth = symbol.lineWidth;\r\n        ctx.lineJoin = \"round\";\r\n        ctx.font = symbol.fontSize + \"px/1 \" + symbol.fontFamily + \" \" + symbol.fontWeight;\r\n        const matrix = ctx.getTransform();\r\n        //keep pixel\r\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n        let text = \"\";\r\n        let center = geometry.getCenter(CoordinateType.Projection, projection);\r\n        if (geometry instanceof Polyline) {\r\n            const length = geometry.getLength(projection);\r\n            text = length > 1000 ? Math.round(length / 1000 * 10) / 10 + \"公里\" : Math.round(length) + \"米\";\r\n            center = geometry.coordinates[geometry.coordinates.length - 1];\r\n        }\r\n        else if (geometry instanceof Polygon) {\r\n            const area = geometry.getArea(projection);\r\n            text = area > 1000 ? Math.round(area / 10000 * 10) / 10 + \"公顷\" : Math.round(area) + \"平方米\";\r\n        }\r\n        else {\r\n            return;\r\n        }\r\n        let width = ctx.measureText(text).width + symbol.padding * 2;\r\n        let height = symbol.fontSize + symbol.padding * 2;\r\n        const screenX = (matrix.a * center[0] + matrix.e);\r\n        const screenY = (matrix.d * center[1] + matrix.f);\r\n        let totalX, totalY;\r\n        totalX = -width / 2;\r\n        totalY = symbol.pointSymbolHeight / 2;\r\n        ctx.strokeRect(screenX + totalX, screenY + totalY, width, height);\r\n        ctx.fillRect(screenX + totalX, screenY + totalY, width, height);\r\n        ctx.textBaseline = \"top\";\r\n        ctx.fillStyle = symbol.fontColor;\r\n        ctx.fillText(text, screenX + totalX + symbol.padding, screenY + totalY + symbol.padding);\r\n        ctx.restore();\r\n    }\r\n    ;\r\n    _onMouseDown(event) {\r\n    }\r\n    _onMouseMove(event) {\r\n        if (!this._measuring)\r\n            return;\r\n        if (this._action === MeasureActionType.Polygon) {\r\n            if (this._create.click == 1) {\r\n                if (this._create.graphic)\r\n                    this._createLayer.remove(this._create.graphic);\r\n                const lnglats = [...this._create.lnglats];\r\n                lnglats.push([event.originalLng, event.originalLat]);\r\n                const line = new Polyline(lnglats);\r\n                this._create.graphic = new Graphic(line, this._defaultLineSymbol);\r\n                this._createLayer.add(this._create.graphic);\r\n            }\r\n            else if (this._create.click > 1) {\r\n                if (this._create.graphic)\r\n                    this._createLayer.remove(this._create.graphic);\r\n                const lnglats = [...this._create.lnglats];\r\n                lnglats.push([event.originalLng, event.originalLat]);\r\n                const polygon = new Polygon([lnglats]);\r\n                this._create.graphic = new Graphic(polygon, this._defaultPolygonSymbol);\r\n                this._createLayer.add(this._create.graphic);\r\n            }\r\n        }\r\n        else if (this._action === MeasureActionType.Polyline) {\r\n            if (this._create.click > 0) {\r\n                if (this._create.graphic)\r\n                    this._createLayer.remove(this._create.graphic);\r\n                const lnglats = [...this._create.lnglats];\r\n                lnglats.push([event.originalLng, event.originalLat]);\r\n                const line = new Polyline(lnglats);\r\n                this._create.graphic = new Graphic(line, this._defaultLineSymbol);\r\n                this._createLayer.add(this._create.graphic);\r\n            }\r\n        }\r\n        this.redraw();\r\n    }\r\n    _onMouseUp(event) {\r\n    }\r\n    destroy() {\r\n        this._measureLayer = null;\r\n        this._map.off(\"resize\", this._onResize);\r\n        this._map.off(\"extent\", this._extentChange);\r\n    }\r\n}\r\n","import { Bound } from \"../util/bound\";\r\nimport { LatLngType, Projection } from \"./projection\";\r\nimport { GCJ02 } from \"./gcj02\";\r\n/**\r\n * 带百度09偏移的球体墨卡托投影\r\n * @remarks https://github.com/wandergis/coordtransform\r\n * just for china\r\n * 依赖Baidu Map API\r\n */\r\nexport class BD09 extends Projection {\r\n    /**\r\n     * 创建带国测局02偏移的球体墨卡托投影\r\n     * @remarks 参考经纬度坐标类型，不同类型走不同数据处理流程\r\n     * @param {LatLngType} type - 经纬度坐标类型\r\n     */\r\n    constructor(type = LatLngType.GPS) {\r\n        super();\r\n        this._type = type;\r\n    }\r\n    /**\r\n     * 投影后的平面坐标范围\r\n     */\r\n    get bound() {\r\n        return new Bound(-BD09.TOTAL_PIXELS / 2, BD09.TOTAL_PIXELS / 2, BD09.TOTAL_PIXELS / 2, -BD09.TOTAL_PIXELS / 2);\r\n    }\r\n    /**\r\n     * 经纬度转平面坐标\r\n     * @remarks 地理平面坐标 单位米\r\n     * @param {number} lng - 经度\r\n     * @param {number} lat - 纬度\r\n     * @return {number[]} 地理平面坐标\r\n     */\r\n    project([lng, lat]) {\r\n        //from leaflet & wiki\r\n        if (this._type == LatLngType.GPS) {\r\n            [lng, lat] = GCJ02.wgs84togcj02(lng, lat);\r\n            [lng, lat] = BD09.gcj02tobd09(lng, lat);\r\n        }\r\n        else if (this._type == LatLngType.GCJ02) {\r\n            [lng, lat] = BD09.gcj02tobd09(lng, lat);\r\n        }\r\n        const projection = new BMap.MercatorProjection();\r\n        const pixel = projection.lngLatToPoint(new BMap.Point(lng, lat));\r\n        return [pixel.x, pixel.y];\r\n        /*const d = Math.PI / 180, sin = Math.sin(lat * d);\r\n        return [WebMercator.R * lng * d,  WebMercator.R * Math.log((1 + sin) / (1 - sin)) / 2];*/\r\n    }\r\n    /**\r\n     * 平面坐标转经纬度\r\n     * @remarks 地理平面坐标 单位米\r\n     * @param {number} x - 地理平面坐标x\r\n     * @param {number} y - 地理平面坐标y\r\n     * @return {number[]} 经纬度\r\n     */\r\n    unproject([x, y], original = false) {\r\n        const projection = new BMap.MercatorProjection();\r\n        const point = projection.pointToLngLat(new BMap.Pixel(x, y));\r\n        let [lng, lat] = [point.lng, point.lat];\r\n        if (original) {\r\n            if (this._type == LatLngType.GPS) {\r\n                [lng, lat] = BD09.bd09togcj02(lng, lat);\r\n                [lng, lat] = GCJ02.gcj02towgs84(lng, lat);\r\n            }\r\n            else if (this._type == LatLngType.GCJ02) {\r\n                [lng, lat] = BD09.bd09togcj02(lng, lat);\r\n            }\r\n        }\r\n        return [lng, lat];\r\n    }\r\n    /**\r\n     * 百度坐标系 (BD-09) 与 火星坐标系 (GCJ-02) 的转换\r\n     * @remarks\r\n     * from https://github.com/wandergis/coordtransform\r\n     * 即 百度 转 谷歌、高德\r\n     * @param bd_lng\r\n     * @param bd_lat\r\n     * @returns {*[]}\r\n     */\r\n    static bd09togcj02(bd_lng, bd_lat) {\r\n        var x = bd_lng - 0.0065;\r\n        var y = bd_lat - 0.006;\r\n        var z = Math.sqrt(x * x + y * y) - 0.00002 * Math.sin(y * Math.PI * 3000.0 / 180.0);\r\n        var theta = Math.atan2(y, x) - 0.000003 * Math.cos(x * Math.PI * 3000.0 / 180.0);\r\n        var gg_lng = z * Math.cos(theta);\r\n        var gg_lat = z * Math.sin(theta);\r\n        return [gg_lng, gg_lat];\r\n    }\r\n    ;\r\n    /**\r\n     * 火星坐标系 (GCJ-02) 与百度坐标系 (BD-09) 的转换\r\n     * @remarks\r\n     * from https://github.com/wandergis/coordtransform\r\n     * 即 谷歌、高德 转 百度\r\n     * @param lng\r\n     * @param lat\r\n     * @returns {*[]}\r\n     */\r\n    static gcj02tobd09(lng, lat) {\r\n        var z = Math.sqrt(lng * lng + lat * lat) + 0.00002 * Math.sin(lat * Math.PI * 3000.0 / 180.0);\r\n        var theta = Math.atan2(lat, lng) + 0.000003 * Math.cos(lng * Math.PI * 3000.0 / 180.0);\r\n        var bd_lng = z * Math.cos(theta) + 0.0065;\r\n        var bd_lat = z * Math.sin(theta) + 0.006;\r\n        return [bd_lng, bd_lat];\r\n    }\r\n    ;\r\n}\r\n/**\r\n * 百度平面坐标系的坐标原点与百度瓦片坐标原点相同，以瓦片等级18级为基准，规定18级时百度平面坐标的一个单位等于屏幕上的一个像素\r\n */\r\nBD09.TOTAL_PIXELS = 256 * Math.pow(2, 18);\r\n","import { Bound } from \"../util/bound\";\r\nimport { LatLngType, Projection } from \"./projection\";\r\n/**\r\n * 带国测局02偏移的球体墨卡托投影\r\n * @remarks https://github.com/wandergis/coordtransform\r\n * just for china\r\n */\r\nexport class GCJ02 extends Projection {\r\n    /**\r\n     * 创建带国测局02偏移的球体墨卡托投影\r\n     * @remarks 参考经纬度坐标类型，不同类型走不同数据处理流程\r\n     * @param {LatLngType} type - 经纬度坐标类型\r\n     */\r\n    constructor(type = LatLngType.GPS) {\r\n        super();\r\n        this._type = type;\r\n    }\r\n    /**\r\n     * 投影后的平面坐标范围\r\n     */\r\n    get bound() {\r\n        return new Bound(-Math.PI * GCJ02.R, Math.PI * GCJ02.R, Math.PI * GCJ02.R, -Math.PI * GCJ02.R);\r\n    }\r\n    /**\r\n     * 经纬度转平面坐标\r\n     * @remarks 地理平面坐标 单位米\r\n     * @param {number} lng - 经度\r\n     * @param {number} lat - 纬度\r\n     * @return {number[]} 地理平面坐标\r\n     */\r\n    project([lng, lat]) {\r\n        if (this._type == LatLngType.GPS) {\r\n            [lng, lat] = GCJ02.wgs84togcj02(lng, lat);\r\n        }\r\n        //from leaflet & wiki\r\n        const d = Math.PI / 180, sin = Math.sin(lat * d);\r\n        return [GCJ02.R * lng * d, GCJ02.R * Math.log((1 + sin) / (1 - sin)) / 2];\r\n    }\r\n    /**\r\n     * 平面坐标转经纬度\r\n     * @remarks 地理平面坐标 单位米\r\n     * @param {number} x - 地理平面坐标x\r\n     * @param {number} y - 地理平面坐标y\r\n     * @param {boolean} original - 是否转换回偏移前经纬度坐标\r\n     * @return {number[]} 经纬度\r\n     */\r\n    unproject([x, y], original = false) {\r\n        const d = 180 / Math.PI;\r\n        let [lng, lat] = [x * d / GCJ02.R, (2 * Math.atan(Math.exp(y / GCJ02.R)) - (Math.PI / 2)) * d];\r\n        if (original) {\r\n            if (this._type == LatLngType.GPS) {\r\n                [lng, lat] = GCJ02.gcj02towgs84(lng, lat);\r\n            }\r\n        }\r\n        return [lng, lat];\r\n    }\r\n    /**\r\n     * WGS-84 转 GCJ-02\r\n     * @remarks https://github.com/wandergis/coordtransform\r\n     * @param lng\r\n     * @param lat\r\n     * @returns {number[]}\r\n     */\r\n    static wgs84togcj02(lng, lat) {\r\n        var dlat = this._transformlat(lng - 105.0, lat - 35.0);\r\n        var dlng = this._transformlng(lng - 105.0, lat - 35.0);\r\n        var radlat = lat / 180.0 * Math.PI;\r\n        var magic = Math.sin(radlat);\r\n        magic = 1 - GCJ02.ee * magic * magic;\r\n        var sqrtmagic = Math.sqrt(magic);\r\n        dlat = (dlat * 180.0) / ((GCJ02.R * (1 - GCJ02.ee)) / (magic * sqrtmagic) * Math.PI);\r\n        dlng = (dlng * 180.0) / (GCJ02.R / sqrtmagic * Math.cos(radlat) * Math.PI);\r\n        var mglat = lat + dlat;\r\n        var mglng = lng + dlng;\r\n        return [mglng, mglat];\r\n    }\r\n    ;\r\n    /**\r\n     * GCJ-02 转换为 WGS-84\r\n     * @remarks https://github.com/wandergis/coordtransform\r\n     * @param lng\r\n     * @param lat\r\n     * @returns {number[]}\r\n     */\r\n    static gcj02towgs84(lng, lat) {\r\n        var dlat = this._transformlat(lng - 105.0, lat - 35.0);\r\n        var dlng = this._transformlng(lng - 105.0, lat - 35.0);\r\n        var radlat = lat / 180.0 * Math.PI;\r\n        var magic = Math.sin(radlat);\r\n        magic = 1 - GCJ02.ee * magic * magic;\r\n        var sqrtmagic = Math.sqrt(magic);\r\n        dlat = (dlat * 180.0) / ((GCJ02.R * (1 - GCJ02.ee)) / (magic * sqrtmagic) * Math.PI);\r\n        dlng = (dlng * 180.0) / (GCJ02.R / sqrtmagic * Math.cos(radlat) * Math.PI);\r\n        var mglat = lat + dlat;\r\n        var mglng = lng + dlng;\r\n        return [lng * 2 - mglng, lat * 2 - mglat];\r\n    }\r\n    ;\r\n    static _transformlat(lng, lat) {\r\n        var ret = -100.0 + 2.0 * lng + 3.0 * lat + 0.2 * lat * lat + 0.1 * lng * lat + 0.2 * Math.sqrt(Math.abs(lng));\r\n        ret += (20.0 * Math.sin(6.0 * lng * Math.PI) + 20.0 * Math.sin(2.0 * lng * Math.PI)) * 2.0 / 3.0;\r\n        ret += (20.0 * Math.sin(lat * Math.PI) + 40.0 * Math.sin(lat / 3.0 * Math.PI)) * 2.0 / 3.0;\r\n        ret += (160.0 * Math.sin(lat / 12.0 * Math.PI) + 320 * Math.sin(lat * Math.PI / 30.0)) * 2.0 / 3.0;\r\n        return ret;\r\n    }\r\n    ;\r\n    static _transformlng(lng, lat) {\r\n        var ret = 300.0 + lng + 2.0 * lat + 0.1 * lng * lng + 0.1 * lng * lat + 0.1 * Math.sqrt(Math.abs(lng));\r\n        ret += (20.0 * Math.sin(6.0 * lng * Math.PI) + 20.0 * Math.sin(2.0 * lng * Math.PI)) * 2.0 / 3.0;\r\n        ret += (20.0 * Math.sin(lng * Math.PI) + 40.0 * Math.sin(lng / 3.0 * Math.PI)) * 2.0 / 3.0;\r\n        ret += (150.0 * Math.sin(lng / 12.0 * Math.PI) + 300.0 * Math.sin(lng / 30.0 * Math.PI)) * 2.0 / 3.0;\r\n        return ret;\r\n    }\r\n    ;\r\n    /**\r\n     * 判断是否在国内，不在国内则不做偏移\r\n     * @remarks 此判断欠妥，暂不采用！\r\n     * @param lng\r\n     * @param lat\r\n     * @returns {boolean}\r\n     */\r\n    static out_of_china(lng, lat) {\r\n        // 纬度 3.86~53.55, 经度 73.66~135.05\r\n        return !(lng > 73.66 && lng < 135.05 && lat > 3.86 && lat < 53.55);\r\n    }\r\n    ;\r\n}\r\n/**\r\n * 地球半径\r\n */\r\nGCJ02.R = 6378137.0;\r\n/**\r\n * ee\r\n * @remarks\r\n * 不知含义的常数，用于WGS-84 与 GCJ-02 之间的转换\r\n */\r\nGCJ02.ee = 0.00669342162296594323;\r\n","import { Bound } from \"../util/bound\";\r\n/**\r\n * 坐标投影转换\r\n * @remarks\r\n * TODO: only support web mecator\r\n */\r\nexport class NoopProjection {\r\n    /**\r\n     * 经纬度转平面坐标\r\n     * @remarks 地理平面坐标 单位米\r\n     * @param {number} lng - 经度\r\n     * @param {number} lat - 纬度\r\n     * @return {number[]} 地理平面坐标\r\n     */\r\n    project([lng, lat]) { return [lng, lat]; }\r\n    ;\r\n    /**\r\n     * 平面坐标转经纬度\r\n     * @remarks 地理平面坐标 单位米\r\n     * @param {number} x - 地理平面坐标x\r\n     * @param {number} y - 地理平面坐标y\r\n     * @return {number[]} 经纬度\r\n     */\r\n    unproject([x, y], original = false) { return [x, y]; }\r\n    ;\r\n    /**\r\n     * 投影后的平面坐标范围\r\n     */\r\n    get bound() { return new Bound(0, 0, 256 * Math.pow(2, 3), 256 * Math.pow(2, 3)); }\r\n    ;\r\n}\r\n","/**\r\n * 经纬度坐标类型\r\n * @remarks\r\n * 本应无此一说，坐标偏移的无奈之举\r\n */\r\nexport var LatLngType;\r\n(function (LatLngType) {\r\n    /**\r\n     * GPS采集的经纬度坐标（Default）\r\n     */\r\n    LatLngType[LatLngType[\"GPS\"] = 1] = \"GPS\";\r\n    /**\r\n     * GCJ02偏移后的经纬度坐标（Default）\r\n     * Just For China, AMap aka GaoDe\r\n     */\r\n    LatLngType[LatLngType[\"GCJ02\"] = 2] = \"GCJ02\";\r\n    /**\r\n     * BD09偏移后的经纬度坐标（Default）\r\n     * Just For China, BaiduMap\r\n     */\r\n    LatLngType[LatLngType[\"BD09\"] = 3] = \"BD09\";\r\n})(LatLngType || (LatLngType = {}));\r\n/**\r\n * 坐标投影转换\r\n * @remarks\r\n * TODO: only support web mecator\r\n */\r\nexport class Projection {\r\n    /**\r\n     * 经纬度转平面坐标\r\n     * @remarks 地理平面坐标 单位米\r\n     * @param {number} lng - 经度\r\n     * @param {number} lat - 纬度\r\n     * @return {number[]} 地理平面坐标\r\n     */\r\n    project([lng, lat]) { return []; }\r\n    ;\r\n    /**\r\n     * 平面坐标转经纬度\r\n     * @remarks 地理平面坐标 单位米\r\n     * @param {number} x - 地理平面坐标x\r\n     * @param {number} y - 地理平面坐标y\r\n     * @return {number[]} 经纬度\r\n     */\r\n    unproject([x, y], original = false) { return []; }\r\n    ;\r\n    /**\r\n     * 投影后的平面坐标范围\r\n     */\r\n    get bound() { return null; }\r\n    ;\r\n}\r\n","import { Bound } from \"../util/bound\";\r\nimport { Projection } from \"./projection\";\r\n/**\r\n * 球体墨卡托\r\n */\r\nexport class WebMercator extends Projection {\r\n    /**\r\n     * 投影后的平面坐标范围\r\n     */\r\n    get bound() {\r\n        return new Bound(-Math.PI * WebMercator.R, Math.PI * WebMercator.R, Math.PI * WebMercator.R, -Math.PI * WebMercator.R);\r\n    }\r\n    /**\r\n     * 经纬度转平面坐标\r\n     * @remarks 地理平面坐标 单位米\r\n     * @param {number} lng - 经度\r\n     * @param {number} lat - 纬度\r\n     * @return {number[]} 地理平面坐标\r\n     */\r\n    project([lng, lat]) {\r\n        //from leaflet & wiki\r\n        const d = Math.PI / 180, sin = Math.sin(lat * d);\r\n        return [WebMercator.R * lng * d, WebMercator.R * Math.log((1 + sin) / (1 - sin)) / 2];\r\n    }\r\n    /**\r\n     * 平面坐标转经纬度\r\n     * @remarks 地理平面坐标 单位米\r\n     * @param {number} x - 地理平面坐标x\r\n     * @param {number} y - 地理平面坐标y\r\n     * @return {number[]} 经纬度\r\n     */\r\n    unproject([x, y], original = false) {\r\n        const d = 180 / Math.PI;\r\n        return [x * d / WebMercator.R, (2 * Math.atan(Math.exp(y / WebMercator.R)) - (Math.PI / 2)) * d];\r\n    }\r\n}\r\n/**\r\n * 地球半径\r\n */\r\nWebMercator.R = 6378137;\r\n","import { SimpleFillSymbol, SimpleLineSymbol, SimplePointSymbol } from \"../symbol/symbol\";\r\nimport { GeometryType } from \"../geometry/geometry\";\r\nimport { Color } from \"../util/color\";\r\n/**\r\n * 分类渲染项\r\n */\r\nexport class CategoryRendererItem {\r\n    constructor() {\r\n        /**\r\n         * 该类总数\r\n         */\r\n        this.count = 1;\r\n    }\r\n}\r\n/**\r\n * 分类渲染\r\n * @remarks\r\n * 一般可通过设置分类字段，再调用generate自动生成分类渲染项\r\n * 也可通过手动添加和定义分类渲染项，完成分类渲染设置，通过items.push()\r\n */\r\nexport class CategoryRenderer {\r\n    constructor() {\r\n        /**\r\n         * 所有分类集合\r\n         */\r\n        this._items = [];\r\n    }\r\n    /**\r\n     * 分类字段\r\n     * @remarks\r\n     * 一般为字符串字段，也可为枚举域值，或是非布尔值\r\n     */\r\n    get field() {\r\n        return this._field;\r\n    }\r\n    /**\r\n     * 所有分类集合\r\n     */\r\n    get items() {\r\n        return this._items;\r\n    }\r\n    /**\r\n     * 根据分类字段，自动生成分类渲染项\r\n     * @param {FeatureClass} featureClass - 要素类（要素集合）\r\n     * @param {Field} field - 分类字段\r\n     */\r\n    generate(featureClass, field) {\r\n        this._field = field;\r\n        this._items = [];\r\n        //分类统计\r\n        featureClass.features.map(feature => feature.properties[field.name]).forEach((value) => {\r\n            const item = this._items.find(item => item.value == value);\r\n            if (item) {\r\n                item.count += 1;\r\n            }\r\n            else {\r\n                const item = new CategoryRendererItem();\r\n                switch (featureClass.type) {\r\n                    case GeometryType.Point:\r\n                        const symbol1 = new SimplePointSymbol();\r\n                        symbol1.fillStyle = Color.random().toString();\r\n                        symbol1.strokeStyle = Color.random().toString();\r\n                        item.symbol = symbol1;\r\n                        item.value = value;\r\n                        this._items.push(item);\r\n                        break;\r\n                    case GeometryType.Polyline:\r\n                        const symbol2 = new SimpleLineSymbol();\r\n                        symbol2.strokeStyle = Color.random().toString();\r\n                        item.symbol = symbol2;\r\n                        item.value = value;\r\n                        this._items.push(item);\r\n                        break;\r\n                    case GeometryType.Polygon:\r\n                        const symbol3 = new SimpleFillSymbol();\r\n                        symbol3.fillStyle = Color.random().toString();\r\n                        symbol3.strokeStyle = Color.random().toString();\r\n                        item.symbol = symbol3;\r\n                        item.value = value;\r\n                        this._items.push(item);\r\n                        break;\r\n                }\r\n            }\r\n        });\r\n    }\r\n    getSymbol(feature) {\r\n        const item = this.items.find(item => item.value == feature.properties[this.field.name]);\r\n        if (item)\r\n            return item.symbol;\r\n    }\r\n}\r\n","import { SimpleFillSymbol, SimpleLineSymbol, SimplePointSymbol } from \"../symbol/symbol\";\r\nimport { GeometryType } from \"../geometry/geometry\";\r\nimport { Color } from \"../util/color\";\r\n/**\r\n * 分级渲染项\r\n * @remarks\r\n * 分级区间一般为( ]: 即下开上闭\r\n */\r\nexport class ClassRendererItem {\r\n}\r\n/**\r\n * 分级渲染\r\n * @remarks\r\n * 一般可通过设置分级字段，再调用generate自动生成分级渲染项\r\n * 也可通过手动添加和定义分级渲染项，完成分级渲染设置，通过items.push()\r\n */\r\nexport class ClassRenderer {\r\n    constructor() {\r\n        /**\r\n         * 所有分级渲染项集合\r\n         */\r\n        this._items = [];\r\n    }\r\n    /**\r\n     * 分级字段\r\n     * @remarks\r\n     * 必须为数值型\r\n     */\r\n    get field() {\r\n        return this._field;\r\n    }\r\n    /**\r\n     * 所有分级渲染项集合\r\n     */\r\n    get items() {\r\n        return this._items;\r\n    }\r\n    /**\r\n     * 自动生成分级渲染项\r\n     * @remarks\r\n     * TODO: 分级有多种方式，目前只实现均分\r\n     */\r\n    generate(featureClass, field, breaks) {\r\n        this._field = field;\r\n        this._items = [];\r\n        //获取该字段极值\r\n        const stat = featureClass.features.map(feature => feature.properties[field.name]).reduce((stat, cur) => {\r\n            stat.max = Math.max(cur, stat.max);\r\n            stat.min = Math.min(cur, stat.min);\r\n            return stat;\r\n        }, { min: Number.MAX_VALUE, max: Number.MIN_VALUE });\r\n        for (let i = 0; i < breaks; i++) {\r\n            const item = new ClassRendererItem();\r\n            switch (featureClass.type) {\r\n                case GeometryType.Point:\r\n                    const symbol1 = new SimplePointSymbol();\r\n                    symbol1.fillStyle = Color.random().toString();\r\n                    symbol1.strokeStyle = Color.random().toString();\r\n                    item.symbol = symbol1;\r\n                    item.low = stat.min + i * (stat.max - stat.min) / breaks;\r\n                    item.high = stat.min + (i + 1) * (stat.max - stat.min) / breaks;\r\n                    item.label = item.low + \" - \" + item.high;\r\n                    this._items.push(item);\r\n                    break;\r\n                case GeometryType.Polyline:\r\n                    const symbol2 = new SimpleLineSymbol();\r\n                    symbol2.strokeStyle = Color.random().toString();\r\n                    item.symbol = symbol2;\r\n                    item.low = stat.min + i * (stat.max - stat.min) / breaks;\r\n                    item.high = stat.min + (i + 1) * (stat.max - stat.min) / breaks;\r\n                    item.label = item.low + \" - \" + item.high;\r\n                    this._items.push(item);\r\n                    break;\r\n                case GeometryType.Polygon:\r\n                    const symbol3 = new SimpleFillSymbol();\r\n                    symbol3.fillStyle = Color.random().toString();\r\n                    symbol3.strokeStyle = Color.random().toString();\r\n                    item.symbol = symbol3;\r\n                    item.low = stat.min + i * (stat.max - stat.min) / breaks;\r\n                    item.high = stat.min + (i + 1) * (stat.max - stat.min) / breaks;\r\n                    item.label = item.low + \" - \" + item.high;\r\n                    this._items.push(item);\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n    getSymbol(feature) {\r\n        const item = this.items.find(item => item.low <= feature.properties[this.field.name] && item.high >= feature.properties[this.field.name]);\r\n        if (item)\r\n            return item.symbol;\r\n    }\r\n}\r\n","import { SimplePointSymbol } from \"../symbol/symbol\";\r\n/**\r\n * 点半径渲染\r\n * @remarks\r\n * 只适用点图层\r\n */\r\nexport class DotRenderer {\r\n    get field() {\r\n        return this._field;\r\n    }\r\n    set field(value) {\r\n        this._field = value;\r\n    }\r\n    getSymbol(feature) {\r\n        const symbol = new SimplePointSymbol();\r\n        symbol.radius = Number(feature.properties[this.field.name] || 0);\r\n        return symbol;\r\n    }\r\n}\r\n","import { SimplePointSymbol } from \"../symbol/symbol\";\r\nexport class Renderer {\r\n    getSymbol(feature) { return new SimplePointSymbol(); }\r\n}\r\n","/**\r\n * 单一渲染\r\n */\r\nexport class SimpleRenderer {\r\n    getSymbol(feature) {\r\n        return this.symbol;\r\n    }\r\n}\r\n","import { Color } from \"../util/color\";\r\n/**\r\n * 符号基类\r\n * @remarks\r\n * 如按现实世界来抽取对象基类，下述属性不应放在基类\r\n * 但考虑到Canvas的上下文设定，才决定抽取到基类\r\n */\r\nexport class Symbol {\r\n    constructor() {\r\n        /**\r\n         * 线宽\r\n         */\r\n        this.lineWidth = 1;\r\n        /**\r\n         * 描边样式\r\n         */\r\n        this.strokeStyle = \"#ff0000\";\r\n        /**\r\n         * 填充样式\r\n         */\r\n        this.fillStyle = \"#ff000088\";\r\n    }\r\n}\r\n/**\r\n * 点符号基类\r\n */\r\nexport class PointSymbol extends Symbol {\r\n    /**\r\n     * 绘制点（虚函数）\r\n     * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n     * @param {number} screenX - 屏幕坐标X\r\n     * @param {number} screenY - 屏幕坐标Y\r\n     */\r\n    draw(ctx, screenX, screenY) { }\r\n    /**\r\n     * 判断鼠标交互位置是否在符号范围内（虚函数）\r\n     * @param {number} anchorX - 鼠标交互位置X\r\n     * @param {number} anchorY - 鼠标交互位置Y\r\n     * @param {number} screenX - 点所在屏幕坐标X\r\n     * @param {number} screenY - 点所在屏幕坐标Y\r\n     */\r\n    contain(anchorX, anchorY, screenX, screenY) { return false; }\r\n}\r\n/**\r\n * 线符号基类\r\n */\r\nexport class LineSymbol extends Symbol {\r\n    /**\r\n     * 绘制线（虚函数）\r\n     * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n     * @param {number[][]} screen - 线对应坐标点的屏幕坐标集合\r\n     */\r\n    draw(ctx, screen) { }\r\n}\r\n/**\r\n * 面符号基类\r\n * @remarks\r\n * aka 填充符号\r\n */\r\nexport class FillSymbol extends Symbol {\r\n    /**\r\n     * 绘制面（虚函数）\r\n     * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n     * @param {number[][][]} screen - 面对应坐标点的屏幕坐标集合\r\n     */\r\n    draw(ctx, screen) { }\r\n}\r\n/**\r\n * 文本符号\r\n * @remarks\r\n * 常用于文本标注\r\n */\r\nexport class SimpleTextSymbol extends Symbol {\r\n    constructor() {\r\n        super(...arguments);\r\n        /**\r\n         * 边框宽\r\n         */\r\n        this.lineWidth = 3;\r\n        /**\r\n         * 边框色\r\n         */\r\n        this.strokeStyle = \"#ff0000\"; //#ffffff\r\n        /**\r\n         * 填充色\r\n         */\r\n        this.fillStyle = \"#ffffff\"; //#ffffff\r\n        /**\r\n         * X偏移\r\n         */\r\n        this.offsetX = 0;\r\n        /**\r\n         * Y偏移\r\n         */\r\n        this.offsetY = 1;\r\n        /**\r\n         * 周边留白\r\n         */\r\n        this.padding = 5;\r\n        /**\r\n         * 字体颜色\r\n         */\r\n        this.fontColor = \"#ff0000\";\r\n        /**\r\n         * 字体大小\r\n         */\r\n        this.fontSize = 12;\r\n        /**\r\n         * 字体\r\n         */\r\n        this.fontFamily = \"YaHei\";\r\n        /**\r\n         * 字体粗细\r\n         */\r\n        this.fontWeight = \"Bold\";\r\n        /**\r\n         * 放置位置\r\n         */\r\n        this.placement = \"BOTTOM\"; //BOTTOM TOP LEFT RIGHT\r\n        /**\r\n         * 自动调整位置\r\n         */\r\n        this.auto = false;\r\n        /**\r\n         * 标注点符号的宽度\r\n         */\r\n        this.pointSymbolWidth = 0;\r\n        /**\r\n         * 标注点符号的高度\r\n         */\r\n        this.pointSymbolHeight = 0;\r\n    }\r\n    /**\r\n     * 自动调整位置\r\n     * @remarks 按逆时针方向寻找合适位置\r\n     */\r\n    replacement() {\r\n        if (this.auto) {\r\n            switch (this.placement) {\r\n                case \"BOTTOM\":\r\n                    this.placement = \"RIGHT\";\r\n                    break;\r\n                case \"RIGHT\":\r\n                    this.placement = \"TOP\";\r\n                    break;\r\n                case \"TOP\":\r\n                    this.placement = \"LEFT\";\r\n                    break;\r\n                case \"LEFT\":\r\n                    this.placement = \"BOTTOM\";\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * 复制符号\r\n     */\r\n    copy(symbol) {\r\n        Object.keys(this).forEach(property => {\r\n            this[property] = symbol[property];\r\n        });\r\n    }\r\n}\r\n/**\r\n * 简单圆点符号\r\n * @remarks\r\n * 最常用的点符号\r\n */\r\nexport class SimplePointSymbol extends PointSymbol {\r\n    constructor() {\r\n        super(...arguments);\r\n        /**\r\n         * 圆点半径，像素值\r\n         */\r\n        this.radius = 6;\r\n    }\r\n    /**\r\n     * 绘制点\r\n     * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n     * @param {number} screenX - 屏幕坐标X\r\n     * @param {number} screenY - 屏幕坐标Y\r\n     */\r\n    draw(ctx, screenX, screenY) {\r\n        ctx.save();\r\n        ctx.strokeStyle = this.strokeStyle;\r\n        ctx.fillStyle = this.fillStyle;\r\n        ctx.lineWidth = this.lineWidth;\r\n        ctx.beginPath(); //Start path\r\n        //keep size\r\n        //地理坐标 转回 屏幕坐标\r\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n        ctx.arc(screenX, screenY, this.radius, 0, Math.PI * 2, true);\r\n        ctx.fill();\r\n        ctx.stroke();\r\n        ctx.restore();\r\n    }\r\n    /**\r\n     * 判断鼠标交互位置是否在符号范围内\r\n     * @param {number} anchorX - 鼠标交互位置X\r\n     * @param {number} anchorY - 鼠标交互位置Y\r\n     * @param {number} screenX - 点所在屏幕坐标X\r\n     * @param {number} screenY - 点所在屏幕坐标Y\r\n     */\r\n    contain(anchorX, anchorY, screenX, screenY) {\r\n        return Math.sqrt((anchorX - screenX) * (anchorX - screenX) + (anchorY - screenY) * (anchorY - screenY)) <= this.radius;\r\n    }\r\n}\r\n/**\r\n * 渐变圆点符号\r\n * @remarks\r\n * 最常用的点符号\r\n */\r\nexport class GradientPointSymbol extends PointSymbol {\r\n    constructor() {\r\n        super(...arguments);\r\n        /**\r\n         * 圆点半径，像素值\r\n         */\r\n        this.radius = 6;\r\n        /**\r\n         * 重写线宽，推荐为0\r\n         */\r\n        this.lineWidth = 0;\r\n        /**\r\n         * 渐变起始色\r\n         */\r\n        this.startColor = \"#ff0000\"; //#ff0000\r\n        /**\r\n         * 渐变终止色\r\n         */\r\n        this.endColor = \"#ff0000\"; //#ff0000\r\n    }\r\n    /**\r\n     * 绘制点\r\n     * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n     * @param {number} screenX - 屏幕坐标X\r\n     * @param {number} screenY - 屏幕坐标Y\r\n     */\r\n    draw(ctx, screenX, screenY) {\r\n        ctx.save();\r\n        //keep size\r\n        //地理坐标 转回 屏幕坐标\r\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n        ctx.lineWidth = this.lineWidth;\r\n        ctx.strokeStyle = this.strokeStyle;\r\n        const radgrad = ctx.createRadialGradient(screenX, screenY, 0, screenX, screenY, this.radius);\r\n        radgrad.addColorStop(0, this.startColor);\r\n        radgrad.addColorStop(1, this.endColor);\r\n        ctx.fillStyle = radgrad;\r\n        ctx.lineWidth = this.lineWidth;\r\n        ctx.beginPath(); //Start path\r\n        ctx.arc(screenX, screenY, this.radius, 0, Math.PI * 2, true);\r\n        ctx.fill();\r\n        //ctx.stroke();\r\n        ctx.restore();\r\n    }\r\n    /**\r\n     * 判断鼠标交互位置是否在符号范围内\r\n     * @param {number} anchorX - 鼠标交互位置X\r\n     * @param {number} anchorY - 鼠标交互位置Y\r\n     * @param {number} screenX - 点所在屏幕坐标X\r\n     * @param {number} screenY - 点所在屏幕坐标Y\r\n     */\r\n    contain(anchorX, anchorY, screenX, screenY) {\r\n        return Math.sqrt((anchorX - screenX) * (anchorX - screenX) + (anchorY - screenY) * (anchorY - screenY)) <= this.radius;\r\n    }\r\n}\r\n/**\r\n * 简单线符号\r\n * @remarks\r\n * 最常用的线符号\r\n */\r\nexport class SimpleLineSymbol extends LineSymbol {\r\n    /**\r\n     * 绘制线\r\n     * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n     * @param {number[][]} screen - 线对应坐标点的屏幕坐标集合\r\n     */\r\n    draw(ctx, screen) {\r\n        if (screen.length < 2)\r\n            return;\r\n        ctx.save();\r\n        ctx.strokeStyle = this.strokeStyle;\r\n        ctx.lineWidth = this.lineWidth;\r\n        //keep lineWidth\r\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n        ctx.beginPath();\r\n        screen.forEach((point, index) => {\r\n            const screenX = point[0], screenY = point[1];\r\n            if (index === 0) {\r\n                ctx.moveTo(screenX, screenY);\r\n            }\r\n            else {\r\n                ctx.lineTo(screenX, screenY);\r\n            }\r\n        });\r\n        ctx.stroke();\r\n        ctx.restore();\r\n    }\r\n}\r\n/**\r\n * 简单面符号\r\n * @remarks\r\n * 最常用的面填充符号\r\n */\r\nexport class SimpleFillSymbol extends Symbol {\r\n    constructor() {\r\n        super(...arguments);\r\n        /**\r\n         * 重写线宽默认值，基类为1，按需设置，可省略\r\n         */\r\n        this.lineWidth = 2;\r\n    }\r\n    /**\r\n     * 绘制面\r\n     * @remarks\r\n     * 奇偶填充\r\n     * https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/fill\r\n     * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n     * @param {number[][][]} screen - 面对应坐标点的屏幕坐标集合\r\n     */\r\n    draw(ctx, screen) {\r\n        ctx.save();\r\n        ctx.strokeStyle = this.strokeStyle;\r\n        ctx.fillStyle = this.fillStyle;\r\n        ctx.lineWidth = this.lineWidth;\r\n        //keep lineWidth\r\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n        //TODO:  exceeding the maximum extent(bound), best way is overlap by extent. find out: maximum is [-PI*R, PI*R]??\r\n        ctx.beginPath();\r\n        screen.forEach(ring => {\r\n            if (ring.length < 3)\r\n                return;\r\n            ring.forEach((point, index) => {\r\n                const screenX = point[0], screenY = point[1];\r\n                if (index === 0) {\r\n                    ctx.moveTo(screenX, screenY);\r\n                }\r\n                else {\r\n                    ctx.lineTo(screenX, screenY);\r\n                }\r\n            });\r\n        });\r\n        ctx.closePath();\r\n        //奇偶填充\r\n        //https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/fill\r\n        ctx.fill(\"evenodd\");\r\n        ctx.stroke();\r\n        ctx.restore();\r\n    }\r\n}\r\n/**\r\n * 图标符号\r\n * @remarks\r\n * 常用于POI兴趣点的渲染\r\n */\r\nexport class SimpleMarkerSymbol extends PointSymbol {\r\n    constructor() {\r\n        super(...arguments);\r\n        /**\r\n         * 宽\r\n         */\r\n        this.width = 16;\r\n        /**\r\n         * 高\r\n         */\r\n        this.height = 16;\r\n        /**\r\n         * offset，坐标点对应图标的位置\r\n         * 例如，宽16px，高16px，offsetX为-8，offsetY为-8，意味着：\r\n         * 该图标的中心点对应渲染点的坐标。\r\n         */\r\n        this.offsetX = -8;\r\n        /**\r\n         * offset，坐标点对应图标的位置\r\n         * 例如，宽16px，高16px，offsetX为-8，offsetY为-8，意味着：\r\n         * 该图标的中心点对应渲染点的坐标。\r\n         */\r\n        this.offsetY = -8;\r\n    }\r\n    /**\r\n     * 记录是否已完成异步图标加载\r\n     */\r\n    get loaded() {\r\n        return this._loaded;\r\n    }\r\n    /**\r\n     * 异步加载图标\r\n     * @return {Color} 生成随机色带\r\n     */\r\n    load() {\r\n        return new Promise((resolve, reject) => {\r\n            let img = new Image();\r\n            img.onload = () => {\r\n                createImageBitmap(img).then(icon => {\r\n                    this.icon = icon;\r\n                    this._loaded = true;\r\n                    resolve(icon);\r\n                }, err => reject(err));\r\n            };\r\n            img.onerror = reject;\r\n            img.src = this.url;\r\n        });\r\n    }\r\n    /**\r\n     * 绘制图标\r\n     * @remarks\r\n     * 注意异步加载\r\n     * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n     * @param {number} screenX - 屏幕坐标X\r\n     * @param {number} screenY - 屏幕坐标Y\r\n     */\r\n    draw(ctx, screenX, screenY) {\r\n        if (!this._loaded) {\r\n            this.image = new Image();\r\n            this.image.src = this.url;\r\n            this._loaded = true;\r\n        }\r\n        ;\r\n        ctx.save();\r\n        //const matrix = (ctx as any).getTransform();\r\n        //keep size\r\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n        //请对应参考offset属性的描述内容\r\n        ctx.drawImage(this.icon || this.image, screenX + this.offsetX, screenY + this.offsetY, this.width, this.height);\r\n        ctx.restore();\r\n    }\r\n    /**\r\n     * 判断鼠标交互位置是否在符号范围内\r\n     * @param {number} anchorX - 鼠标交互位置X\r\n     * @param {number} anchorY - 鼠标交互位置Y\r\n     * @param {number} screenX - 点所在屏幕坐标X\r\n     * @param {number} screenY - 点所在屏幕坐标Y\r\n     */\r\n    contain(anchorX, anchorY, screenX, screenY) {\r\n        return screenX >= (anchorX + this.offsetX) && screenX <= (anchorX + this.offsetX + this.width) && screenY >= (anchorY + this.offsetY) && screenY <= (anchorY + this.offsetY + this.height);\r\n    }\r\n}\r\n/**\r\n * 字符符号\r\n * @remarks\r\n * 中英文皆可，注意控制长度，推荐单个字符\r\n */\r\nexport class LetterSymbol extends PointSymbol {\r\n    constructor() {\r\n        super(...arguments);\r\n        /**\r\n         * 外圈半径\r\n         */\r\n        this.radius = 10;\r\n        /**\r\n         * 字符，中英文皆可，推荐单个字符\r\n         */\r\n        this.letter = \"\";\r\n        /**\r\n         * 字体颜色\r\n         */\r\n        this.fontColor = \"#ff0000\";\r\n        /**\r\n         * 字体大小\r\n         */\r\n        this.fontSize = 12;\r\n        /**\r\n         * 字体\r\n         */\r\n        this.fontFamily = \"YaHei\";\r\n        /**\r\n         * 字体粗细\r\n         */\r\n        this.fontWeight = \"Bold\";\r\n    }\r\n    /**\r\n     * 绘制字符符号\r\n     * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n     * @param {number} screenX - 屏幕坐标X\r\n     * @param {number} screenY - 屏幕坐标Y\r\n     */\r\n    draw(ctx, screenX, screenY) {\r\n        ctx.save();\r\n        ctx.strokeStyle = this.strokeStyle;\r\n        ctx.fillStyle = this.fillStyle;\r\n        ctx.lineWidth = this.lineWidth;\r\n        ctx.beginPath(); //Start path\r\n        //keep size\r\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n        //绘制外圈\r\n        ctx.arc(screenX, screenY, this.radius, 0, Math.PI * 2, true);\r\n        ctx.fill();\r\n        ctx.stroke();\r\n        ctx.textBaseline = \"middle\";\r\n        ctx.textAlign = \"center\";\r\n        ctx.fillStyle = this.fontColor;\r\n        ctx.font = this.fontSize + \"px/1 \" + this.fontFamily + \" \" + this.fontWeight;\r\n        //绘制字符\r\n        ctx.fillText(this.letter, screenX, screenY);\r\n        ctx.restore();\r\n    }\r\n    /**\r\n     * 判断鼠标交互位置是否在符号范围内\r\n     * @param {number} anchorX - 鼠标交互位置X\r\n     * @param {number} anchorY - 鼠标交互位置Y\r\n     * @param {number} screenX - 点所在屏幕坐标X\r\n     * @param {number} screenY - 点所在屏幕坐标Y\r\n     */\r\n    contain(anchorX, anchorY, screenX, screenY) {\r\n        return Math.sqrt((anchorX - screenX) * (anchorX - screenX) + (anchorY - screenY) * (anchorY - screenY)) <= this.radius;\r\n    }\r\n}\r\n/**\r\n * 箭头符号\r\n */\r\nexport class ArrowSymbol extends Symbol {\r\n    constructor() {\r\n        super(...arguments);\r\n        /**\r\n         * 线宽\r\n         */\r\n        this.lineWidth = 2;\r\n        /**\r\n         * 决定绘制箭头的最小线长\r\n         * @remarks 屏幕坐标，单位pixel\r\n         * 默认 >50pixels will draw arrow\r\n         */\r\n        this.minLength = 50;\r\n        /**\r\n         * 箭翼长度\r\n         */\r\n        this.arrowLength = 10;\r\n        /**\r\n         * 箭翼夹角\r\n         * @remarks 默认 angle 30 = Math.PI / 6\r\n         */\r\n        this.arrowAngle = Math.PI / 6;\r\n    }\r\n    /**\r\n     * 绘制线\r\n     * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n     * @param {number[][]} screen - 线对应坐标点的屏幕坐标集合\r\n     */\r\n    draw(ctx, screen) {\r\n        ctx.save();\r\n        ctx.strokeStyle = this.strokeStyle;\r\n        ctx.lineWidth = this.lineWidth;\r\n        //keep lineWidth\r\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n        ctx.beginPath();\r\n        screen.forEach((point, index) => {\r\n            const screenX = point[0], screenY = point[1];\r\n            if (index === 0) {\r\n                ctx.moveTo(screenX, screenY);\r\n            }\r\n            else {\r\n                ctx.lineTo(screenX, screenY);\r\n            }\r\n        });\r\n        ctx.stroke();\r\n        //已知 起点和终点  求沿线距起点定长的点\r\n        const _getPointAlongLine = (p1, p2, d) => {\r\n            //line length\r\n            let l = Math.sqrt((p2[0] - p1[0]) * (p2[0] - p1[0]) + (p2[1] - p1[1]) * (p2[1] - p1[1]));\r\n            let t = d / l;\r\n            return [(1 - t) * p1[0] + t * p2[0], (1 - t) * p1[1] + t * p2[1]];\r\n        };\r\n        //已知 起点 y = kx + b   求沿线距起点定长的点 两个点\r\n        const _getPointAlongLine2 = (k, b, p, d) => {\r\n            let x0 = p[0] + Math.sqrt((d * d) / (k * k + 1)), x1 = p[0] - Math.sqrt((d * d) / (k * k + 1));\r\n            return [[x0, k * x0 + b], [x1, k * x1 + b]];\r\n        };\r\n        screen.reduce((prev, cur) => {\r\n            if (prev) {\r\n                const length = Math.sqrt((cur[0] - prev[0]) * (cur[0] - prev[0]) + (cur[1] - prev[1]) * (cur[1] - prev[1]));\r\n                if (length >= this.minLength) {\r\n                    //中点 即箭头\r\n                    const [middleX, middleY] = [(prev[0] + cur[0]) / 2, (prev[1] + cur[1]) / 2];\r\n                    //箭尾垂线的垂足\r\n                    const [footX, footY] = _getPointAlongLine([middleX, middleY], prev, Math.cos(this.arrowAngle) * this.arrowLength);\r\n                    const k = (cur[1] - prev[1]) / (cur[0] - prev[0]);\r\n                    // 1/k 垂线\r\n                    const points = _getPointAlongLine2(-1 / k, footY - footX * -1 / k, [footX, footY], Math.sin(this.arrowAngle) * this.arrowLength);\r\n                    //两点\r\n                    points.forEach(point => {\r\n                        ctx.beginPath();\r\n                        ctx.moveTo(middleX, middleY);\r\n                        ctx.lineTo(point[0], point[1]);\r\n                        ctx.stroke();\r\n                    });\r\n                }\r\n                return cur;\r\n            }\r\n            else {\r\n                return cur;\r\n            }\r\n        });\r\n        ctx.restore();\r\n    }\r\n}\r\n/**\r\n * 聚合符号\r\n * @remarks\r\n * 限制用于点图层\r\n */\r\nexport class ClusterSymbol extends PointSymbol {\r\n    /**\r\n     * 创建聚合符号\r\n     * @param {number} count - 聚合数量\r\n     */\r\n    constructor(count) {\r\n        super();\r\n        /**\r\n         * 聚合数量\r\n         */\r\n        this._count = 2;\r\n        /**\r\n         * 聚合符号的默认半径\r\n         */\r\n        this.radius = 10;\r\n        /**\r\n         * 重写描边样式\r\n         */\r\n        this.strokeStyle = \"#ffffff\"; //#ff0000\r\n        /**\r\n         * 聚合外圈填充样式\r\n         */\r\n        this.outerFillStyle = \"#ffffff\"; //#ff0000\r\n        /**\r\n         * 聚合数量字体颜色\r\n         */\r\n        this.fontColor = \"#ffffff\";\r\n        /**\r\n         * 聚合数量字体\r\n         */\r\n        this.fontFamily = \"YaHei\";\r\n        /**\r\n         * 聚合数量字体粗细\r\n         */\r\n        this.fontWeight = \"Bold\";\r\n        /**\r\n         * 色带起始色\r\n         */\r\n        this.startColor = \"#19caad\";\r\n        /**\r\n         * 色带终止色\r\n         */\r\n        this.endColor = \"#f4606c\";\r\n        this._count = count;\r\n    }\r\n    /**\r\n     * 聚合数量文本\r\n     * @remarks\r\n     * 大于99，标记为99+\r\n     */\r\n    get text() {\r\n        return this._count <= 99 ? this._count.toString() : \"99+\";\r\n    }\r\n    /**\r\n     * 内圈半径\r\n     */\r\n    get inner() {\r\n        return this._count <= 15 ? this.radius + this._count : this.radius + 15;\r\n    }\r\n    /**\r\n     * 外圈半径\r\n     */\r\n    get outer() {\r\n        return this.inner + 4;\r\n    }\r\n    /**\r\n     * 字体随数量递增，同时控制为非无限递增\r\n     */\r\n    get fontSize() {\r\n        if (this._count < 10) {\r\n            return 12;\r\n        }\r\n        else if (this._count >= 10 && this._count < 30) {\r\n            return 14;\r\n        }\r\n        else if (this._count >= 30 && this._count < 50) {\r\n            return 16;\r\n        }\r\n        else if (this._count >= 30 && this._count < 50) {\r\n            return 18;\r\n        }\r\n        else if (this._count > 50) {\r\n            return 20;\r\n        }\r\n    }\r\n    /**\r\n     * 聚合的内圈填充样式\r\n     * @remarks\r\n     * 采用色带，色带可自定义扩展\r\n     */\r\n    get innerFillStyle() {\r\n        //TODO 优化 setter hex, getter color\r\n        const colors = Color.ramp(Color.fromHex(this.startColor), Color.fromHex(this.endColor), 16);\r\n        return colors[this._count <= 15 ? this._count : 15].toString();\r\n    }\r\n    /**\r\n     * 绘制聚合符号\r\n     * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n     * @param {number} screenX - 屏幕坐标X\r\n     * @param {number} screenY - 屏幕坐标Y\r\n     */\r\n    draw(ctx, screenX, screenY) {\r\n        ctx.save();\r\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n        ctx.strokeStyle = this.strokeStyle;\r\n        ctx.fillStyle = this.outerFillStyle;\r\n        ctx.lineWidth = this.lineWidth;\r\n        ctx.beginPath(); //Start path\r\n        //keep size 画外圈\r\n        ctx.arc(screenX, screenY, this.outer, 0, Math.PI * 2, true);\r\n        ctx.fill();\r\n        ctx.stroke();\r\n        ctx.fillStyle = this.innerFillStyle;\r\n        ctx.beginPath(); //Start path\r\n        //keep size 画内圈\r\n        ctx.arc(screenX, screenY, this.inner, 0, Math.PI * 2, true);\r\n        ctx.fill();\r\n        ctx.stroke();\r\n        ctx.textBaseline = \"middle\";\r\n        ctx.textAlign = \"center\";\r\n        ctx.fillStyle = this.fontColor;\r\n        ctx.font = this.fontSize + \"px/1 \" + this.fontFamily + \" \" + this.fontWeight;\r\n        ctx.fillText(this.text, screenX, screenY);\r\n        ctx.restore();\r\n    }\r\n}\r\n/**\r\n * Vertex符号\r\n * @remarks\r\n * 限制用于编辑器，当编辑要素激活时，点对应点坐标，线和面对应坐标点集合，拐点的渲染符号，默认为正方形\r\n */\r\nexport class VertexSymbol extends PointSymbol {\r\n    constructor() {\r\n        super(...arguments);\r\n        /**\r\n         * 正方形边长\r\n         */\r\n        this.size = 10;\r\n    }\r\n    /**\r\n     * 绘制Vertex符号\r\n     * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n     * @param {number} screenX - 屏幕坐标X\r\n     * @param {number} screenY - 屏幕坐标Y\r\n     */\r\n    draw(ctx, screenX, screenY) {\r\n        ctx.save();\r\n        ctx.strokeStyle = this.strokeStyle;\r\n        ctx.fillStyle = this.fillStyle;\r\n        ctx.lineWidth = this.lineWidth;\r\n        ctx.beginPath(); //Start path\r\n        //keep size\r\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n        const size = this.size;\r\n        ctx.rect(screenX - size / 2, screenY - size / 2, size, size);\r\n        ctx.fill();\r\n        ctx.stroke();\r\n        ctx.restore();\r\n    }\r\n    /**\r\n     * 判断鼠标交互位置是否在符号范围内\r\n     * @param {number} anchorX - 鼠标交互位置X\r\n     * @param {number} anchorY - 鼠标交互位置Y\r\n     * @param {number} screenX - 点所在屏幕坐标X\r\n     * @param {number} screenY - 点所在屏幕坐标Y\r\n     */\r\n    contain(anchorX, anchorY, screenX, screenY) {\r\n        return screenX >= (anchorX - this.size / 2) && screenX <= (anchorX + this.size / 2) && screenY >= (anchorY - this.size / 2) && screenY <= (anchorY + this.size / 2);\r\n    }\r\n}\r\n","import { Subject } from \"./util/subject\";\r\n/**\r\n * 栅格切片管理器\r\n * 已内置于map，可通过map的接口进行添加删除的维护操作\r\n */\r\nexport class Tile extends Subject {\r\n    /**\r\n     * 创建Tile\r\n     * 不应自主创建，map内部创建\r\n     * @param {Map} map - 地图容器\r\n     */\r\n    constructor(map) {\r\n        super([\"mouseover\", \"mouseout\"]); //when mouseover feature\r\n        this._map = map;\r\n        const container = map.container;\r\n        //create div\r\n        this._container = document.createElement(\"div\");\r\n        this._container.style.cssText = \"position: absolute; height: 100%; width: 100%; z-index: 80\";\r\n        container.appendChild(this._container);\r\n        this._extentChange = this._extentChange.bind(this);\r\n        this._map.on(\"extent\", this._extentChange);\r\n    }\r\n    /**\r\n     * 图层url\r\n     */\r\n    get url() {\r\n        return this._url;\r\n    }\r\n    /**\r\n     * 图层url\r\n     */\r\n    set url(value) {\r\n        this._url = value;\r\n    }\r\n    //与主视图同步\r\n    _extentChange(event) {\r\n        this.redraw();\r\n    }\r\n    /**\r\n     * 重绘\r\n     */\r\n    redraw() {\r\n        if (!this._url)\r\n            return;\r\n        const lngLat2Tile = (lng, lat, z) => {\r\n            let tileX = Math.floor((lng + 180) / 360 * Math.pow(2, z));\r\n            let tileY = Math.floor((1 / 2 - (Math.log(Math.tan(lat * Math.PI / 180) + 1 / Math.cos(lat * Math.PI / 180))) / (2 * Math.PI)) * Math.pow(2, z));\r\n            return [tileX, tileY];\r\n        };\r\n        const lngLat2Pixel = (lng, lat, z) => {\r\n            let pixelX = Math.floor(((lng + 180) / 360 * Math.pow(2, z) * 256) % 256);\r\n            let pixelY = Math.floor(((1 - (Math.log(Math.tan(lat * Math.PI / 180) + 1 / Math.cos(lat * Math.PI / 180))) / (2 * Math.PI)) * Math.pow(2, z) * 256) % 256);\r\n            return [pixelX, pixelY];\r\n        };\r\n        const getUrl = (url, x, y, z) => {\r\n            return url.replace(\"{x}\", x).replace(\"{y}\", y).replace(\"{z}\", z);\r\n        };\r\n        const projection = this._map.projection;\r\n        const extent = this._map.extent;\r\n        const zoom = this._map.zoom;\r\n        const [lng1, lat1] = projection.unproject([extent.xmin, extent.ymax]);\r\n        const [lng2, lat2] = projection.unproject([extent.xmax, extent.ymin]);\r\n        const [tileMinX, tileMinY] = lngLat2Tile(lng1, lat1, zoom);\r\n        const [tileMaxX, tileMaxY] = lngLat2Tile(lng2, lat2, zoom);\r\n        const [pixelX, pixelY] = lngLat2Pixel(lng1, lat1, zoom);\r\n        this._container.innerHTML = \"\";\r\n        for (let x = tileMinX; x <= tileMaxX; x++) {\r\n            for (let y = tileMinY; y <= tileMaxY; y++) {\r\n                const url = getUrl(this._url, x, y, zoom);\r\n                let tile = document.createElement('img');\r\n                tile.alt = '';\r\n                tile.setAttribute('role', 'presentation');\r\n                tile.style.width = '256px';\r\n                tile.style.height = '256px';\r\n                tile.style.position = 'absolute';\r\n                tile.src = url;\r\n                tile.style.left = (-pixelX + (x - tileMinX) * 256) + 'px';\r\n                tile.style.top = (-pixelY + (y - tileMinY) * 256) + 'px';\r\n                this._container.appendChild(tile);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * 销毁\r\n     */\r\n    destroy() {\r\n        this._map.off(\"extent\", this._extentChange);\r\n    }\r\n}\r\n","import { Utility } from \"../util/utility\";\r\n/**\r\n * Tooltip\r\n */\r\nexport class Tooltip {\r\n    /**\r\n     * 创建Tooltip\r\n     * @param {Map} map - 地图容器\r\n     */\r\n    constructor(map) {\r\n        this._map = map;\r\n        const container = this._map.container;\r\n        this._tooltipContainer = document.createElement(\"div\");\r\n        Utility.addClass(this._tooltipContainer, \"green-tooltip\");\r\n        //Utility.addClass(this._tooltipContainer, \"green-tooltip-placement-top\");\r\n        container.appendChild(this._tooltipContainer);\r\n        this._tooltipArrow = document.createElement(\"div\");\r\n        Utility.addClass(this._tooltipArrow, \"green-tooltip-arrow\");\r\n        //Utility.addClass(this._tooltipArrow, \"green-tooltip-arrow-placement-top\");\r\n        this._tooltipContainer.appendChild(this._tooltipArrow);\r\n        this._tooltipText = document.createElement(\"div\");\r\n        Utility.addClass(this._tooltipText, \"green-tooltip-text\");\r\n        this._tooltipContainer.appendChild(this._tooltipText);\r\n    }\r\n    /**\r\n     * 显示Tooltip\r\n     * 设置限高\r\n     * 小于限高，显示在上方\r\n     * 超出限高，显示在下方\r\n     * @param {string | HTMLElement} text - HTMLElement | string\r\n     * @param {number} screenX - 屏幕坐标X\r\n     * @param {number} screenY - 屏幕坐标Y\r\n     * @param {number} height - 设置限高\r\n     */\r\n    show(text, screenX, screenY, height) {\r\n        if (typeof text === 'string') {\r\n            this._tooltipText.innerHTML = text;\r\n        }\r\n        else {\r\n            const node = this._tooltipText;\r\n            while (node.hasChildNodes()) {\r\n                node.removeChild(node.firstChild);\r\n            }\r\n            node.appendChild(text);\r\n        }\r\n        //this._tooltip.style.cssText = \"display: block; left: \" + (screenX - this._tooltip.offsetWidth / 2) + \"px; top: \" + (screenY - this._tooltip.offsetHeight) + \"px;\";\r\n        Utility.removeClass(this._tooltipContainer, \"green-tooltip-placement-top\");\r\n        Utility.removeClass(this._tooltipContainer, \"green-tooltip-placement-bottom\");\r\n        Utility.removeClass(this._tooltipArrow, \"green-tooltip-arrow-placement-top\");\r\n        Utility.removeClass(this._tooltipArrow, \"green-tooltip-arrow-placement-bottom\");\r\n        if (screenY < (height || this._tooltipContainer.offsetHeight)) {\r\n            Utility.addClass(this._tooltipContainer, \"green-tooltip-placement-bottom\");\r\n            Utility.addClass(this._tooltipArrow, \"green-tooltip-arrow-placement-bottom\");\r\n        }\r\n        else {\r\n            Utility.addClass(this._tooltipContainer, \"green-tooltip-placement-top\");\r\n            Utility.addClass(this._tooltipArrow, \"green-tooltip-arrow-placement-top\");\r\n        }\r\n        this._tooltipContainer.style.cssText = \"display: block; left: \" + (screenX) + \"px; top: \" + (screenY) + \"px;\";\r\n    }\r\n    /**\r\n     * 隐藏Tooltip\r\n     */\r\n    hide() {\r\n        this._tooltipContainer.style.cssText = \"display: none\";\r\n    }\r\n}\r\n","/**\r\n * 边界类，用在包络矩形，以及投影的平面坐标边界\r\n * @remarks\r\n * 考虑此处代码影响较多内容，故暂不大变动，沿用设计时的定义：\r\n * 屏幕坐标系的设定：x正方向为自左向右，y正方向为自上向下，因此与常规笛卡尔坐标系中的y正方向相反，请重点注意\r\n * 故，如传入常规笛卡尔坐标系的坐标，请将ymin与ymax颠倒(即y坐标的最大值传给ymin，最小值传给ymax)，以便于程序设置yscale为-1\r\n * 当然，如表示的是屏幕坐标范围与边界，正常传入：ymin最小值，ymax最大值。\r\n */\r\nexport class Bound {\r\n    /**\r\n     * 创建包络矩形\r\n     * @param {number} xmin - x方向靠左极值\r\n     * @param {number} ymin - y方向上方极值\r\n     * @param {number} xmax - x方向靠右极值\r\n     * @param {number} ymax - y方向下方极值\r\n     */\r\n    constructor(xmin, ymin, xmax, ymax) {\r\n        //+1代表 x方向为自左向右，-1则反之\r\n        this._xscale = 1;\r\n        //+1代表 y方向为自上向下，-1则反之\r\n        this._yscale = 1;\r\n        this._xmin = Math.min(xmin, xmax);\r\n        this._ymin = Math.min(ymin, ymax);\r\n        this._xmax = Math.max(xmin, xmax);\r\n        this._ymax = Math.max(ymin, ymax);\r\n        this._xscale = xmin <= xmax ? 1 : -1;\r\n        this._yscale = ymin <= ymax ? 1 : -1;\r\n    }\r\n    /**\r\n     * x方向最小值（应为靠左极值）\r\n     * @return {number} x方向靠左极值\r\n     */\r\n    get xmin() {\r\n        return this._xmin;\r\n    }\r\n    /**\r\n     * y方向最小值（应为上方极值）\r\n     * @return {number} y方向上方极值\r\n     */\r\n    get ymin() {\r\n        return this._ymin;\r\n    }\r\n    /**\r\n     * x方向最大值（应为靠右极值）\r\n     * @return {number} x方向靠右极值\r\n     */\r\n    get xmax() {\r\n        return this._xmax;\r\n    }\r\n    /**\r\n     * y方向最大值（应为下方极值）\r\n     * @return {number} y方向下方极值\r\n     */\r\n    get ymax() {\r\n        return this._ymax;\r\n    }\r\n    /**\r\n     * +1代表 x方向为自左向右，-1则反之\r\n     * @return {number} x方向\r\n     */\r\n    get xscale() {\r\n        return this._xscale;\r\n    }\r\n    /**\r\n     * +1代表 y方向为自上向下，-1则反之\r\n     * @return {number} y方向\r\n     */\r\n    get yscale() {\r\n        return this._yscale;\r\n    }\r\n    /**\r\n     * 包络矩形中心点坐标数组\r\n     * @return {number[]} 中心点坐标数组[x,y]\r\n     */\r\n    getCenter() {\r\n        return [(this._xmin + this._xmax) / 2, (this._ymin + this._ymax) / 2];\r\n    }\r\n    /**\r\n     * 是否交叉叠盖\r\n     * @param {Bound} bound - 交叉叠盖检测对象\r\n     * @return {boolean} 是否交叉叠盖\r\n     */\r\n    intersect(bound) {\r\n        return (bound.xmax >= this._xmin) && (bound.xmin <= this._xmax) && (bound.ymax >= this._ymin) && (bound.ymin <= this._ymax);\r\n    }\r\n    /**\r\n     * 缩放整个边界\r\n     * @param {number} s - 缩放倍数\r\n     */\r\n    scale(s) {\r\n        this._xmin = this._xmin - (s - 1) * (this._xmax - this._xmin) / 2;\r\n        this._xmax = this._xmax + (s - 1) * (this._xmax - this._xmin) / 2;\r\n        this._ymin = this._ymin - (s - 1) * (this._ymax - this._ymin) / 2;\r\n        this._ymax = this._ymax + (s - 1) * (this._ymax - this._ymin) / 2;\r\n    }\r\n    /**\r\n     * 缓冲整个边界，类似拓宽\r\n     * @param {number} size - 拓宽相应尺寸\r\n     */\r\n    buffer(size) {\r\n        this._xmin -= size;\r\n        this._ymin -= size;\r\n        this._xmax += size;\r\n        this._ymax += size;\r\n    }\r\n}\r\n","/**\r\n * 颜色工具类\r\n * @remarks\r\n * 此处有太多可扩展内容，如更优雅的生成色带，给色带更多的配置项等等\r\n * 但由于相关内容，并非GIS API的关注重点，故未花太多精力扩展此内容\r\n * 各位可根据项目需求，自行发挥，达到更优雅美观的颜色渲染效果。\r\n * TODO: a lot of things to be done\r\n */\r\nexport class Color {\r\n    /**\r\n     * 创建颜色\r\n     * @param {number} r - red\r\n     * @param {number} g - green\r\n     * @param {number} b - blue\r\n     * @param {number} a - alpha\r\n     */\r\n    constructor(r, g, b, a = 1) {\r\n        /**\r\n         * alpha\r\n         */\r\n        this.a = 1;\r\n        this.r = r;\r\n        this.g = g;\r\n        this.b = b;\r\n        this.a = a;\r\n    }\r\n    /**\r\n     * 输出rgba值\r\n     * @return {string} rgba\r\n     */\r\n    toString() {\r\n        return \"rgba(\" + this.r + \",\" + this.g + \",\" + this.b + \",\" + this.a + \")\";\r\n    }\r\n    /**\r\n     * 16进制表示法颜色 转十进制 R G B\r\n     * @param {string} hex - 十六进制 #ffffff\r\n     * @return {string} 十进制 R G B\r\n     */\r\n    static fromHex(hex) {\r\n        let reg = /^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6}|[0-9a-fA-f]{8})$/;\r\n        hex = hex.toLowerCase();\r\n        if (hex && reg.test(hex)) {\r\n            //处理三位的颜色值\r\n            if (hex.length === 4) {\r\n                var sColorNew = \"#\";\r\n                for (var i = 1; i < 4; i += 1) {\r\n                    sColorNew += hex.slice(i, i + 1).concat(hex.slice(i, i + 1));\r\n                }\r\n                hex = sColorNew;\r\n            }\r\n            //处理六位的颜色值\r\n            if (hex.length === 7) {\r\n                hex += \"ff\";\r\n            }\r\n            let sColorChange = [];\r\n            for (let i = 1; i < 9; i += 2) {\r\n                sColorChange.push(parseInt(\"0x\" + hex.slice(i, i + 2)));\r\n            }\r\n            return new Color(sColorChange[0], sColorChange[1], sColorChange[2], sColorChange[3] / 255);\r\n        }\r\n    }\r\n    /**\r\n     * 生成随机色带\r\n     * @param {Color} start - 色带起始色\r\n     * @param {Color} end - 色带终止色\r\n     * @param {number} count - 随机颜色数，默认值10个\r\n     * @return {Color} 生成随机色带\r\n     */\r\n    static ramp(start, end, count = 10) {\r\n        const colors = [];\r\n        for (let i = 0; i < count; i += 1) {\r\n            colors.push(new Color((end.r - start.r) * i / count + start.r, (end.g - start.g) * i / count + start.g, (end.b - start.b) * i / count + start.b, (end.a - start.a) * i / count + start.a));\r\n        }\r\n        return colors;\r\n    }\r\n    /**\r\n     * 生成随机色\r\n     * @return {Color} 生成随机色\r\n     */\r\n    static random() {\r\n        return new Color(Math.random() * 255, Math.random() * 255, Math.random() * 255);\r\n    }\r\n}\r\n","/**\r\n * 可订阅对象\r\n * @remarks\r\n * 事件监听者列表\r\n * {\r\n *    click: [clickhander1, clickhandler2, ...]\r\n *    mousemove: [mousemovehander1, mousemovehandler2, ...]\r\n * }\r\n */\r\nexport class Subject {\r\n    /**\r\n     * 事件名称数组\r\n     * [\"click\", \"mousemove\"]\r\n     * @param {string[]} events - 事件名称数组\r\n     */\r\n    constructor(events) {\r\n        this._handlers = {};\r\n        events.forEach(event => {\r\n            this._handlers[event] = []; //handlers array\r\n        });\r\n    }\r\n    /**\r\n     * 事件注册监听\r\n     * @param {string} event - 事件名称\r\n     * @param {Function} handler - 回调函数\r\n     */\r\n    on(event, handler) {\r\n        this._handlers[event].push(handler);\r\n    }\r\n    /**\r\n     * 事件取消监听\r\n     * @param {string} event - 事件名称\r\n     * @param {Function} handler - 回调函数\r\n     */\r\n    off(event, handler) {\r\n        if (Array.isArray(this._handlers[event])) {\r\n            const index = this._handlers[event].findIndex(item => item === handler);\r\n            index != -1 && this._handlers[event].splice(index, 1);\r\n        }\r\n    }\r\n    /**\r\n     * 激发事件\r\n     * @param {string} event - 事件名称\r\n     * @param {Object} param - 事件参数\r\n     */\r\n    emit(event, param) {\r\n        this._handlers[event].forEach(handler => handler(param));\r\n    }\r\n}\r\n","/**\r\n * 通用工具类\r\n * @remarks\r\n * 目前主要用于css样式管理维护\r\n * 当前代码来自leaflet\r\n */\r\nexport class Utility {\r\n    /**\r\n     * 添加css class\r\n     * @remarks\r\n     * Adds `name` to the element's class attribute.\r\n     * @param {HTMLElement} el - HTMLElement\r\n     * @param {string} name - css class name\r\n     */\r\n    static addClass(el, name) {\r\n        if (el.classList !== undefined) {\r\n            el.classList.add(name);\r\n        }\r\n        else if (!Utility.hasClass(el, name)) {\r\n            var className = Utility.getClass(el);\r\n            Utility.setClass(el, (className ? className + ' ' : '') + name);\r\n        }\r\n    }\r\n    /**\r\n     * 移除css class\r\n     * @remarks\r\n     * Removes `name` from the element's class attribute.\r\n     * @param {HTMLElement} el - HTMLElement\r\n     * @param {string} name - css class name\r\n     */\r\n    static removeClass(el, name) {\r\n        if (el.classList !== undefined) {\r\n            el.classList.remove(name);\r\n        }\r\n        else {\r\n            Utility.setClass(el, (' ' + Utility.getClass(el) + ' ').replace(' ' + name + ' ', ' ').trim());\r\n        }\r\n    }\r\n    /**\r\n     * 检测是否含有css class\r\n     * @remarks\r\n     * Returns `true` if the element's class attribute contains `name`.\r\n     * @param {HTMLElement} el - HTMLElement\r\n     * @param {string} name - css class name\r\n     * @return {boolean} 是否含有\r\n     */\r\n    static hasClass(el, name) {\r\n        if (el.classList !== undefined) {\r\n            return el.classList.contains(name);\r\n        }\r\n        var className = Utility.getClass(el);\r\n        return className.length > 0 && new RegExp('(^|\\\\s)' + name + '(\\\\s|$)').test(className);\r\n    }\r\n    /**\r\n     * 设置css class\r\n     * @remarks\r\n     * Sets the element's class.\r\n     * @param {HTMLElement} el - HTMLElement\r\n     * @param {string} name - css class name\r\n     */\r\n    static setClass(el, name) {\r\n        if (el.className.baseVal === undefined) {\r\n            el.className = name;\r\n        }\r\n        else {\r\n            // in case of SVG element\r\n            el.className.baseVal = name;\r\n        }\r\n    }\r\n    /**\r\n     * 获取css class\r\n     * @remarks\r\n     * Returns the element's class.\r\n     * @param {HTMLElement} el - HTMLElement\r\n     * @return {string} css class name\r\n     */\r\n    static getClass(el) {\r\n        // Check if the element is an SVGElementInstance and use the correspondingElement instead\r\n        // (Required for linked SVG elements in IE11.)\r\n        if (el.correspondingElement) {\r\n            el = el.correspondingElement;\r\n        }\r\n        return el.className.baseVal === undefined ? el.className : el.className.baseVal;\r\n    }\r\n}\r\n","import { FeatureLayer } from \"./layer/feature-layer\";\r\nimport { Subject } from \"./util/subject\";\r\n/**\r\n * Viewer\r\n * 相对于Editor，管理所有非编辑状态下的图层\r\n * 优化的产物\r\n */\r\nexport class Viewer extends Subject {\r\n    /**\r\n     * 创建Viewer\r\n     * 不应自主创建，map内部创建\r\n     * @param {Map} map - 地图容器\r\n     */\r\n    constructor(map) {\r\n        super([\"mouseover\", \"mouseout\"]); //when mouseover feature\r\n        //图层列表\r\n        this._layers = [];\r\n        this._map = map;\r\n        const container = map.container;\r\n        //create canvas\r\n        this._canvas = document.createElement(\"canvas\");\r\n        this._canvas.style.cssText = \"position: absolute; height: 100%; width: 100%;\";\r\n        this._canvas.width = container.clientWidth;\r\n        this._canvas.height = container.clientHeight;\r\n        container.appendChild(this._canvas);\r\n        this._onResize = this._onResize.bind(this);\r\n        this._extentChange = this._extentChange.bind(this);\r\n        this._onClick = this._onClick.bind(this);\r\n        this._onDoubleClick = this._onDoubleClick.bind(this);\r\n        this._onMouseMove = this._onMouseMove.bind(this);\r\n        this._ctx = this._canvas.getContext(\"2d\");\r\n        this._map.on(\"resize\", this._onResize);\r\n        this._map.on(\"extent\", this._extentChange);\r\n        this._map.on(\"click\", this._onClick);\r\n        this._map.on(\"dblclick\", this._onDoubleClick);\r\n        this._map.on(\"mousemove\", this._onMouseMove);\r\n    }\r\n    //与主视图同步\r\n    _onResize(event) {\r\n        this._canvas.width = this._map.container.clientWidth;\r\n        this._canvas.height = this._map.container.clientHeight;\r\n    }\r\n    //与主视图同步\r\n    _extentChange(event) {\r\n        //const matrix = DOMMatrix.fromFloat64Array( new Float64Array([event.matrix.a, 0, 0, event.matrix.d, event.matrix.e, event.matrix.f] ) );\r\n        //this._ctx.setTransform(matrix);\r\n        this._ctx.setTransform(event.matrix.a, 0, 0, event.matrix.d, event.matrix.e, event.matrix.f);\r\n        this.redraw();\r\n    }\r\n    //接管click事件\r\n    _onClick(event) {\r\n        const layers = [...this._layers];\r\n        layers.filter(layer => layer instanceof FeatureLayer && layer.interactive && !layer.editing).reverse().some((layer) => layer.contain(event.offsetX, event.offsetY, this._map.projection, this._map.extent, this._map.zoom, \"click\"));\r\n    }\r\n    //接管doubleclick事件\r\n    _onDoubleClick(event) {\r\n        const layers = [...this._layers];\r\n        layers.filter(layer => layer instanceof FeatureLayer && layer.interactive && !layer.editing).reverse().some((layer) => layer.contain(event.offsetX, event.offsetY, this._map.projection, this._map.extent, this._map.zoom, \"dblclick\"));\r\n    }\r\n    //接管mousemove事件\r\n    _onMouseMove(event) {\r\n        //if call Array.some, maybe abort mouseout last feature which mouseover!!! but filter maybe cause slow!!!no choice\r\n        //const flag = this._layers.filter(layer => (layer instanceof FeatureLayer) && layer.interactive).some((layer: FeatureLayer) => layer.contain(event.offsetX, event.offsetY, this._projection, this._extent, \"mousemove\"));\r\n        const layers = this._layers.filter(layer => layer instanceof FeatureLayer && layer.interactive && !layer.editing).filter((layer) => layer.contain(event.offsetX, event.offsetY, this._map.projection, this._map.extent, this._map.zoom, \"mousemove\"));\r\n        if (layers.length > 0) {\r\n            this.emit(\"mouseover\", event);\r\n        }\r\n        else {\r\n            this.emit(\"mouseout\", event);\r\n        }\r\n    }\r\n    /**\r\n     * 添加图层\r\n     * @param {Layer} layer - 图层\r\n     */\r\n    addLayer(layer) {\r\n        this._layers.push(layer);\r\n        this.redraw();\r\n    }\r\n    /**\r\n     * 插入图层\r\n     * @param {Layer} layer - 图层\r\n     * @param {number} index - 图层顺序\r\n     */\r\n    insertLayer(layer, index = -1) {\r\n        index = index > this._layers.length ? -1 : index;\r\n        if (index == -1) {\r\n            this.addLayer(layer);\r\n        }\r\n        else {\r\n            this._layers.splice(index, 0, layer);\r\n            this.redraw();\r\n        }\r\n    }\r\n    /**\r\n     * 移除图层\r\n     * @param {Layer} layer - 图层\r\n     */\r\n    removeLayer(layer) {\r\n        const index = this._layers.findIndex(item => item === layer);\r\n        index != -1 && this._layers.splice(index, 1);\r\n        this.redraw();\r\n    }\r\n    /**\r\n     * 清空图层\r\n     */\r\n    clearLayers() {\r\n        this._layers = [];\r\n        this.redraw();\r\n    }\r\n    /**\r\n     * 重绘\r\n     */\r\n    redraw() {\r\n        //const t0 = performance.now();\r\n        this._ctx.save();\r\n        this._ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n        this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);\r\n        this._ctx.restore();\r\n        this._layers.sort((a, b) => a.index - b.index).filter(layer => (layer instanceof FeatureLayer && !layer.editing) || !(layer instanceof FeatureLayer)).forEach(layer => {\r\n            layer.draw(this._ctx, this._map.projection, this._map.extent, this._map.zoom);\r\n        });\r\n        this._layers.filter(layer => layer instanceof FeatureLayer && layer.labeled && !layer.editing).forEach((layer) => {\r\n            layer.drawLabel(this._ctx, this._map.projection, this._map.extent, this._map.zoom);\r\n        });\r\n        //const t1 = performance.now();\r\n        //console.log(`Call to redraw took ${t1 - t0} milliseconds.`);\r\n    }\r\n    /**\r\n     * 清空画布\r\n     */\r\n    clear() {\r\n        this._ctx.save();\r\n        this._ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n        this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);\r\n        this._ctx.restore();\r\n    }\r\n    /**\r\n     * 销毁\r\n     */\r\n    destroy() {\r\n        this._map.off(\"resize\", this._onResize);\r\n        this._map.off(\"extent\", this._extentChange);\r\n        this._map.off(\"click\", this._onClick);\r\n        this._map.off(\"dblclick\", this._onDoubleClick);\r\n        this._map.off(\"mousemove\", this._onMouseMove);\r\n    }\r\n}\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import {\r\n    Map,\r\n    Point, Feature,\r\n    FeatureClass,\r\n    FeatureLayer,\r\n    SimpleRenderer,\r\n    Label, SimpleTextSymbol, CoverCollision, SimpleMarkerSymbol,\r\n    Field,\r\n    FieldType,\r\n    GeometryType,\r\n    ClusterType\r\n} from \"../dist\";\r\n\r\nwindow.load = async () => {\r\n    const amap = new AMap.Map(\"amap\", {\r\n        fadeOnZoom: false,\r\n        navigationMode: 'classic',\r\n        optimizePanAnimation: false,\r\n        animateEnable: false,\r\n        dragEnable: false,\r\n        zoomEnable: false,\r\n        resizeEnable: true,\r\n        doubleClickZoom: false,\r\n        keyboardEnable: false,\r\n        scrollWheel: false,\r\n        expandZoomRange: true,\r\n        zooms: [1, 20],\r\n        mapStyle: 'normal',\r\n        features: ['road', 'point', 'bg'],\r\n        viewMode: '2D'\r\n    });\r\n\r\n    const map = new Map(\"foo\");\r\n    map.on(\"extent\", (event) => {\r\n        amap.setZoomAndCenter(event.zoom, event.center);\r\n    });\r\n\r\n    //随机生成点数据\r\n    const random = (lng, lat) => {\r\n        return [lng + Math.random() - 0.5, lat + Math.random() - 0.5];\r\n    };\r\n    const featureClass = new FeatureClass(GeometryType.Point);\r\n    const field = new Field();\r\n    field.name = \"name\";\r\n    field.type = FieldType.String;\r\n    featureClass.addField(field)\r\n    for (let i = 0; i < 100000; i++) {\r\n        const lnglat = random(109.519, 18.271);\r\n        const point = new Point(lnglat[0], lnglat[1]);\r\n        const feature = new Feature(point, {name: \"标注\" + i});\r\n        featureClass.addFeature(feature);\r\n    }\r\n    const featureLayer = new FeatureLayer();\r\n    featureLayer.featureClass = featureClass;\r\n    const renderer = new SimpleRenderer();\r\n    const marker = new SimpleMarkerSymbol();\r\n    marker.width = 32;\r\n    marker.height = 32;\r\n    marker.offsetX = -16;\r\n    marker.offsetY = -32;\r\n    marker.url = \"assets/img/marker.svg\";\r\n    await marker.load();\r\n    renderer.symbol = marker;\r\n    //featureLayer.cluster = true;\r\n    featureLayer.clusterType = ClusterType.Thinning;\r\n    featureLayer.renderer = renderer;\r\n\r\n    const label = new Label();\r\n    const symbol = new SimpleTextSymbol();\r\n    symbol.pointSymbolWidth = 12;     //diameter\r\n    symbol.pointSymbolHeight = 12;   //diameter\r\n    symbol.auto = true;\r\n    label.field = field;\r\n    label.symbol = symbol;\r\n    label.collision = new CoverCollision();\r\n    //featureLayer.label = label;\r\n    //featureLayer.labeled = true;\r\n\r\n    featureLayer.zoom = [5, 20];\r\n    map.addLayer(featureLayer);\r\n\r\n    map.setView([109.519, 18.271], 13);\r\n\r\n}\r\n"],"names":[],"sourceRoot":""}